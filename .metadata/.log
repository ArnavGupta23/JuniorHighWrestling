!SESSION 2022-10-13 22:06:27.456 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=18
java.vendor=Oracle Corporation
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/arnavgupta/.eclipse_keyring
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/arnavgupta/.eclipse_keyring

This is a continuation of log file /Users/arnavgupta/eclipse-workspace/.metadata/.bak_1.log
Created Time: 2022-10-13 22:32:32.730

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-13 22:32:32.730
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4320)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3943)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:577)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-13 22:32:32.731
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4320)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3943)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:577)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-13 22:32:32.742
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package JuniorHigh;

import java.util.*;
import java.util.Enumeration;

/*
 *
 *  This is a class to holds an wrestler and all data pertaining to him/her.
 */
class Wrestler {
	private String name;
	private String seed;
	private String cert;
	private String teamName;
	private WrestlingLanguage.Grade grade;
	private WrestlingLanguage.Gender gender;
	private String trackRecord;
	private String trackWtClass;
	private boolean rosteredLastYear;
	private String trackLastYearWtClass;
	private String trackLastYearRecord;
	private WrestlingLanguage.Prestige prestigeLastYear;
	private WrestlingLanguage.Prestige prestige2YearsAgo;
	private WrestlingLanguage.Prestige prestige3YearsAgo;
	
	private Hashtable<String,Integer> matchesAtWeight=new Hashtable<String,Integer>();
	
	private int wins;
	private int losses;
	private boolean lossByInjury=false;
	private String lossByInjuryString;
	private int winByFFT;
	private int lossByFFT;

	private int winByFall;
	private int winByDec;
	private int winByMD;
	private int winByTech;
	
	private int lossByFall;
	private int lossByDec;
	private int lossByMD;
	private int lossByTech;
	
	private int weight;
	
	private Hashtable<Integer,Integer> matchWeight=new Hashtable<Integer,Integer>();

		
	private WeighInHistory wiHistory;
	
	/* These 2 attributes are used to force where we put the wrestler in the reporting
	 * order.
	 */
	private String forceWeight=null;  /* for reporting force the use of this weight class. */
	private Integer forceRank=null;  /* for reporting this is the rank order withing the weight class. */

	public void setLossByInjuryString(String s) {
		lossByInjuryString = s;
	}
	public String getLossByInjuryString() { return lossByInjuryString; }
	
	public String getLowestWeightWrestled() {
		int lowInt=99999;
		
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
			int i =  Integer.parseInt(key);
		    if (i < lowInt ) {
		    	lowInt = i;
		    }
		}
		return Integer.toString(lowInt);
	}
	public String getPrintWeight() {
		if ( forceWeight != null ) {
			if ( forceWeight.length() > 0 ) {
				return forceWeight;
			}
		}
		return getLowestWeightWrestled();
	}
	public int getPrintRank() {
		if (forceRank == null ) {
			return getWins() + getLosses();
		} else {
			return 100000 - forceRank.intValue();
		}
	}
	public String getForceWeight() { return forceWeight; }
	public Integer getForceRank() { return forceRank; }
	
	public void setWeight( int w ) { 
		if (matchWeight.containsKey(w)) {
			int val =matchWeight.get(w);
			matchWeight.put(w, val+1);
			
		}
		else {
		matchWeight.put(w, 1);	
		}
		
	}
	public String getWeight() {
		Enumeration<Integer> e = matchWeight.keys();
		String WeightString="";
		while (e.hasMoreElements()) {
			 
	            // Getting the key of a particular entry
	            int keyWeight = e.nextElement();
	            int valueCount = matchWeight.get(keyWeight);
	            
	            WeightString += Integer.toString(valueCount) + "@" + Integer.toString(keyWeight) + " - ";
	             
	          
	        }
		return WeightString;
		
	}


	
	public void setForceWeight( String w ) { forceWeight = w; }
	public void setForceRank ( Integer i ) { forceRank = i; }
	
	List<Bout> bouts = new ArrayList<Bout> ();

	public List<Bout> getBouts() { return bouts; }
	
	public boolean getLossByInjury() { return lossByInjury; }
	
	public WeighInHistory getWeighInHistory() { return wiHistory; }
	
	public void setWeighInHistory(WeighInHistory wih ) { wiHistory = wih; }

	public void setPrestigeLastYear(WrestlingLanguage.Prestige p) { prestigeLastYear = p; }
	public void setPrestige2YearsAgo(WrestlingLanguage.Prestige p) { prestige2YearsAgo= p; }
	public void setPrestige3YearsAgo(WrestlingLanguage.Prestige p) { prestige3YearsAgo = p; }

	public WrestlingLanguage.Prestige getPrestigeLastYear() { return prestigeLastYear; }
	public WrestlingLanguage.Prestige getPrestige2YearsAgo() { return prestige2YearsAgo; }
	public WrestlingLanguage.Prestige getPrestige3YearsAgo() { return prestige3YearsAgo; }

    public void printVerbose () {
		System.out.println( getName() + 
			" Grade<" + getGrade() + ">" + 
			" Seed<" + getSeed() + ">" +
			" Cert<" + getCert() + ">"); 
			//" Gender<" + getGender() + "> Wt<" + 
			//getTrackWtClass() + ">" + " (" + getWins() + "W-" + 
			//getLosses() + "L) Last Year=<" + rosteredLastYear + "> Last Year Record <" + trackLastYearRecord + ">" );
    }	   
	public String getRecordString() { 
		return String.valueOf(wins) + "-" + String.valueOf(losses); 
	}
	public String getRecordBreakdown() {
		String breakdownString = "";
		boolean addedWins=false;
		if ( getWins() > 0 ) {
			breakdownString += getWins() + "W[";
			if ( getWinByFall() > 0 ) {
				breakdownString += getWinByFall() + " Pin,";
				addedWins=true;
			}
			if ( getWinByTech() > 0 ) {
				breakdownString += getWinByTech() + " TF,";
				addedWins=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getWinByMD() + " MD,";
				addedWins=true;
			}
			if ( getWinByDec() > 0 ) {
				breakdownString += getWinByDec() + " Dec,";
				addedWins=true;
			}
			if ( getWinByFFT() > 0 ) {
				breakdownString += getWinByFFT() + " FFT,";
				addedWins=true;
			}
			if ( addedWins ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "0 W";
		}
		boolean addedLosses=false;
		if ( getLosses() > 0 ) {
			breakdownString += "-" + getLosses() + "L[";
			if ( getLossByFall() > 0 ) {
				breakdownString += getLossByFall() + " Pin,";
				addedLosses=true;
			}
			if ( getLossByTech() > 0 ) {
				breakdownString += getLossByTech() + " TF,";
				addedLosses=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getLossByMD() + " MD,";
				addedLosses=true;
			}
			if ( getLossByDec() > 0 ) {
				breakdownString += getLossByDec() + " Dec,";
				addedLosses=true;
			}
			
			if ( addedLosses ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "-0L";
		}
		if ( getWins() ==0 && getLosses() == 0 ) {
			return "";
		} else {
			return breakdownString +" - "+ getWeight();
		}
	}
	public String getName() { return name; }
	public String getSeed() { return seed; }
	public String getCert() { return cert; }
	public String getTeamName() { return teamName; }
	public WrestlingLanguage.Grade getGrade() { return grade; }
	public WrestlingLanguage.Gender getGender() { return gender; }
	public String getTrackRecord() { return trackRecord; }
	public String getTrackWtClass() { return trackWtClass; }
	
	public int getWins() { return wins; }
	public int getLosses() { return losses; }
	
	public int getWinByFFT() { return winByFFT; }
	public int getWinByFall() { return winByFall; }
	public int getWinByTech() { return winByTech; }
	public int getWinByMD() { return winByMD; }
	public int getWinByDec() { return winByDec; }
	
	public int getLossByFFT() { return lossByFFT; }
	public int getLossByFall() { return lossByFall; }
	public int getLossByTech() { return lossByTech; }
	public int getLossByMD() { return lossByMD; }
	public int getLossByDec() { return lossByDec; }
	
    public Wrestler(String n, String team){
		setName(n);
		setTeamName(team);
		return;
	}
	public boolean getRosteredLastYear() { return rosteredLastYear; }
	
	public void setRosteredLastYearOn() { rosteredLastYear = true; }
	public void setRosteredLastYearOff() { rosteredLastYear = false; }
	
	public String getTrackLastYearWtClass() { return trackLastYearWtClass; }
	public String getTrackLastYearRecord() { return trackLastYearRecord; }
	
	public void setTrackLastYearWtClass(String w) { 
		trackLastYearWtClass = w; 
	}
	public void setTrackLastYearRecord(String r) {
		trackLastYearRecord = r;
	}
	
	
	public void addBout(Bout b) {
		String cmd=b.getMatchDate();
		if (cmd == null ) {
			Event e = b.getEvent();
			if ( e != null ) {
				String sss = e.getEventTitle();
				if ( wiHistory != null ) {
					String s = wiHistory.findWeighInDate(sss);
					if ( s != null ) { 
						b.setMatchDate(s);
					}
				}
			}
		}	
		
		bouts.add(b);
		addToSummary(b);
		addToMatchesAtWeight(b);
	}
	private void addToMatchesAtWeight(Bout b) {
		String w=b.getWeight();
		Integer ct = matchesAtWeight.get(w);
		if ( ct != null ) {
			ct++;
			matchesAtWeight.replace(w,ct);
		} else {
			matchesAtWeight.put(w,1);
		}
		return;
	}
	public String getMatchesAtWeightString() {

		String byWt="";
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
	
			int ct = matchesAtWeight.get(key);
			if ( byWt.length() > 0 ) { byWt=byWt + ";" ; }
			byWt=byWt + ct + "@" + key;
		}
		return byWt;
	}
	
	public void setName( String n ) {
		name = n.strip();
	}
	public void setSeed( String n ) {
		seed = n.strip();
	}
	public void setCert( String n ) {
		cert = n.strip();
	}
	public void setTeamName( String team ) {
		teamName = team;
	}
	public void setGrade5() { grade = WrestlingLanguage.Grade.G5;	}
	public void setGrade6() { grade = WrestlingLanguage.Grade.G6;	}
	public void setGrade7() { grade = WrestlingLanguage.Grade.G7;	}
	public void setGrade8() { grade = WrestlingLanguage.Grade.G8;	}
	public void setGrade(WrestlingLanguage.Grade g ) { grade=g; }
	
	public void setGenderM() { gender = WrestlingLanguage.Gender.M;	}
	public void setGenderF() { gender = WrestlingLanguage.Gender.F;	}
	public void setGender(WrestlingLanguage.Gender g ) { gender = g; }
	
	public void setTrackRecord(String rec) {
		trackRecord = rec;
	}
	public void setTrackWtClass(String w ) {
		trackWtClass = w;
	}
	public String toString() {
		return "Wrestler:" + teamName + ":" + name  ;
	}
	private void addToSummary(Bout b) {
	   if ( b.isAWin() ) {
          addWin();	
          switch ( b.getMatchResultType() ) {
			  case FFT: 
			    addWinByFFT();
				break;
			  case FALL:
			    addWinByFall();
				break;
			  case TECH:
			    addWinByTech();
				break;
			  case MD:
			    addWinByMD();
			    break;
			  case DEC:
			    addWinByDec();
				break;
			  case INJ:
			    break;
			  case DQ:
			    break;
		  }
       } else {
          addLoss();
          switch ( b.getMatchResultType() ) {

          case FFT:
			  addLossByFFT();
			    break;
			  case FALL:
			    addLossByFall();
				break;
			  case TECH:
			    addLossByTech();
				break;
			  case MD:
			    addLossByMD();
			    break;
			  case DEC:
			    addLossByDec();
				break;
			  case INJ:
			    if ( lossByInjury) {
			    	lossByInjuryString += ";";
			    } else {
			    	lossByInjury=true;
			    	lossByInjuryString= "Loss by Injury on ";
			    }
			    if ( b.getMatchDate() != null ) {
			    	lossByInjuryString += b.getMatchDate();
			    	lossByInjuryString += " ";
			    }
			    lossByInjuryString += " vs ";
			    lossByInjuryString += b.getOpponentTeam();
			    
			    break;
			  case DQ:
			    break;
		  }		  
       }		  
	}
	public void addWin() { wins++; }
	public void addLoss() { losses++; }
	public void addWinByFFT() { winByFFT++; }
	public void addWinByFall() { winByFall++; }
	public void addWinByTech() { winByTech++; }
	public void addWinByMD() { winByMD++; }
	public void addWinByDec() { winByDec++; }
	
	public void addLossByFFT() { lossByFFT++; }
	public void addLossByFall() { lossByFall++; }
	public void addLossByTech() { lossByTech++; }
	public void addLossByMD() { lossByMD++; }
	public void addLossByDec() { lossByDec++; }

	public boolean equals(Object o) {
	  if ( o == null ) { return false; }
	  if ( this == o ) { return true; }
	  if ( this.getClass() == o.getClass() ){
         Wrestler ow = (Wrestler) o;		  
	     if ( this.getName().equals(ow.getName()) && this.getTeamName().equals(ow.getTeamName())) {
			 return true;
	     }
	  }
	  return false; 
	}
	public int hashCode() {
		return getName().hashCode() + getTeamName().hashCode();
	}


public String getFinWeight() {
	String finWeight = "";
	boolean a = playedMatch();
	
	if(cert != null) {
		finWeight = cert;
	}
	else (this.cert == null&&playedMatch()== true){
		finWeight = getLowestWeightWrestled();
	}
	
	return finWeight;
}

public boolean playedMatch() {
	if (matchWeight == null) {
		return false;
}	
	return true;
}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4320)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3943)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:577)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui 4 0 2022-10-13 22:32:32.743
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4320)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3943)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:577)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-13 22:32:33.407
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package JuniorHigh;

import java.util.*;
import java.util.Enumeration;

/*
 *
 *  This is a class to holds an wrestler and all data pertaining to him/her.
 */
class Wrestler {
	private String name;
	private String seed;
	private String cert;
	private String teamName;
	private WrestlingLanguage.Grade grade;
	private WrestlingLanguage.Gender gender;
	private String trackRecord;
	private String trackWtClass;
	private boolean rosteredLastYear;
	private String trackLastYearWtClass;
	private String trackLastYearRecord;
	private WrestlingLanguage.Prestige prestigeLastYear;
	private WrestlingLanguage.Prestige prestige2YearsAgo;
	private WrestlingLanguage.Prestige prestige3YearsAgo;
	
	private Hashtable<String,Integer> matchesAtWeight=new Hashtable<String,Integer>();
	
	private int wins;
	private int losses;
	private boolean lossByInjury=false;
	private String lossByInjuryString;
	private int winByFFT;
	private int lossByFFT;

	private int winByFall;
	private int winByDec;
	private int winByMD;
	private int winByTech;
	
	private int lossByFall;
	private int lossByDec;
	private int lossByMD;
	private int lossByTech;
	
	private int weight;
	
	private Hashtable<Integer,Integer> matchWeight=new Hashtable<Integer,Integer>();

		
	private WeighInHistory wiHistory;
	
	/* These 2 attributes are used to force where we put the wrestler in the reporting
	 * order.
	 */
	private String forceWeight=null;  /* for reporting force the use of this weight class. */
	private Integer forceRank=null;  /* for reporting this is the rank order withing the weight class. */

	public void setLossByInjuryString(String s) {
		lossByInjuryString = s;
	}
	public String getLossByInjuryString() { return lossByInjuryString; }
	
	public String getLowestWeightWrestled() {
		int lowInt=99999;
		
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
			int i =  Integer.parseInt(key);
		    if (i < lowInt ) {
		    	lowInt = i;
		    }
		}
		return Integer.toString(lowInt);
	}
	public String getPrintWeight() {
		if ( forceWeight != null ) {
			if ( forceWeight.length() > 0 ) {
				return forceWeight;
			}
		}
		return getLowestWeightWrestled();
	}
	public int getPrintRank() {
		if (forceRank == null ) {
			return getWins() + getLosses();
		} else {
			return 100000 - forceRank.intValue();
		}
	}
	public String getForceWeight() { return forceWeight; }
	public Integer getForceRank() { return forceRank; }
	
	public void setWeight( int w ) { 
		if (matchWeight.containsKey(w)) {
			int val =matchWeight.get(w);
			matchWeight.put(w, val+1);
			
		}
		else {
		matchWeight.put(w, 1);	
		}
		
	}
	public String getWeight() {
		Enumeration<Integer> e = matchWeight.keys();
		String WeightString="";
		while (e.hasMoreElements()) {
			 
	            // Getting the key of a particular entry
	            int keyWeight = e.nextElement();
	            int valueCount = matchWeight.get(keyWeight);
	            
	            WeightString += Integer.toString(valueCount) + "@" + Integer.toString(keyWeight) + " - ";
	             
	          
	        }
		return WeightString;
		
	}


	
	public void setForceWeight( String w ) { forceWeight = w; }
	public void setForceRank ( Integer i ) { forceRank = i; }
	
	List<Bout> bouts = new ArrayList<Bout> ();

	public List<Bout> getBouts() { return bouts; }
	
	public boolean getLossByInjury() { return lossByInjury; }
	
	public WeighInHistory getWeighInHistory() { return wiHistory; }
	
	public void setWeighInHistory(WeighInHistory wih ) { wiHistory = wih; }

	public void setPrestigeLastYear(WrestlingLanguage.Prestige p) { prestigeLastYear = p; }
	public void setPrestige2YearsAgo(WrestlingLanguage.Prestige p) { prestige2YearsAgo= p; }
	public void setPrestige3YearsAgo(WrestlingLanguage.Prestige p) { prestige3YearsAgo = p; }

	public WrestlingLanguage.Prestige getPrestigeLastYear() { return prestigeLastYear; }
	public WrestlingLanguage.Prestige getPrestige2YearsAgo() { return prestige2YearsAgo; }
	public WrestlingLanguage.Prestige getPrestige3YearsAgo() { return prestige3YearsAgo; }

    public void printVerbose () {
		System.out.println( getName() + 
			" Grade<" + getGrade() + ">" + 
			" Seed<" + getSeed() + ">" +
			" Cert<" + getCert() + ">"); 
			//" Gender<" + getGender() + "> Wt<" + 
			//getTrackWtClass() + ">" + " (" + getWins() + "W-" + 
			//getLosses() + "L) Last Year=<" + rosteredLastYear + "> Last Year Record <" + trackLastYearRecord + ">" );
    }	   
	public String getRecordString() { 
		return String.valueOf(wins) + "-" + String.valueOf(losses); 
	}
	public String getRecordBreakdown() {
		String breakdownString = "";
		boolean addedWins=false;
		if ( getWins() > 0 ) {
			breakdownString += getWins() + "W[";
			if ( getWinByFall() > 0 ) {
				breakdownString += getWinByFall() + " Pin,";
				addedWins=true;
			}
			if ( getWinByTech() > 0 ) {
				breakdownString += getWinByTech() + " TF,";
				addedWins=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getWinByMD() + " MD,";
				addedWins=true;
			}
			if ( getWinByDec() > 0 ) {
				breakdownString += getWinByDec() + " Dec,";
				addedWins=true;
			}
			if ( getWinByFFT() > 0 ) {
				breakdownString += getWinByFFT() + " FFT,";
				addedWins=true;
			}
			if ( addedWins ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "0 W";
		}
		boolean addedLosses=false;
		if ( getLosses() > 0 ) {
			breakdownString += "-" + getLosses() + "L[";
			if ( getLossByFall() > 0 ) {
				breakdownString += getLossByFall() + " Pin,";
				addedLosses=true;
			}
			if ( getLossByTech() > 0 ) {
				breakdownString += getLossByTech() + " TF,";
				addedLosses=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getLossByMD() + " MD,";
				addedLosses=true;
			}
			if ( getLossByDec() > 0 ) {
				breakdownString += getLossByDec() + " Dec,";
				addedLosses=true;
			}
			
			if ( addedLosses ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "-0L";
		}
		if ( getWins() ==0 && getLosses() == 0 ) {
			return "";
		} else {
			return breakdownString +" - "+ getWeight();
		}
	}
	public String getName() { return name; }
	public String getSeed() { return seed; }
	public String getCert() { return cert; }
	public String getTeamName() { return teamName; }
	public WrestlingLanguage.Grade getGrade() { return grade; }
	public WrestlingLanguage.Gender getGender() { return gender; }
	public String getTrackRecord() { return trackRecord; }
	public String getTrackWtClass() { return trackWtClass; }
	
	public int getWins() { return wins; }
	public int getLosses() { return losses; }
	
	public int getWinByFFT() { return winByFFT; }
	public int getWinByFall() { return winByFall; }
	public int getWinByTech() { return winByTech; }
	public int getWinByMD() { return winByMD; }
	public int getWinByDec() { return winByDec; }
	
	public int getLossByFFT() { return lossByFFT; }
	public int getLossByFall() { return lossByFall; }
	public int getLossByTech() { return lossByTech; }
	public int getLossByMD() { return lossByMD; }
	public int getLossByDec() { return lossByDec; }
	
    public Wrestler(String n, String team){
		setName(n);
		setTeamName(team);
		return;
	}
	public boolean getRosteredLastYear() { return rosteredLastYear; }
	
	public void setRosteredLastYearOn() { rosteredLastYear = true; }
	public void setRosteredLastYearOff() { rosteredLastYear = false; }
	
	public String getTrackLastYearWtClass() { return trackLastYearWtClass; }
	public String getTrackLastYearRecord() { return trackLastYearRecord; }
	
	public void setTrackLastYearWtClass(String w) { 
		trackLastYearWtClass = w; 
	}
	public void setTrackLastYearRecord(String r) {
		trackLastYearRecord = r;
	}
	
	
	public void addBout(Bout b) {
		String cmd=b.getMatchDate();
		if (cmd == null ) {
			Event e = b.getEvent();
			if ( e != null ) {
				String sss = e.getEventTitle();
				if ( wiHistory != null ) {
					String s = wiHistory.findWeighInDate(sss);
					if ( s != null ) { 
						b.setMatchDate(s);
					}
				}
			}
		}	
		
		bouts.add(b);
		addToSummary(b);
		addToMatchesAtWeight(b);
	}
	private void addToMatchesAtWeight(Bout b) {
		String w=b.getWeight();
		Integer ct = matchesAtWeight.get(w);
		if ( ct != null ) {
			ct++;
			matchesAtWeight.replace(w,ct);
		} else {
			matchesAtWeight.put(w,1);
		}
		return;
	}
	public String getMatchesAtWeightString() {

		String byWt="";
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
	
			int ct = matchesAtWeight.get(key);
			if ( byWt.length() > 0 ) { byWt=byWt + ";" ; }
			byWt=byWt + ct + "@" + key;
		}
		return byWt;
	}
	
	public void setName( String n ) {
		name = n.strip();
	}
	public void setSeed( String n ) {
		seed = n.strip();
	}
	public void setCert( String n ) {
		cert = n.strip();
	}
	public void setTeamName( String team ) {
		teamName = team;
	}
	public void setGrade5() { grade = WrestlingLanguage.Grade.G5;	}
	public void setGrade6() { grade = WrestlingLanguage.Grade.G6;	}
	public void setGrade7() { grade = WrestlingLanguage.Grade.G7;	}
	public void setGrade8() { grade = WrestlingLanguage.Grade.G8;	}
	public void setGrade(WrestlingLanguage.Grade g ) { grade=g; }
	
	public void setGenderM() { gender = WrestlingLanguage.Gender.M;	}
	public void setGenderF() { gender = WrestlingLanguage.Gender.F;	}
	public void setGender(WrestlingLanguage.Gender g ) { gender = g; }
	
	public void setTrackRecord(String rec) {
		trackRecord = rec;
	}
	public void setTrackWtClass(String w ) {
		trackWtClass = w;
	}
	public String toString() {
		return "Wrestler:" + teamName + ":" + name  ;
	}
	private void addToSummary(Bout b) {
	   if ( b.isAWin() ) {
          addWin();	
          switch ( b.getMatchResultType() ) {
			  case FFT: 
			    addWinByFFT();
				break;
			  case FALL:
			    addWinByFall();
				break;
			  case TECH:
			    addWinByTech();
				break;
			  case MD:
			    addWinByMD();
			    break;
			  case DEC:
			    addWinByDec();
				break;
			  case INJ:
			    break;
			  case DQ:
			    break;
		  }
       } else {
          addLoss();
          switch ( b.getMatchResultType() ) {

          case FFT:
			  addLossByFFT();
			    break;
			  case FALL:
			    addLossByFall();
				break;
			  case TECH:
			    addLossByTech();
				break;
			  case MD:
			    addLossByMD();
			    break;
			  case DEC:
			    addLossByDec();
				break;
			  case INJ:
			    if ( lossByInjury) {
			    	lossByInjuryString += ";";
			    } else {
			    	lossByInjury=true;
			    	lossByInjuryString= "Loss by Injury on ";
			    }
			    if ( b.getMatchDate() != null ) {
			    	lossByInjuryString += b.getMatchDate();
			    	lossByInjuryString += " ";
			    }
			    lossByInjuryString += " vs ";
			    lossByInjuryString += b.getOpponentTeam();
			    
			    break;
			  case DQ:
			    break;
		  }		  
       }		  
	}
	public void addWin() { wins++; }
	public void addLoss() { losses++; }
	public void addWinByFFT() { winByFFT++; }
	public void addWinByFall() { winByFall++; }
	public void addWinByTech() { winByTech++; }
	public void addWinByMD() { winByMD++; }
	public void addWinByDec() { winByDec++; }
	
	public void addLossByFFT() { lossByFFT++; }
	public void addLossByFall() { lossByFall++; }
	public void addLossByTech() { lossByTech++; }
	public void addLossByMD() { lossByMD++; }
	public void addLossByDec() { lossByDec++; }

	public boolean equals(Object o) {
	  if ( o == null ) { return false; }
	  if ( this == o ) { return true; }
	  if ( this.getClass() == o.getClass() ){
         Wrestler ow = (Wrestler) o;		  
	     if ( this.getName().equals(ow.getName()) && this.getTeamName().equals(ow.getTeamName())) {
			 return true;
	     }
	  }
	  return false; 
	}
	public int hashCode() {
		return getName().hashCode() + getTeamName().hashCode();
	}


public String getFinWeight() {
	String finWeight = "";
	boolean a = playedMatch();
	
	if(cert != null) {
		finWeight = cert;
	}
	else (this.cert == null&&playedMatch()== true){
		finWeight = getLowestWeightWrestled();
	}
	
	return finWeight;
}

public boolean playedMatch() {
	if (matchWeight == null) {
		return false;
}	
	return true;
}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:254)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-13 22:32:33.407
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:254)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-13 22:32:33.408
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:254)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-13 22:32:33.427
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package JuniorHigh;

import java.util.*;
import java.util.Enumeration;

/*
 *
 *  This is a class to holds an wrestler and all data pertaining to him/her.
 */
class Wrestler {
	private String name;
	private String seed;
	private String cert;
	private String teamName;
	private WrestlingLanguage.Grade grade;
	private WrestlingLanguage.Gender gender;
	private String trackRecord;
	private String trackWtClass;
	private boolean rosteredLastYear;
	private String trackLastYearWtClass;
	private String trackLastYearRecord;
	private WrestlingLanguage.Prestige prestigeLastYear;
	private WrestlingLanguage.Prestige prestige2YearsAgo;
	private WrestlingLanguage.Prestige prestige3YearsAgo;
	
	private Hashtable<String,Integer> matchesAtWeight=new Hashtable<String,Integer>();
	
	private int wins;
	private int losses;
	private boolean lossByInjury=false;
	private String lossByInjuryString;
	private int winByFFT;
	private int lossByFFT;

	private int winByFall;
	private int winByDec;
	private int winByMD;
	private int winByTech;
	
	private int lossByFall;
	private int lossByDec;
	private int lossByMD;
	private int lossByTech;
	
	private int weight;
	
	private Hashtable<Integer,Integer> matchWeight=new Hashtable<Integer,Integer>();

		
	private WeighInHistory wiHistory;
	
	/* These 2 attributes are used to force where we put the wrestler in the reporting
	 * order.
	 */
	private String forceWeight=null;  /* for reporting force the use of this weight class. */
	private Integer forceRank=null;  /* for reporting this is the rank order withing the weight class. */

	public void setLossByInjuryString(String s) {
		lossByInjuryString = s;
	}
	public String getLossByInjuryString() { return lossByInjuryString; }
	
	public String getLowestWeightWrestled() {
		int lowInt=99999;
		
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
			int i =  Integer.parseInt(key);
		    if (i < lowInt ) {
		    	lowInt = i;
		    }
		}
		return Integer.toString(lowInt);
	}
	public String getPrintWeight() {
		if ( forceWeight != null ) {
			if ( forceWeight.length() > 0 ) {
				return forceWeight;
			}
		}
		return getLowestWeightWrestled();
	}
	public int getPrintRank() {
		if (forceRank == null ) {
			return getWins() + getLosses();
		} else {
			return 100000 - forceRank.intValue();
		}
	}
	public String getForceWeight() { return forceWeight; }
	public Integer getForceRank() { return forceRank; }
	
	public void setWeight( int w ) { 
		if (matchWeight.containsKey(w)) {
			int val =matchWeight.get(w);
			matchWeight.put(w, val+1);
			
		}
		else {
		matchWeight.put(w, 1);	
		}
		
	}
	public String getWeight() {
		Enumeration<Integer> e = matchWeight.keys();
		String WeightString="";
		while (e.hasMoreElements()) {
			 
	            // Getting the key of a particular entry
	            int keyWeight = e.nextElement();
	            int valueCount = matchWeight.get(keyWeight);
	            
	            WeightString += Integer.toString(valueCount) + "@" + Integer.toString(keyWeight) + " - ";
	             
	          
	        }
		return WeightString;
		
	}


	
	public void setForceWeight( String w ) { forceWeight = w; }
	public void setForceRank ( Integer i ) { forceRank = i; }
	
	List<Bout> bouts = new ArrayList<Bout> ();

	public List<Bout> getBouts() { return bouts; }
	
	public boolean getLossByInjury() { return lossByInjury; }
	
	public WeighInHistory getWeighInHistory() { return wiHistory; }
	
	public void setWeighInHistory(WeighInHistory wih ) { wiHistory = wih; }

	public void setPrestigeLastYear(WrestlingLanguage.Prestige p) { prestigeLastYear = p; }
	public void setPrestige2YearsAgo(WrestlingLanguage.Prestige p) { prestige2YearsAgo= p; }
	public void setPrestige3YearsAgo(WrestlingLanguage.Prestige p) { prestige3YearsAgo = p; }

	public WrestlingLanguage.Prestige getPrestigeLastYear() { return prestigeLastYear; }
	public WrestlingLanguage.Prestige getPrestige2YearsAgo() { return prestige2YearsAgo; }
	public WrestlingLanguage.Prestige getPrestige3YearsAgo() { return prestige3YearsAgo; }

    public void printVerbose () {
		System.out.println( getName() + 
			" Grade<" + getGrade() + ">" + 
			" Seed<" + getSeed() + ">" +
			" Cert<" + getCert() + ">"); 
			//" Gender<" + getGender() + "> Wt<" + 
			//getTrackWtClass() + ">" + " (" + getWins() + "W-" + 
			//getLosses() + "L) Last Year=<" + rosteredLastYear + "> Last Year Record <" + trackLastYearRecord + ">" );
    }	   
	public String getRecordString() { 
		return String.valueOf(wins) + "-" + String.valueOf(losses); 
	}
	public String getRecordBreakdown() {
		String breakdownString = "";
		boolean addedWins=false;
		if ( getWins() > 0 ) {
			breakdownString += getWins() + "W[";
			if ( getWinByFall() > 0 ) {
				breakdownString += getWinByFall() + " Pin,";
				addedWins=true;
			}
			if ( getWinByTech() > 0 ) {
				breakdownString += getWinByTech() + " TF,";
				addedWins=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getWinByMD() + " MD,";
				addedWins=true;
			}
			if ( getWinByDec() > 0 ) {
				breakdownString += getWinByDec() + " Dec,";
				addedWins=true;
			}
			if ( getWinByFFT() > 0 ) {
				breakdownString += getWinByFFT() + " FFT,";
				addedWins=true;
			}
			if ( addedWins ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "0 W";
		}
		boolean addedLosses=false;
		if ( getLosses() > 0 ) {
			breakdownString += "-" + getLosses() + "L[";
			if ( getLossByFall() > 0 ) {
				breakdownString += getLossByFall() + " Pin,";
				addedLosses=true;
			}
			if ( getLossByTech() > 0 ) {
				breakdownString += getLossByTech() + " TF,";
				addedLosses=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getLossByMD() + " MD,";
				addedLosses=true;
			}
			if ( getLossByDec() > 0 ) {
				breakdownString += getLossByDec() + " Dec,";
				addedLosses=true;
			}
			
			if ( addedLosses ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "-0L";
		}
		if ( getWins() ==0 && getLosses() == 0 ) {
			return "";
		} else {
			return breakdownString +" - "+ getWeight();
		}
	}
	public String getName() { return name; }
	public String getSeed() { return seed; }
	public String getCert() { return cert; }
	public String getTeamName() { return teamName; }
	public WrestlingLanguage.Grade getGrade() { return grade; }
	public WrestlingLanguage.Gender getGender() { return gender; }
	public String getTrackRecord() { return trackRecord; }
	public String getTrackWtClass() { return trackWtClass; }
	
	public int getWins() { return wins; }
	public int getLosses() { return losses; }
	
	public int getWinByFFT() { return winByFFT; }
	public int getWinByFall() { return winByFall; }
	public int getWinByTech() { return winByTech; }
	public int getWinByMD() { return winByMD; }
	public int getWinByDec() { return winByDec; }
	
	public int getLossByFFT() { return lossByFFT; }
	public int getLossByFall() { return lossByFall; }
	public int getLossByTech() { return lossByTech; }
	public int getLossByMD() { return lossByMD; }
	public int getLossByDec() { return lossByDec; }
	
    public Wrestler(String n, String team){
		setName(n);
		setTeamName(team);
		return;
	}
	public boolean getRosteredLastYear() { return rosteredLastYear; }
	
	public void setRosteredLastYearOn() { rosteredLastYear = true; }
	public void setRosteredLastYearOff() { rosteredLastYear = false; }
	
	public String getTrackLastYearWtClass() { return trackLastYearWtClass; }
	public String getTrackLastYearRecord() { return trackLastYearRecord; }
	
	public void setTrackLastYearWtClass(String w) { 
		trackLastYearWtClass = w; 
	}
	public void setTrackLastYearRecord(String r) {
		trackLastYearRecord = r;
	}
	
	
	public void addBout(Bout b) {
		String cmd=b.getMatchDate();
		if (cmd == null ) {
			Event e = b.getEvent();
			if ( e != null ) {
				String sss = e.getEventTitle();
				if ( wiHistory != null ) {
					String s = wiHistory.findWeighInDate(sss);
					if ( s != null ) { 
						b.setMatchDate(s);
					}
				}
			}
		}	
		
		bouts.add(b);
		addToSummary(b);
		addToMatchesAtWeight(b);
	}
	private void addToMatchesAtWeight(Bout b) {
		String w=b.getWeight();
		Integer ct = matchesAtWeight.get(w);
		if ( ct != null ) {
			ct++;
			matchesAtWeight.replace(w,ct);
		} else {
			matchesAtWeight.put(w,1);
		}
		return;
	}
	public String getMatchesAtWeightString() {

		String byWt="";
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
	
			int ct = matchesAtWeight.get(key);
			if ( byWt.length() > 0 ) { byWt=byWt + ";" ; }
			byWt=byWt + ct + "@" + key;
		}
		return byWt;
	}
	
	public void setName( String n ) {
		name = n.strip();
	}
	public void setSeed( String n ) {
		seed = n.strip();
	}
	public void setCert( String n ) {
		cert = n.strip();
	}
	public void setTeamName( String team ) {
		teamName = team;
	}
	public void setGrade5() { grade = WrestlingLanguage.Grade.G5;	}
	public void setGrade6() { grade = WrestlingLanguage.Grade.G6;	}
	public void setGrade7() { grade = WrestlingLanguage.Grade.G7;	}
	public void setGrade8() { grade = WrestlingLanguage.Grade.G8;	}
	public void setGrade(WrestlingLanguage.Grade g ) { grade=g; }
	
	public void setGenderM() { gender = WrestlingLanguage.Gender.M;	}
	public void setGenderF() { gender = WrestlingLanguage.Gender.F;	}
	public void setGender(WrestlingLanguage.Gender g ) { gender = g; }
	
	public void setTrackRecord(String rec) {
		trackRecord = rec;
	}
	public void setTrackWtClass(String w ) {
		trackWtClass = w;
	}
	public String toString() {
		return "Wrestler:" + teamName + ":" + name  ;
	}
	private void addToSummary(Bout b) {
	   if ( b.isAWin() ) {
          addWin();	
          switch ( b.getMatchResultType() ) {
			  case FFT: 
			    addWinByFFT();
				break;
			  case FALL:
			    addWinByFall();
				break;
			  case TECH:
			    addWinByTech();
				break;
			  case MD:
			    addWinByMD();
			    break;
			  case DEC:
			    addWinByDec();
				break;
			  case INJ:
			    break;
			  case DQ:
			    break;
		  }
       } else {
          addLoss();
          switch ( b.getMatchResultType() ) {

          case FFT:
			  addLossByFFT();
			    break;
			  case FALL:
			    addLossByFall();
				break;
			  case TECH:
			    addLossByTech();
				break;
			  case MD:
			    addLossByMD();
			    break;
			  case DEC:
			    addLossByDec();
				break;
			  case INJ:
			    if ( lossByInjury) {
			    	lossByInjuryString += ";";
			    } else {
			    	lossByInjury=true;
			    	lossByInjuryString= "Loss by Injury on ";
			    }
			    if ( b.getMatchDate() != null ) {
			    	lossByInjuryString += b.getMatchDate();
			    	lossByInjuryString += " ";
			    }
			    lossByInjuryString += " vs ";
			    lossByInjuryString += b.getOpponentTeam();
			    
			    break;
			  case DQ:
			    break;
		  }		  
       }		  
	}
	public void addWin() { wins++; }
	public void addLoss() { losses++; }
	public void addWinByFFT() { winByFFT++; }
	public void addWinByFall() { winByFall++; }
	public void addWinByTech() { winByTech++; }
	public void addWinByMD() { winByMD++; }
	public void addWinByDec() { winByDec++; }
	
	public void addLossByFFT() { lossByFFT++; }
	public void addLossByFall() { lossByFall++; }
	public void addLossByTech() { lossByTech++; }
	public void addLossByMD() { lossByMD++; }
	public void addLossByDec() { lossByDec++; }

	public boolean equals(Object o) {
	  if ( o == null ) { return false; }
	  if ( this == o ) { return true; }
	  if ( this.getClass() == o.getClass() ){
         Wrestler ow = (Wrestler) o;		  
	     if ( this.getName().equals(ow.getName()) && this.getTeamName().equals(ow.getTeamName())) {
			 return true;
	     }
	  }
	  return false; 
	}
	public int hashCode() {
		return getName().hashCode() + getTeamName().hashCode();
	}


public String getFinWeight() {
	String finWeight = "";
	boolean a = playedMatch();
	
	if(cert != null) {
		finWeight = cert;
	}
	else (this.cert == null&&playedMatch()== true){
		finWeight = getLowestWeightWrestled();
	}
	
	return finWeight;
}

public boolean playedMatch() {
	if (matchWeight == null) {
		return false;
}	
	return true;
}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-13 22:32:33.428
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-13 22:32:33.428
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-13 22:32:37.488
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package JuniorHigh;

import java.util.*;
import java.util.Enumeration;

/*
 *
 *  This is a class to holds an wrestler and all data pertaining to him/her.
 */
class Wrestler {
	private String name;
	private String seed;
	private String cert;
	private String teamName;
	private WrestlingLanguage.Grade grade;
	private WrestlingLanguage.Gender gender;
	private String trackRecord;
	private String trackWtClass;
	private boolean rosteredLastYear;
	private String trackLastYearWtClass;
	private String trackLastYearRecord;
	private WrestlingLanguage.Prestige prestigeLastYear;
	private WrestlingLanguage.Prestige prestige2YearsAgo;
	private WrestlingLanguage.Prestige prestige3YearsAgo;
	
	private Hashtable<String,Integer> matchesAtWeight=new Hashtable<String,Integer>();
	
	private int wins;
	private int losses;
	private boolean lossByInjury=false;
	private String lossByInjuryString;
	private int winByFFT;
	private int lossByFFT;

	private int winByFall;
	private int winByDec;
	private int winByMD;
	private int winByTech;
	
	private int lossByFall;
	private int lossByDec;
	private int lossByMD;
	private int lossByTech;
	
	private int weight;
	
	private Hashtable<Integer,Integer> matchWeight=new Hashtable<Integer,Integer>();

		
	private WeighInHistory wiHistory;
	
	/* These 2 attributes are used to force where we put the wrestler in the reporting
	 * order.
	 */
	private String forceWeight=null;  /* for reporting force the use of this weight class. */
	private Integer forceRank=null;  /* for reporting this is the rank order withing the weight class. */

	public void setLossByInjuryString(String s) {
		lossByInjuryString = s;
	}
	public String getLossByInjuryString() { return lossByInjuryString; }
	
	public String getLowestWeightWrestled() {
		int lowInt=99999;
		
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
			int i =  Integer.parseInt(key);
		    if (i < lowInt ) {
		    	lowInt = i;
		    }
		}
		return Integer.toString(lowInt);
	}
	public String getPrintWeight() {
		if ( forceWeight != null ) {
			if ( forceWeight.length() > 0 ) {
				return forceWeight;
			}
		}
		return getLowestWeightWrestled();
	}
	public int getPrintRank() {
		if (forceRank == null ) {
			return getWins() + getLosses();
		} else {
			return 100000 - forceRank.intValue();
		}
	}
	public String getForceWeight() { return forceWeight; }
	public Integer getForceRank() { return forceRank; }
	
	public void setWeight( int w ) { 
		if (matchWeight.containsKey(w)) {
			int val =matchWeight.get(w);
			matchWeight.put(w, val+1);
			
		}
		else {
		matchWeight.put(w, 1);	
		}
		
	}
	public String getWeight() {
		Enumeration<Integer> e = matchWeight.keys();
		String WeightString="";
		while (e.hasMoreElements()) {
			 
	            // Getting the key of a particular entry
	            int keyWeight = e.nextElement();
	            int valueCount = matchWeight.get(keyWeight);
	            
	            WeightString += Integer.toString(valueCount) + "@" + Integer.toString(keyWeight) + " - ";
	             
	          
	        }
		return WeightString;
		
	}


	
	public void setForceWeight( String w ) { forceWeight = w; }
	public void setForceRank ( Integer i ) { forceRank = i; }
	
	List<Bout> bouts = new ArrayList<Bout> ();

	public List<Bout> getBouts() { return bouts; }
	
	public boolean getLossByInjury() { return lossByInjury; }
	
	public WeighInHistory getWeighInHistory() { return wiHistory; }
	
	public void setWeighInHistory(WeighInHistory wih ) { wiHistory = wih; }

	public void setPrestigeLastYear(WrestlingLanguage.Prestige p) { prestigeLastYear = p; }
	public void setPrestige2YearsAgo(WrestlingLanguage.Prestige p) { prestige2YearsAgo= p; }
	public void setPrestige3YearsAgo(WrestlingLanguage.Prestige p) { prestige3YearsAgo = p; }

	public WrestlingLanguage.Prestige getPrestigeLastYear() { return prestigeLastYear; }
	public WrestlingLanguage.Prestige getPrestige2YearsAgo() { return prestige2YearsAgo; }
	public WrestlingLanguage.Prestige getPrestige3YearsAgo() { return prestige3YearsAgo; }

    public void printVerbose () {
		System.out.println( getName() + 
			" Grade<" + getGrade() + ">" + 
			" Seed<" + getSeed() + ">" +
			" Cert<" + getCert() + ">"); 
			//" Gender<" + getGender() + "> Wt<" + 
			//getTrackWtClass() + ">" + " (" + getWins() + "W-" + 
			//getLosses() + "L) Last Year=<" + rosteredLastYear + "> Last Year Record <" + trackLastYearRecord + ">" );
    }	   
	public String getRecordString() { 
		return String.valueOf(wins) + "-" + String.valueOf(losses); 
	}
	public String getRecordBreakdown() {
		String breakdownString = "";
		boolean addedWins=false;
		if ( getWins() > 0 ) {
			breakdownString += getWins() + "W[";
			if ( getWinByFall() > 0 ) {
				breakdownString += getWinByFall() + " Pin,";
				addedWins=true;
			}
			if ( getWinByTech() > 0 ) {
				breakdownString += getWinByTech() + " TF,";
				addedWins=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getWinByMD() + " MD,";
				addedWins=true;
			}
			if ( getWinByDec() > 0 ) {
				breakdownString += getWinByDec() + " Dec,";
				addedWins=true;
			}
			if ( getWinByFFT() > 0 ) {
				breakdownString += getWinByFFT() + " FFT,";
				addedWins=true;
			}
			if ( addedWins ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "0 W";
		}
		boolean addedLosses=false;
		if ( getLosses() > 0 ) {
			breakdownString += "-" + getLosses() + "L[";
			if ( getLossByFall() > 0 ) {
				breakdownString += getLossByFall() + " Pin,";
				addedLosses=true;
			}
			if ( getLossByTech() > 0 ) {
				breakdownString += getLossByTech() + " TF,";
				addedLosses=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getLossByMD() + " MD,";
				addedLosses=true;
			}
			if ( getLossByDec() > 0 ) {
				breakdownString += getLossByDec() + " Dec,";
				addedLosses=true;
			}
			
			if ( addedLosses ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "-0L";
		}
		if ( getWins() ==0 && getLosses() == 0 ) {
			return "";
		} else {
			return breakdownString +" - "+ getWeight();
		}
	}
	public String getName() { return name; }
	public String getSeed() { return seed; }
	public String getCert() { return cert; }
	public String getTeamName() { return teamName; }
	public WrestlingLanguage.Grade getGrade() { return grade; }
	public WrestlingLanguage.Gender getGender() { return gender; }
	public String getTrackRecord() { return trackRecord; }
	public String getTrackWtClass() { return trackWtClass; }
	
	public int getWins() { return wins; }
	public int getLosses() { return losses; }
	
	public int getWinByFFT() { return winByFFT; }
	public int getWinByFall() { return winByFall; }
	public int getWinByTech() { return winByTech; }
	public int getWinByMD() { return winByMD; }
	public int getWinByDec() { return winByDec; }
	
	public int getLossByFFT() { return lossByFFT; }
	public int getLossByFall() { return lossByFall; }
	public int getLossByTech() { return lossByTech; }
	public int getLossByMD() { return lossByMD; }
	public int getLossByDec() { return lossByDec; }
	
    public Wrestler(String n, String team){
		setName(n);
		setTeamName(team);
		return;
	}
	public boolean getRosteredLastYear() { return rosteredLastYear; }
	
	public void setRosteredLastYearOn() { rosteredLastYear = true; }
	public void setRosteredLastYearOff() { rosteredLastYear = false; }
	
	public String getTrackLastYearWtClass() { return trackLastYearWtClass; }
	public String getTrackLastYearRecord() { return trackLastYearRecord; }
	
	public void setTrackLastYearWtClass(String w) { 
		trackLastYearWtClass = w; 
	}
	public void setTrackLastYearRecord(String r) {
		trackLastYearRecord = r;
	}
	
	
	public void addBout(Bout b) {
		String cmd=b.getMatchDate();
		if (cmd == null ) {
			Event e = b.getEvent();
			if ( e != null ) {
				String sss = e.getEventTitle();
				if ( wiHistory != null ) {
					String s = wiHistory.findWeighInDate(sss);
					if ( s != null ) { 
						b.setMatchDate(s);
					}
				}
			}
		}	
		
		bouts.add(b);
		addToSummary(b);
		addToMatchesAtWeight(b);
	}
	private void addToMatchesAtWeight(Bout b) {
		String w=b.getWeight();
		Integer ct = matchesAtWeight.get(w);
		if ( ct != null ) {
			ct++;
			matchesAtWeight.replace(w,ct);
		} else {
			matchesAtWeight.put(w,1);
		}
		return;
	}
	public String getMatchesAtWeightString() {

		String byWt="";
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
	
			int ct = matchesAtWeight.get(key);
			if ( byWt.length() > 0 ) { byWt=byWt + ";" ; }
			byWt=byWt + ct + "@" + key;
		}
		return byWt;
	}
	
	public void setName( String n ) {
		name = n.strip();
	}
	public void setSeed( String n ) {
		seed = n.strip();
	}
	public void setCert( String n ) {
		cert = n.strip();
	}
	public void setTeamName( String team ) {
		teamName = team;
	}
	public void setGrade5() { grade = WrestlingLanguage.Grade.G5;	}
	public void setGrade6() { grade = WrestlingLanguage.Grade.G6;	}
	public void setGrade7() { grade = WrestlingLanguage.Grade.G7;	}
	public void setGrade8() { grade = WrestlingLanguage.Grade.G8;	}
	public void setGrade(WrestlingLanguage.Grade g ) { grade=g; }
	
	public void setGenderM() { gender = WrestlingLanguage.Gender.M;	}
	public void setGenderF() { gender = WrestlingLanguage.Gender.F;	}
	public void setGender(WrestlingLanguage.Gender g ) { gender = g; }
	
	public void setTrackRecord(String rec) {
		trackRecord = rec;
	}
	public void setTrackWtClass(String w ) {
		trackWtClass = w;
	}
	public String toString() {
		return "Wrestler:" + teamName + ":" + name  ;
	}
	private void addToSummary(Bout b) {
	   if ( b.isAWin() ) {
          addWin();	
          switch ( b.getMatchResultType() ) {
			  case FFT: 
			    addWinByFFT();
				break;
			  case FALL:
			    addWinByFall();
				break;
			  case TECH:
			    addWinByTech();
				break;
			  case MD:
			    addWinByMD();
			    break;
			  case DEC:
			    addWinByDec();
				break;
			  case INJ:
			    break;
			  case DQ:
			    break;
		  }
       } else {
          addLoss();
          switch ( b.getMatchResultType() ) {

          case FFT:
			  addLossByFFT();
			    break;
			  case FALL:
			    addLossByFall();
				break;
			  case TECH:
			    addLossByTech();
				break;
			  case MD:
			    addLossByMD();
			    break;
			  case DEC:
			    addLossByDec();
				break;
			  case INJ:
			    if ( lossByInjury) {
			    	lossByInjuryString += ";";
			    } else {
			    	lossByInjury=true;
			    	lossByInjuryString= "Loss by Injury on ";
			    }
			    if ( b.getMatchDate() != null ) {
			    	lossByInjuryString += b.getMatchDate();
			    	lossByInjuryString += " ";
			    }
			    lossByInjuryString += " vs ";
			    lossByInjuryString += b.getOpponentTeam();
			    
			    break;
			  case DQ:
			    break;
		  }		  
       }		  
	}
	public void addWin() { wins++; }
	public void addLoss() { losses++; }
	public void addWinByFFT() { winByFFT++; }
	public void addWinByFall() { winByFall++; }
	public void addWinByTech() { winByTech++; }
	public void addWinByMD() { winByMD++; }
	public void addWinByDec() { winByDec++; }
	
	public void addLossByFFT() { lossByFFT++; }
	public void addLossByFall() { lossByFall++; }
	public void addLossByTech() { lossByTech++; }
	public void addLossByMD() { lossByMD++; }
	public void addLossByDec() { lossByDec++; }

	public boolean equals(Object o) {
	  if ( o == null ) { return false; }
	  if ( this == o ) { return true; }
	  if ( this.getClass() == o.getClass() ){
         Wrestler ow = (Wrestler) o;		  
	     if ( this.getName().equals(ow.getName()) && this.getTeamName().equals(ow.getTeamName())) {
			 return true;
	     }
	  }
	  return false; 
	}
	public int hashCode() {
		return getName().hashCode() + getTeamName().hashCode();
	}


public String getFinWeight() {
	String finWeight = "";
	boolean a = playedMatch();
	
	if(cert != null) {
		finWeight = cert;
	}
	else (this.cert == null&&thplayedMatch()== true){
		finWeight = getLowestWeightWrestled();
	}
	
	return finWeight;
}

public boolean playedMatch() {
	if (matchWeight == null) {
		return false;
}	
	return true;
}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-10-13 22:32:37.489
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-10-13 22:32:37.489
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-13 22:32:37.517
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package JuniorHigh;

import java.util.*;
import java.util.Enumeration;

/*
 *
 *  This is a class to holds an wrestler and all data pertaining to him/her.
 */
class Wrestler {
	private String name;
	private String seed;
	private String cert;
	private String teamName;
	private WrestlingLanguage.Grade grade;
	private WrestlingLanguage.Gender gender;
	private String trackRecord;
	private String trackWtClass;
	private boolean rosteredLastYear;
	private String trackLastYearWtClass;
	private String trackLastYearRecord;
	private WrestlingLanguage.Prestige prestigeLastYear;
	private WrestlingLanguage.Prestige prestige2YearsAgo;
	private WrestlingLanguage.Prestige prestige3YearsAgo;
	
	private Hashtable<String,Integer> matchesAtWeight=new Hashtable<String,Integer>();
	
	private int wins;
	private int losses;
	private boolean lossByInjury=false;
	private String lossByInjuryString;
	private int winByFFT;
	private int lossByFFT;

	private int winByFall;
	private int winByDec;
	private int winByMD;
	private int winByTech;
	
	private int lossByFall;
	private int lossByDec;
	private int lossByMD;
	private int lossByTech;
	
	private int weight;
	
	private Hashtable<Integer,Integer> matchWeight=new Hashtable<Integer,Integer>();

		
	private WeighInHistory wiHistory;
	
	/* These 2 attributes are used to force where we put the wrestler in the reporting
	 * order.
	 */
	private String forceWeight=null;  /* for reporting force the use of this weight class. */
	private Integer forceRank=null;  /* for reporting this is the rank order withing the weight class. */

	public void setLossByInjuryString(String s) {
		lossByInjuryString = s;
	}
	public String getLossByInjuryString() { return lossByInjuryString; }
	
	public String getLowestWeightWrestled() {
		int lowInt=99999;
		
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
			int i =  Integer.parseInt(key);
		    if (i < lowInt ) {
		    	lowInt = i;
		    }
		}
		return Integer.toString(lowInt);
	}
	public String getPrintWeight() {
		if ( forceWeight != null ) {
			if ( forceWeight.length() > 0 ) {
				return forceWeight;
			}
		}
		return getLowestWeightWrestled();
	}
	public int getPrintRank() {
		if (forceRank == null ) {
			return getWins() + getLosses();
		} else {
			return 100000 - forceRank.intValue();
		}
	}
	public String getForceWeight() { return forceWeight; }
	public Integer getForceRank() { return forceRank; }
	
	public void setWeight( int w ) { 
		if (matchWeight.containsKey(w)) {
			int val =matchWeight.get(w);
			matchWeight.put(w, val+1);
			
		}
		else {
		matchWeight.put(w, 1);	
		}
		
	}
	public String getWeight() {
		Enumeration<Integer> e = matchWeight.keys();
		String WeightString="";
		while (e.hasMoreElements()) {
			 
	            // Getting the key of a particular entry
	            int keyWeight = e.nextElement();
	            int valueCount = matchWeight.get(keyWeight);
	            
	            WeightString += Integer.toString(valueCount) + "@" + Integer.toString(keyWeight) + " - ";
	             
	          
	        }
		return WeightString;
		
	}


	
	public void setForceWeight( String w ) { forceWeight = w; }
	public void setForceRank ( Integer i ) { forceRank = i; }
	
	List<Bout> bouts = new ArrayList<Bout> ();

	public List<Bout> getBouts() { return bouts; }
	
	public boolean getLossByInjury() { return lossByInjury; }
	
	public WeighInHistory getWeighInHistory() { return wiHistory; }
	
	public void setWeighInHistory(WeighInHistory wih ) { wiHistory = wih; }

	public void setPrestigeLastYear(WrestlingLanguage.Prestige p) { prestigeLastYear = p; }
	public void setPrestige2YearsAgo(WrestlingLanguage.Prestige p) { prestige2YearsAgo= p; }
	public void setPrestige3YearsAgo(WrestlingLanguage.Prestige p) { prestige3YearsAgo = p; }

	public WrestlingLanguage.Prestige getPrestigeLastYear() { return prestigeLastYear; }
	public WrestlingLanguage.Prestige getPrestige2YearsAgo() { return prestige2YearsAgo; }
	public WrestlingLanguage.Prestige getPrestige3YearsAgo() { return prestige3YearsAgo; }

    public void printVerbose () {
		System.out.println( getName() + 
			" Grade<" + getGrade() + ">" + 
			" Seed<" + getSeed() + ">" +
			" Cert<" + getCert() + ">"); 
			//" Gender<" + getGender() + "> Wt<" + 
			//getTrackWtClass() + ">" + " (" + getWins() + "W-" + 
			//getLosses() + "L) Last Year=<" + rosteredLastYear + "> Last Year Record <" + trackLastYearRecord + ">" );
    }	   
	public String getRecordString() { 
		return String.valueOf(wins) + "-" + String.valueOf(losses); 
	}
	public String getRecordBreakdown() {
		String breakdownString = "";
		boolean addedWins=false;
		if ( getWins() > 0 ) {
			breakdownString += getWins() + "W[";
			if ( getWinByFall() > 0 ) {
				breakdownString += getWinByFall() + " Pin,";
				addedWins=true;
			}
			if ( getWinByTech() > 0 ) {
				breakdownString += getWinByTech() + " TF,";
				addedWins=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getWinByMD() + " MD,";
				addedWins=true;
			}
			if ( getWinByDec() > 0 ) {
				breakdownString += getWinByDec() + " Dec,";
				addedWins=true;
			}
			if ( getWinByFFT() > 0 ) {
				breakdownString += getWinByFFT() + " FFT,";
				addedWins=true;
			}
			if ( addedWins ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "0 W";
		}
		boolean addedLosses=false;
		if ( getLosses() > 0 ) {
			breakdownString += "-" + getLosses() + "L[";
			if ( getLossByFall() > 0 ) {
				breakdownString += getLossByFall() + " Pin,";
				addedLosses=true;
			}
			if ( getLossByTech() > 0 ) {
				breakdownString += getLossByTech() + " TF,";
				addedLosses=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getLossByMD() + " MD,";
				addedLosses=true;
			}
			if ( getLossByDec() > 0 ) {
				breakdownString += getLossByDec() + " Dec,";
				addedLosses=true;
			}
			
			if ( addedLosses ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "-0L";
		}
		if ( getWins() ==0 && getLosses() == 0 ) {
			return "";
		} else {
			return breakdownString +" - "+ getWeight();
		}
	}
	public String getName() { return name; }
	public String getSeed() { return seed; }
	public String getCert() { return cert; }
	public String getTeamName() { return teamName; }
	public WrestlingLanguage.Grade getGrade() { return grade; }
	public WrestlingLanguage.Gender getGender() { return gender; }
	public String getTrackRecord() { return trackRecord; }
	public String getTrackWtClass() { return trackWtClass; }
	
	public int getWins() { return wins; }
	public int getLosses() { return losses; }
	
	public int getWinByFFT() { return winByFFT; }
	public int getWinByFall() { return winByFall; }
	public int getWinByTech() { return winByTech; }
	public int getWinByMD() { return winByMD; }
	public int getWinByDec() { return winByDec; }
	
	public int getLossByFFT() { return lossByFFT; }
	public int getLossByFall() { return lossByFall; }
	public int getLossByTech() { return lossByTech; }
	public int getLossByMD() { return lossByMD; }
	public int getLossByDec() { return lossByDec; }
	
    public Wrestler(String n, String team){
		setName(n);
		setTeamName(team);
		return;
	}
	public boolean getRosteredLastYear() { return rosteredLastYear; }
	
	public void setRosteredLastYearOn() { rosteredLastYear = true; }
	public void setRosteredLastYearOff() { rosteredLastYear = false; }
	
	public String getTrackLastYearWtClass() { return trackLastYearWtClass; }
	public String getTrackLastYearRecord() { return trackLastYearRecord; }
	
	public void setTrackLastYearWtClass(String w) { 
		trackLastYearWtClass = w; 
	}
	public void setTrackLastYearRecord(String r) {
		trackLastYearRecord = r;
	}
	
	
	public void addBout(Bout b) {
		String cmd=b.getMatchDate();
		if (cmd == null ) {
			Event e = b.getEvent();
			if ( e != null ) {
				String sss = e.getEventTitle();
				if ( wiHistory != null ) {
					String s = wiHistory.findWeighInDate(sss);
					if ( s != null ) { 
						b.setMatchDate(s);
					}
				}
			}
		}	
		
		bouts.add(b);
		addToSummary(b);
		addToMatchesAtWeight(b);
	}
	private void addToMatchesAtWeight(Bout b) {
		String w=b.getWeight();
		Integer ct = matchesAtWeight.get(w);
		if ( ct != null ) {
			ct++;
			matchesAtWeight.replace(w,ct);
		} else {
			matchesAtWeight.put(w,1);
		}
		return;
	}
	public String getMatchesAtWeightString() {

		String byWt="";
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
	
			int ct = matchesAtWeight.get(key);
			if ( byWt.length() > 0 ) { byWt=byWt + ";" ; }
			byWt=byWt + ct + "@" + key;
		}
		return byWt;
	}
	
	public void setName( String n ) {
		name = n.strip();
	}
	public void setSeed( String n ) {
		seed = n.strip();
	}
	public void setCert( String n ) {
		cert = n.strip();
	}
	public void setTeamName( String team ) {
		teamName = team;
	}
	public void setGrade5() { grade = WrestlingLanguage.Grade.G5;	}
	public void setGrade6() { grade = WrestlingLanguage.Grade.G6;	}
	public void setGrade7() { grade = WrestlingLanguage.Grade.G7;	}
	public void setGrade8() { grade = WrestlingLanguage.Grade.G8;	}
	public void setGrade(WrestlingLanguage.Grade g ) { grade=g; }
	
	public void setGenderM() { gender = WrestlingLanguage.Gender.M;	}
	public void setGenderF() { gender = WrestlingLanguage.Gender.F;	}
	public void setGender(WrestlingLanguage.Gender g ) { gender = g; }
	
	public void setTrackRecord(String rec) {
		trackRecord = rec;
	}
	public void setTrackWtClass(String w ) {
		trackWtClass = w;
	}
	public String toString() {
		return "Wrestler:" + teamName + ":" + name  ;
	}
	private void addToSummary(Bout b) {
	   if ( b.isAWin() ) {
          addWin();	
          switch ( b.getMatchResultType() ) {
			  case FFT: 
			    addWinByFFT();
				break;
			  case FALL:
			    addWinByFall();
				break;
			  case TECH:
			    addWinByTech();
				break;
			  case MD:
			    addWinByMD();
			    break;
			  case DEC:
			    addWinByDec();
				break;
			  case INJ:
			    break;
			  case DQ:
			    break;
		  }
       } else {
          addLoss();
          switch ( b.getMatchResultType() ) {

          case FFT:
			  addLossByFFT();
			    break;
			  case FALL:
			    addLossByFall();
				break;
			  case TECH:
			    addLossByTech();
				break;
			  case MD:
			    addLossByMD();
			    break;
			  case DEC:
			    addLossByDec();
				break;
			  case INJ:
			    if ( lossByInjury) {
			    	lossByInjuryString += ";";
			    } else {
			    	lossByInjury=true;
			    	lossByInjuryString= "Loss by Injury on ";
			    }
			    if ( b.getMatchDate() != null ) {
			    	lossByInjuryString += b.getMatchDate();
			    	lossByInjuryString += " ";
			    }
			    lossByInjuryString += " vs ";
			    lossByInjuryString += b.getOpponentTeam();
			    
			    break;
			  case DQ:
			    break;
		  }		  
       }		  
	}
	public void addWin() { wins++; }
	public void addLoss() { losses++; }
	public void addWinByFFT() { winByFFT++; }
	public void addWinByFall() { winByFall++; }
	public void addWinByTech() { winByTech++; }
	public void addWinByMD() { winByMD++; }
	public void addWinByDec() { winByDec++; }
	
	public void addLossByFFT() { lossByFFT++; }
	public void addLossByFall() { lossByFall++; }
	public void addLossByTech() { lossByTech++; }
	public void addLossByMD() { lossByMD++; }
	public void addLossByDec() { lossByDec++; }

	public boolean equals(Object o) {
	  if ( o == null ) { return false; }
	  if ( this == o ) { return true; }
	  if ( this.getClass() == o.getClass() ){
         Wrestler ow = (Wrestler) o;		  
	     if ( this.getName().equals(ow.getName()) && this.getTeamName().equals(ow.getTeamName())) {
			 return true;
	     }
	  }
	  return false; 
	}
	public int hashCode() {
		return getName().hashCode() + getTeamName().hashCode();
	}


public String getFinWeight() {
	String finWeight = "";
	boolean a = playedMatch();
	
	if(cert != null) {
		finWeight = cert;
	}
	else (this.cert == null&&thplayedMatch()== true){
		finWeight = getLowestWeightWrestled();
	}
	
	return finWeight;
}

public boolean playedMatch() {
	if (matchWeight == null) {
		return false;
}	
	return true;
}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-13 22:32:37.518
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-13 22:32:37.518
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-13 22:32:38.281
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package JuniorHigh;

import java.util.*;
import java.util.Enumeration;

/*
 *
 *  This is a class to holds an wrestler and all data pertaining to him/her.
 */
class Wrestler {
	private String name;
	private String seed;
	private String cert;
	private String teamName;
	private WrestlingLanguage.Grade grade;
	private WrestlingLanguage.Gender gender;
	private String trackRecord;
	private String trackWtClass;
	private boolean rosteredLastYear;
	private String trackLastYearWtClass;
	private String trackLastYearRecord;
	private WrestlingLanguage.Prestige prestigeLastYear;
	private WrestlingLanguage.Prestige prestige2YearsAgo;
	private WrestlingLanguage.Prestige prestige3YearsAgo;
	
	private Hashtable<String,Integer> matchesAtWeight=new Hashtable<String,Integer>();
	
	private int wins;
	private int losses;
	private boolean lossByInjury=false;
	private String lossByInjuryString;
	private int winByFFT;
	private int lossByFFT;

	private int winByFall;
	private int winByDec;
	private int winByMD;
	private int winByTech;
	
	private int lossByFall;
	private int lossByDec;
	private int lossByMD;
	private int lossByTech;
	
	private int weight;
	
	private Hashtable<Integer,Integer> matchWeight=new Hashtable<Integer,Integer>();

		
	private WeighInHistory wiHistory;
	
	/* These 2 attributes are used to force where we put the wrestler in the reporting
	 * order.
	 */
	private String forceWeight=null;  /* for reporting force the use of this weight class. */
	private Integer forceRank=null;  /* for reporting this is the rank order withing the weight class. */

	public void setLossByInjuryString(String s) {
		lossByInjuryString = s;
	}
	public String getLossByInjuryString() { return lossByInjuryString; }
	
	public String getLowestWeightWrestled() {
		int lowInt=99999;
		
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
			int i =  Integer.parseInt(key);
		    if (i < lowInt ) {
		    	lowInt = i;
		    }
		}
		return Integer.toString(lowInt);
	}
	public String getPrintWeight() {
		if ( forceWeight != null ) {
			if ( forceWeight.length() > 0 ) {
				return forceWeight;
			}
		}
		return getLowestWeightWrestled();
	}
	public int getPrintRank() {
		if (forceRank == null ) {
			return getWins() + getLosses();
		} else {
			return 100000 - forceRank.intValue();
		}
	}
	public String getForceWeight() { return forceWeight; }
	public Integer getForceRank() { return forceRank; }
	
	public void setWeight( int w ) { 
		if (matchWeight.containsKey(w)) {
			int val =matchWeight.get(w);
			matchWeight.put(w, val+1);
			
		}
		else {
		matchWeight.put(w, 1);	
		}
		
	}
	public String getWeight() {
		Enumeration<Integer> e = matchWeight.keys();
		String WeightString="";
		while (e.hasMoreElements()) {
			 
	            // Getting the key of a particular entry
	            int keyWeight = e.nextElement();
	            int valueCount = matchWeight.get(keyWeight);
	            
	            WeightString += Integer.toString(valueCount) + "@" + Integer.toString(keyWeight) + " - ";
	             
	          
	        }
		return WeightString;
		
	}


	
	public void setForceWeight( String w ) { forceWeight = w; }
	public void setForceRank ( Integer i ) { forceRank = i; }
	
	List<Bout> bouts = new ArrayList<Bout> ();

	public List<Bout> getBouts() { return bouts; }
	
	public boolean getLossByInjury() { return lossByInjury; }
	
	public WeighInHistory getWeighInHistory() { return wiHistory; }
	
	public void setWeighInHistory(WeighInHistory wih ) { wiHistory = wih; }

	public void setPrestigeLastYear(WrestlingLanguage.Prestige p) { prestigeLastYear = p; }
	public void setPrestige2YearsAgo(WrestlingLanguage.Prestige p) { prestige2YearsAgo= p; }
	public void setPrestige3YearsAgo(WrestlingLanguage.Prestige p) { prestige3YearsAgo = p; }

	public WrestlingLanguage.Prestige getPrestigeLastYear() { return prestigeLastYear; }
	public WrestlingLanguage.Prestige getPrestige2YearsAgo() { return prestige2YearsAgo; }
	public WrestlingLanguage.Prestige getPrestige3YearsAgo() { return prestige3YearsAgo; }

    public void printVerbose () {
		System.out.println( getName() + 
			" Grade<" + getGrade() + ">" + 
			" Seed<" + getSeed() + ">" +
			" Cert<" + getCert() + ">"); 
			//" Gender<" + getGender() + "> Wt<" + 
			//getTrackWtClass() + ">" + " (" + getWins() + "W-" + 
			//getLosses() + "L) Last Year=<" + rosteredLastYear + "> Last Year Record <" + trackLastYearRecord + ">" );
    }	   
	public String getRecordString() { 
		return String.valueOf(wins) + "-" + String.valueOf(losses); 
	}
	public String getRecordBreakdown() {
		String breakdownString = "";
		boolean addedWins=false;
		if ( getWins() > 0 ) {
			breakdownString += getWins() + "W[";
			if ( getWinByFall() > 0 ) {
				breakdownString += getWinByFall() + " Pin,";
				addedWins=true;
			}
			if ( getWinByTech() > 0 ) {
				breakdownString += getWinByTech() + " TF,";
				addedWins=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getWinByMD() + " MD,";
				addedWins=true;
			}
			if ( getWinByDec() > 0 ) {
				breakdownString += getWinByDec() + " Dec,";
				addedWins=true;
			}
			if ( getWinByFFT() > 0 ) {
				breakdownString += getWinByFFT() + " FFT,";
				addedWins=true;
			}
			if ( addedWins ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "0 W";
		}
		boolean addedLosses=false;
		if ( getLosses() > 0 ) {
			breakdownString += "-" + getLosses() + "L[";
			if ( getLossByFall() > 0 ) {
				breakdownString += getLossByFall() + " Pin,";
				addedLosses=true;
			}
			if ( getLossByTech() > 0 ) {
				breakdownString += getLossByTech() + " TF,";
				addedLosses=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getLossByMD() + " MD,";
				addedLosses=true;
			}
			if ( getLossByDec() > 0 ) {
				breakdownString += getLossByDec() + " Dec,";
				addedLosses=true;
			}
			
			if ( addedLosses ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "-0L";
		}
		if ( getWins() ==0 && getLosses() == 0 ) {
			return "";
		} else {
			return breakdownString +" - "+ getWeight();
		}
	}
	public String getName() { return name; }
	public String getSeed() { return seed; }
	public String getCert() { return cert; }
	public String getTeamName() { return teamName; }
	public WrestlingLanguage.Grade getGrade() { return grade; }
	public WrestlingLanguage.Gender getGender() { return gender; }
	public String getTrackRecord() { return trackRecord; }
	public String getTrackWtClass() { return trackWtClass; }
	
	public int getWins() { return wins; }
	public int getLosses() { return losses; }
	
	public int getWinByFFT() { return winByFFT; }
	public int getWinByFall() { return winByFall; }
	public int getWinByTech() { return winByTech; }
	public int getWinByMD() { return winByMD; }
	public int getWinByDec() { return winByDec; }
	
	public int getLossByFFT() { return lossByFFT; }
	public int getLossByFall() { return lossByFall; }
	public int getLossByTech() { return lossByTech; }
	public int getLossByMD() { return lossByMD; }
	public int getLossByDec() { return lossByDec; }
	
    public Wrestler(String n, String team){
		setName(n);
		setTeamName(team);
		return;
	}
	public boolean getRosteredLastYear() { return rosteredLastYear; }
	
	public void setRosteredLastYearOn() { rosteredLastYear = true; }
	public void setRosteredLastYearOff() { rosteredLastYear = false; }
	
	public String getTrackLastYearWtClass() { return trackLastYearWtClass; }
	public String getTrackLastYearRecord() { return trackLastYearRecord; }
	
	public void setTrackLastYearWtClass(String w) { 
		trackLastYearWtClass = w; 
	}
	public void setTrackLastYearRecord(String r) {
		trackLastYearRecord = r;
	}
	
	
	public void addBout(Bout b) {
		String cmd=b.getMatchDate();
		if (cmd == null ) {
			Event e = b.getEvent();
			if ( e != null ) {
				String sss = e.getEventTitle();
				if ( wiHistory != null ) {
					String s = wiHistory.findWeighInDate(sss);
					if ( s != null ) { 
						b.setMatchDate(s);
					}
				}
			}
		}	
		
		bouts.add(b);
		addToSummary(b);
		addToMatchesAtWeight(b);
	}
	private void addToMatchesAtWeight(Bout b) {
		String w=b.getWeight();
		Integer ct = matchesAtWeight.get(w);
		if ( ct != null ) {
			ct++;
			matchesAtWeight.replace(w,ct);
		} else {
			matchesAtWeight.put(w,1);
		}
		return;
	}
	public String getMatchesAtWeightString() {

		String byWt="";
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
	
			int ct = matchesAtWeight.get(key);
			if ( byWt.length() > 0 ) { byWt=byWt + ";" ; }
			byWt=byWt + ct + "@" + key;
		}
		return byWt;
	}
	
	public void setName( String n ) {
		name = n.strip();
	}
	public void setSeed( String n ) {
		seed = n.strip();
	}
	public void setCert( String n ) {
		cert = n.strip();
	}
	public void setTeamName( String team ) {
		teamName = team;
	}
	public void setGrade5() { grade = WrestlingLanguage.Grade.G5;	}
	public void setGrade6() { grade = WrestlingLanguage.Grade.G6;	}
	public void setGrade7() { grade = WrestlingLanguage.Grade.G7;	}
	public void setGrade8() { grade = WrestlingLanguage.Grade.G8;	}
	public void setGrade(WrestlingLanguage.Grade g ) { grade=g; }
	
	public void setGenderM() { gender = WrestlingLanguage.Gender.M;	}
	public void setGenderF() { gender = WrestlingLanguage.Gender.F;	}
	public void setGender(WrestlingLanguage.Gender g ) { gender = g; }
	
	public void setTrackRecord(String rec) {
		trackRecord = rec;
	}
	public void setTrackWtClass(String w ) {
		trackWtClass = w;
	}
	public String toString() {
		return "Wrestler:" + teamName + ":" + name  ;
	}
	private void addToSummary(Bout b) {
	   if ( b.isAWin() ) {
          addWin();	
          switch ( b.getMatchResultType() ) {
			  case FFT: 
			    addWinByFFT();
				break;
			  case FALL:
			    addWinByFall();
				break;
			  case TECH:
			    addWinByTech();
				break;
			  case MD:
			    addWinByMD();
			    break;
			  case DEC:
			    addWinByDec();
				break;
			  case INJ:
			    break;
			  case DQ:
			    break;
		  }
       } else {
          addLoss();
          switch ( b.getMatchResultType() ) {

          case FFT:
			  addLossByFFT();
			    break;
			  case FALL:
			    addLossByFall();
				break;
			  case TECH:
			    addLossByTech();
				break;
			  case MD:
			    addLossByMD();
			    break;
			  case DEC:
			    addLossByDec();
				break;
			  case INJ:
			    if ( lossByInjury) {
			    	lossByInjuryString += ";";
			    } else {
			    	lossByInjury=true;
			    	lossByInjuryString= "Loss by Injury on ";
			    }
			    if ( b.getMatchDate() != null ) {
			    	lossByInjuryString += b.getMatchDate();
			    	lossByInjuryString += " ";
			    }
			    lossByInjuryString += " vs ";
			    lossByInjuryString += b.getOpponentTeam();
			    
			    break;
			  case DQ:
			    break;
		  }		  
       }		  
	}
	public void addWin() { wins++; }
	public void addLoss() { losses++; }
	public void addWinByFFT() { winByFFT++; }
	public void addWinByFall() { winByFall++; }
	public void addWinByTech() { winByTech++; }
	public void addWinByMD() { winByMD++; }
	public void addWinByDec() { winByDec++; }
	
	public void addLossByFFT() { lossByFFT++; }
	public void addLossByFall() { lossByFall++; }
	public void addLossByTech() { lossByTech++; }
	public void addLossByMD() { lossByMD++; }
	public void addLossByDec() { lossByDec++; }

	public boolean equals(Object o) {
	  if ( o == null ) { return false; }
	  if ( this == o ) { return true; }
	  if ( this.getClass() == o.getClass() ){
         Wrestler ow = (Wrestler) o;		  
	     if ( this.getName().equals(ow.getName()) && this.getTeamName().equals(ow.getTeamName())) {
			 return true;
	     }
	  }
	  return false; 
	}
	public int hashCode() {
		return getName().hashCode() + getTeamName().hashCode();
	}


public String getFinWeight() {
	String finWeight = "";
	boolean a = playedMatch();
	
	if(cert != null) {
		finWeight = cert;
	}
	else (this.cert == null&&thisplayedMatch()== true){
		finWeight = getLowestWeightWrestled();
	}
	
	return finWeight;
}

public boolean playedMatch() {
	if (matchWeight == null) {
		return false;
}	
	return true;
}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-10-13 22:32:38.282
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-10-13 22:32:38.283
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-13 22:32:38.372
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package JuniorHigh;

import java.util.*;
import java.util.Enumeration;

/*
 *
 *  This is a class to holds an wrestler and all data pertaining to him/her.
 */
class Wrestler {
	private String name;
	private String seed;
	private String cert;
	private String teamName;
	private WrestlingLanguage.Grade grade;
	private WrestlingLanguage.Gender gender;
	private String trackRecord;
	private String trackWtClass;
	private boolean rosteredLastYear;
	private String trackLastYearWtClass;
	private String trackLastYearRecord;
	private WrestlingLanguage.Prestige prestigeLastYear;
	private WrestlingLanguage.Prestige prestige2YearsAgo;
	private WrestlingLanguage.Prestige prestige3YearsAgo;
	
	private Hashtable<String,Integer> matchesAtWeight=new Hashtable<String,Integer>();
	
	private int wins;
	private int losses;
	private boolean lossByInjury=false;
	private String lossByInjuryString;
	private int winByFFT;
	private int lossByFFT;

	private int winByFall;
	private int winByDec;
	private int winByMD;
	private int winByTech;
	
	private int lossByFall;
	private int lossByDec;
	private int lossByMD;
	private int lossByTech;
	
	private int weight;
	
	private Hashtable<Integer,Integer> matchWeight=new Hashtable<Integer,Integer>();

		
	private WeighInHistory wiHistory;
	
	/* These 2 attributes are used to force where we put the wrestler in the reporting
	 * order.
	 */
	private String forceWeight=null;  /* for reporting force the use of this weight class. */
	private Integer forceRank=null;  /* for reporting this is the rank order withing the weight class. */

	public void setLossByInjuryString(String s) {
		lossByInjuryString = s;
	}
	public String getLossByInjuryString() { return lossByInjuryString; }
	
	public String getLowestWeightWrestled() {
		int lowInt=99999;
		
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
			int i =  Integer.parseInt(key);
		    if (i < lowInt ) {
		    	lowInt = i;
		    }
		}
		return Integer.toString(lowInt);
	}
	public String getPrintWeight() {
		if ( forceWeight != null ) {
			if ( forceWeight.length() > 0 ) {
				return forceWeight;
			}
		}
		return getLowestWeightWrestled();
	}
	public int getPrintRank() {
		if (forceRank == null ) {
			return getWins() + getLosses();
		} else {
			return 100000 - forceRank.intValue();
		}
	}
	public String getForceWeight() { return forceWeight; }
	public Integer getForceRank() { return forceRank; }
	
	public void setWeight( int w ) { 
		if (matchWeight.containsKey(w)) {
			int val =matchWeight.get(w);
			matchWeight.put(w, val+1);
			
		}
		else {
		matchWeight.put(w, 1);	
		}
		
	}
	public String getWeight() {
		Enumeration<Integer> e = matchWeight.keys();
		String WeightString="";
		while (e.hasMoreElements()) {
			 
	            // Getting the key of a particular entry
	            int keyWeight = e.nextElement();
	            int valueCount = matchWeight.get(keyWeight);
	            
	            WeightString += Integer.toString(valueCount) + "@" + Integer.toString(keyWeight) + " - ";
	             
	          
	        }
		return WeightString;
		
	}


	
	public void setForceWeight( String w ) { forceWeight = w; }
	public void setForceRank ( Integer i ) { forceRank = i; }
	
	List<Bout> bouts = new ArrayList<Bout> ();

	public List<Bout> getBouts() { return bouts; }
	
	public boolean getLossByInjury() { return lossByInjury; }
	
	public WeighInHistory getWeighInHistory() { return wiHistory; }
	
	public void setWeighInHistory(WeighInHistory wih ) { wiHistory = wih; }

	public void setPrestigeLastYear(WrestlingLanguage.Prestige p) { prestigeLastYear = p; }
	public void setPrestige2YearsAgo(WrestlingLanguage.Prestige p) { prestige2YearsAgo= p; }
	public void setPrestige3YearsAgo(WrestlingLanguage.Prestige p) { prestige3YearsAgo = p; }

	public WrestlingLanguage.Prestige getPrestigeLastYear() { return prestigeLastYear; }
	public WrestlingLanguage.Prestige getPrestige2YearsAgo() { return prestige2YearsAgo; }
	public WrestlingLanguage.Prestige getPrestige3YearsAgo() { return prestige3YearsAgo; }

    public void printVerbose () {
		System.out.println( getName() + 
			" Grade<" + getGrade() + ">" + 
			" Seed<" + getSeed() + ">" +
			" Cert<" + getCert() + ">"); 
			//" Gender<" + getGender() + "> Wt<" + 
			//getTrackWtClass() + ">" + " (" + getWins() + "W-" + 
			//getLosses() + "L) Last Year=<" + rosteredLastYear + "> Last Year Record <" + trackLastYearRecord + ">" );
    }	   
	public String getRecordString() { 
		return String.valueOf(wins) + "-" + String.valueOf(losses); 
	}
	public String getRecordBreakdown() {
		String breakdownString = "";
		boolean addedWins=false;
		if ( getWins() > 0 ) {
			breakdownString += getWins() + "W[";
			if ( getWinByFall() > 0 ) {
				breakdownString += getWinByFall() + " Pin,";
				addedWins=true;
			}
			if ( getWinByTech() > 0 ) {
				breakdownString += getWinByTech() + " TF,";
				addedWins=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getWinByMD() + " MD,";
				addedWins=true;
			}
			if ( getWinByDec() > 0 ) {
				breakdownString += getWinByDec() + " Dec,";
				addedWins=true;
			}
			if ( getWinByFFT() > 0 ) {
				breakdownString += getWinByFFT() + " FFT,";
				addedWins=true;
			}
			if ( addedWins ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "0 W";
		}
		boolean addedLosses=false;
		if ( getLosses() > 0 ) {
			breakdownString += "-" + getLosses() + "L[";
			if ( getLossByFall() > 0 ) {
				breakdownString += getLossByFall() + " Pin,";
				addedLosses=true;
			}
			if ( getLossByTech() > 0 ) {
				breakdownString += getLossByTech() + " TF,";
				addedLosses=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getLossByMD() + " MD,";
				addedLosses=true;
			}
			if ( getLossByDec() > 0 ) {
				breakdownString += getLossByDec() + " Dec,";
				addedLosses=true;
			}
			
			if ( addedLosses ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "-0L";
		}
		if ( getWins() ==0 && getLosses() == 0 ) {
			return "";
		} else {
			return breakdownString +" - "+ getWeight();
		}
	}
	public String getName() { return name; }
	public String getSeed() { return seed; }
	public String getCert() { return cert; }
	public String getTeamName() { return teamName; }
	public WrestlingLanguage.Grade getGrade() { return grade; }
	public WrestlingLanguage.Gender getGender() { return gender; }
	public String getTrackRecord() { return trackRecord; }
	public String getTrackWtClass() { return trackWtClass; }
	
	public int getWins() { return wins; }
	public int getLosses() { return losses; }
	
	public int getWinByFFT() { return winByFFT; }
	public int getWinByFall() { return winByFall; }
	public int getWinByTech() { return winByTech; }
	public int getWinByMD() { return winByMD; }
	public int getWinByDec() { return winByDec; }
	
	public int getLossByFFT() { return lossByFFT; }
	public int getLossByFall() { return lossByFall; }
	public int getLossByTech() { return lossByTech; }
	public int getLossByMD() { return lossByMD; }
	public int getLossByDec() { return lossByDec; }
	
    public Wrestler(String n, String team){
		setName(n);
		setTeamName(team);
		return;
	}
	public boolean getRosteredLastYear() { return rosteredLastYear; }
	
	public void setRosteredLastYearOn() { rosteredLastYear = true; }
	public void setRosteredLastYearOff() { rosteredLastYear = false; }
	
	public String getTrackLastYearWtClass() { return trackLastYearWtClass; }
	public String getTrackLastYearRecord() { return trackLastYearRecord; }
	
	public void setTrackLastYearWtClass(String w) { 
		trackLastYearWtClass = w; 
	}
	public void setTrackLastYearRecord(String r) {
		trackLastYearRecord = r;
	}
	
	
	public void addBout(Bout b) {
		String cmd=b.getMatchDate();
		if (cmd == null ) {
			Event e = b.getEvent();
			if ( e != null ) {
				String sss = e.getEventTitle();
				if ( wiHistory != null ) {
					String s = wiHistory.findWeighInDate(sss);
					if ( s != null ) { 
						b.setMatchDate(s);
					}
				}
			}
		}	
		
		bouts.add(b);
		addToSummary(b);
		addToMatchesAtWeight(b);
	}
	private void addToMatchesAtWeight(Bout b) {
		String w=b.getWeight();
		Integer ct = matchesAtWeight.get(w);
		if ( ct != null ) {
			ct++;
			matchesAtWeight.replace(w,ct);
		} else {
			matchesAtWeight.put(w,1);
		}
		return;
	}
	public String getMatchesAtWeightString() {

		String byWt="";
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
	
			int ct = matchesAtWeight.get(key);
			if ( byWt.length() > 0 ) { byWt=byWt + ";" ; }
			byWt=byWt + ct + "@" + key;
		}
		return byWt;
	}
	
	public void setName( String n ) {
		name = n.strip();
	}
	public void setSeed( String n ) {
		seed = n.strip();
	}
	public void setCert( String n ) {
		cert = n.strip();
	}
	public void setTeamName( String team ) {
		teamName = team;
	}
	public void setGrade5() { grade = WrestlingLanguage.Grade.G5;	}
	public void setGrade6() { grade = WrestlingLanguage.Grade.G6;	}
	public void setGrade7() { grade = WrestlingLanguage.Grade.G7;	}
	public void setGrade8() { grade = WrestlingLanguage.Grade.G8;	}
	public void setGrade(WrestlingLanguage.Grade g ) { grade=g; }
	
	public void setGenderM() { gender = WrestlingLanguage.Gender.M;	}
	public void setGenderF() { gender = WrestlingLanguage.Gender.F;	}
	public void setGender(WrestlingLanguage.Gender g ) { gender = g; }
	
	public void setTrackRecord(String rec) {
		trackRecord = rec;
	}
	public void setTrackWtClass(String w ) {
		trackWtClass = w;
	}
	public String toString() {
		return "Wrestler:" + teamName + ":" + name  ;
	}
	private void addToSummary(Bout b) {
	   if ( b.isAWin() ) {
          addWin();	
          switch ( b.getMatchResultType() ) {
			  case FFT: 
			    addWinByFFT();
				break;
			  case FALL:
			    addWinByFall();
				break;
			  case TECH:
			    addWinByTech();
				break;
			  case MD:
			    addWinByMD();
			    break;
			  case DEC:
			    addWinByDec();
				break;
			  case INJ:
			    break;
			  case DQ:
			    break;
		  }
       } else {
          addLoss();
          switch ( b.getMatchResultType() ) {

          case FFT:
			  addLossByFFT();
			    break;
			  case FALL:
			    addLossByFall();
				break;
			  case TECH:
			    addLossByTech();
				break;
			  case MD:
			    addLossByMD();
			    break;
			  case DEC:
			    addLossByDec();
				break;
			  case INJ:
			    if ( lossByInjury) {
			    	lossByInjuryString += ";";
			    } else {
			    	lossByInjury=true;
			    	lossByInjuryString= "Loss by Injury on ";
			    }
			    if ( b.getMatchDate() != null ) {
			    	lossByInjuryString += b.getMatchDate();
			    	lossByInjuryString += " ";
			    }
			    lossByInjuryString += " vs ";
			    lossByInjuryString += b.getOpponentTeam();
			    
			    break;
			  case DQ:
			    break;
		  }		  
       }		  
	}
	public void addWin() { wins++; }
	public void addLoss() { losses++; }
	public void addWinByFFT() { winByFFT++; }
	public void addWinByFall() { winByFall++; }
	public void addWinByTech() { winByTech++; }
	public void addWinByMD() { winByMD++; }
	public void addWinByDec() { winByDec++; }
	
	public void addLossByFFT() { lossByFFT++; }
	public void addLossByFall() { lossByFall++; }
	public void addLossByTech() { lossByTech++; }
	public void addLossByMD() { lossByMD++; }
	public void addLossByDec() { lossByDec++; }

	public boolean equals(Object o) {
	  if ( o == null ) { return false; }
	  if ( this == o ) { return true; }
	  if ( this.getClass() == o.getClass() ){
         Wrestler ow = (Wrestler) o;		  
	     if ( this.getName().equals(ow.getName()) && this.getTeamName().equals(ow.getTeamName())) {
			 return true;
	     }
	  }
	  return false; 
	}
	public int hashCode() {
		return getName().hashCode() + getTeamName().hashCode();
	}


public String getFinWeight() {
	String finWeight = "";
	boolean a = playedMatch();
	
	if(cert != null) {
		finWeight = cert;
	}
	else (this.cert == null&&thisplayedMatch()== true){
		finWeight = getLowestWeightWrestled();
	}
	
	return finWeight;
}

public boolean playedMatch() {
	if (matchWeight == null) {
		return false;
}	
	return true;
}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-10-13 22:32:38.372
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-10-13 22:32:38.373
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-13 22:32:38.391
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package JuniorHigh;

import java.util.*;
import java.util.Enumeration;

/*
 *
 *  This is a class to holds an wrestler and all data pertaining to him/her.
 */
class Wrestler {
	private String name;
	private String seed;
	private String cert;
	private String teamName;
	private WrestlingLanguage.Grade grade;
	private WrestlingLanguage.Gender gender;
	private String trackRecord;
	private String trackWtClass;
	private boolean rosteredLastYear;
	private String trackLastYearWtClass;
	private String trackLastYearRecord;
	private WrestlingLanguage.Prestige prestigeLastYear;
	private WrestlingLanguage.Prestige prestige2YearsAgo;
	private WrestlingLanguage.Prestige prestige3YearsAgo;
	
	private Hashtable<String,Integer> matchesAtWeight=new Hashtable<String,Integer>();
	
	private int wins;
	private int losses;
	private boolean lossByInjury=false;
	private String lossByInjuryString;
	private int winByFFT;
	private int lossByFFT;

	private int winByFall;
	private int winByDec;
	private int winByMD;
	private int winByTech;
	
	private int lossByFall;
	private int lossByDec;
	private int lossByMD;
	private int lossByTech;
	
	private int weight;
	
	private Hashtable<Integer,Integer> matchWeight=new Hashtable<Integer,Integer>();

		
	private WeighInHistory wiHistory;
	
	/* These 2 attributes are used to force where we put the wrestler in the reporting
	 * order.
	 */
	private String forceWeight=null;  /* for reporting force the use of this weight class. */
	private Integer forceRank=null;  /* for reporting this is the rank order withing the weight class. */

	public void setLossByInjuryString(String s) {
		lossByInjuryString = s;
	}
	public String getLossByInjuryString() { return lossByInjuryString; }
	
	public String getLowestWeightWrestled() {
		int lowInt=99999;
		
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
			int i =  Integer.parseInt(key);
		    if (i < lowInt ) {
		    	lowInt = i;
		    }
		}
		return Integer.toString(lowInt);
	}
	public String getPrintWeight() {
		if ( forceWeight != null ) {
			if ( forceWeight.length() > 0 ) {
				return forceWeight;
			}
		}
		return getLowestWeightWrestled();
	}
	public int getPrintRank() {
		if (forceRank == null ) {
			return getWins() + getLosses();
		} else {
			return 100000 - forceRank.intValue();
		}
	}
	public String getForceWeight() { return forceWeight; }
	public Integer getForceRank() { return forceRank; }
	
	public void setWeight( int w ) { 
		if (matchWeight.containsKey(w)) {
			int val =matchWeight.get(w);
			matchWeight.put(w, val+1);
			
		}
		else {
		matchWeight.put(w, 1);	
		}
		
	}
	public String getWeight() {
		Enumeration<Integer> e = matchWeight.keys();
		String WeightString="";
		while (e.hasMoreElements()) {
			 
	            // Getting the key of a particular entry
	            int keyWeight = e.nextElement();
	            int valueCount = matchWeight.get(keyWeight);
	            
	            WeightString += Integer.toString(valueCount) + "@" + Integer.toString(keyWeight) + " - ";
	             
	          
	        }
		return WeightString;
		
	}


	
	public void setForceWeight( String w ) { forceWeight = w; }
	public void setForceRank ( Integer i ) { forceRank = i; }
	
	List<Bout> bouts = new ArrayList<Bout> ();

	public List<Bout> getBouts() { return bouts; }
	
	public boolean getLossByInjury() { return lossByInjury; }
	
	public WeighInHistory getWeighInHistory() { return wiHistory; }
	
	public void setWeighInHistory(WeighInHistory wih ) { wiHistory = wih; }

	public void setPrestigeLastYear(WrestlingLanguage.Prestige p) { prestigeLastYear = p; }
	public void setPrestige2YearsAgo(WrestlingLanguage.Prestige p) { prestige2YearsAgo= p; }
	public void setPrestige3YearsAgo(WrestlingLanguage.Prestige p) { prestige3YearsAgo = p; }

	public WrestlingLanguage.Prestige getPrestigeLastYear() { return prestigeLastYear; }
	public WrestlingLanguage.Prestige getPrestige2YearsAgo() { return prestige2YearsAgo; }
	public WrestlingLanguage.Prestige getPrestige3YearsAgo() { return prestige3YearsAgo; }

    public void printVerbose () {
		System.out.println( getName() + 
			" Grade<" + getGrade() + ">" + 
			" Seed<" + getSeed() + ">" +
			" Cert<" + getCert() + ">"); 
			//" Gender<" + getGender() + "> Wt<" + 
			//getTrackWtClass() + ">" + " (" + getWins() + "W-" + 
			//getLosses() + "L) Last Year=<" + rosteredLastYear + "> Last Year Record <" + trackLastYearRecord + ">" );
    }	   
	public String getRecordString() { 
		return String.valueOf(wins) + "-" + String.valueOf(losses); 
	}
	public String getRecordBreakdown() {
		String breakdownString = "";
		boolean addedWins=false;
		if ( getWins() > 0 ) {
			breakdownString += getWins() + "W[";
			if ( getWinByFall() > 0 ) {
				breakdownString += getWinByFall() + " Pin,";
				addedWins=true;
			}
			if ( getWinByTech() > 0 ) {
				breakdownString += getWinByTech() + " TF,";
				addedWins=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getWinByMD() + " MD,";
				addedWins=true;
			}
			if ( getWinByDec() > 0 ) {
				breakdownString += getWinByDec() + " Dec,";
				addedWins=true;
			}
			if ( getWinByFFT() > 0 ) {
				breakdownString += getWinByFFT() + " FFT,";
				addedWins=true;
			}
			if ( addedWins ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "0 W";
		}
		boolean addedLosses=false;
		if ( getLosses() > 0 ) {
			breakdownString += "-" + getLosses() + "L[";
			if ( getLossByFall() > 0 ) {
				breakdownString += getLossByFall() + " Pin,";
				addedLosses=true;
			}
			if ( getLossByTech() > 0 ) {
				breakdownString += getLossByTech() + " TF,";
				addedLosses=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getLossByMD() + " MD,";
				addedLosses=true;
			}
			if ( getLossByDec() > 0 ) {
				breakdownString += getLossByDec() + " Dec,";
				addedLosses=true;
			}
			
			if ( addedLosses ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "-0L";
		}
		if ( getWins() ==0 && getLosses() == 0 ) {
			return "";
		} else {
			return breakdownString +" - "+ getWeight();
		}
	}
	public String getName() { return name; }
	public String getSeed() { return seed; }
	public String getCert() { return cert; }
	public String getTeamName() { return teamName; }
	public WrestlingLanguage.Grade getGrade() { return grade; }
	public WrestlingLanguage.Gender getGender() { return gender; }
	public String getTrackRecord() { return trackRecord; }
	public String getTrackWtClass() { return trackWtClass; }
	
	public int getWins() { return wins; }
	public int getLosses() { return losses; }
	
	public int getWinByFFT() { return winByFFT; }
	public int getWinByFall() { return winByFall; }
	public int getWinByTech() { return winByTech; }
	public int getWinByMD() { return winByMD; }
	public int getWinByDec() { return winByDec; }
	
	public int getLossByFFT() { return lossByFFT; }
	public int getLossByFall() { return lossByFall; }
	public int getLossByTech() { return lossByTech; }
	public int getLossByMD() { return lossByMD; }
	public int getLossByDec() { return lossByDec; }
	
    public Wrestler(String n, String team){
		setName(n);
		setTeamName(team);
		return;
	}
	public boolean getRosteredLastYear() { return rosteredLastYear; }
	
	public void setRosteredLastYearOn() { rosteredLastYear = true; }
	public void setRosteredLastYearOff() { rosteredLastYear = false; }
	
	public String getTrackLastYearWtClass() { return trackLastYearWtClass; }
	public String getTrackLastYearRecord() { return trackLastYearRecord; }
	
	public void setTrackLastYearWtClass(String w) { 
		trackLastYearWtClass = w; 
	}
	public void setTrackLastYearRecord(String r) {
		trackLastYearRecord = r;
	}
	
	
	public void addBout(Bout b) {
		String cmd=b.getMatchDate();
		if (cmd == null ) {
			Event e = b.getEvent();
			if ( e != null ) {
				String sss = e.getEventTitle();
				if ( wiHistory != null ) {
					String s = wiHistory.findWeighInDate(sss);
					if ( s != null ) { 
						b.setMatchDate(s);
					}
				}
			}
		}	
		
		bouts.add(b);
		addToSummary(b);
		addToMatchesAtWeight(b);
	}
	private void addToMatchesAtWeight(Bout b) {
		String w=b.getWeight();
		Integer ct = matchesAtWeight.get(w);
		if ( ct != null ) {
			ct++;
			matchesAtWeight.replace(w,ct);
		} else {
			matchesAtWeight.put(w,1);
		}
		return;
	}
	public String getMatchesAtWeightString() {

		String byWt="";
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
	
			int ct = matchesAtWeight.get(key);
			if ( byWt.length() > 0 ) { byWt=byWt + ";" ; }
			byWt=byWt + ct + "@" + key;
		}
		return byWt;
	}
	
	public void setName( String n ) {
		name = n.strip();
	}
	public void setSeed( String n ) {
		seed = n.strip();
	}
	public void setCert( String n ) {
		cert = n.strip();
	}
	public void setTeamName( String team ) {
		teamName = team;
	}
	public void setGrade5() { grade = WrestlingLanguage.Grade.G5;	}
	public void setGrade6() { grade = WrestlingLanguage.Grade.G6;	}
	public void setGrade7() { grade = WrestlingLanguage.Grade.G7;	}
	public void setGrade8() { grade = WrestlingLanguage.Grade.G8;	}
	public void setGrade(WrestlingLanguage.Grade g ) { grade=g; }
	
	public void setGenderM() { gender = WrestlingLanguage.Gender.M;	}
	public void setGenderF() { gender = WrestlingLanguage.Gender.F;	}
	public void setGender(WrestlingLanguage.Gender g ) { gender = g; }
	
	public void setTrackRecord(String rec) {
		trackRecord = rec;
	}
	public void setTrackWtClass(String w ) {
		trackWtClass = w;
	}
	public String toString() {
		return "Wrestler:" + teamName + ":" + name  ;
	}
	private void addToSummary(Bout b) {
	   if ( b.isAWin() ) {
          addWin();	
          switch ( b.getMatchResultType() ) {
			  case FFT: 
			    addWinByFFT();
				break;
			  case FALL:
			    addWinByFall();
				break;
			  case TECH:
			    addWinByTech();
				break;
			  case MD:
			    addWinByMD();
			    break;
			  case DEC:
			    addWinByDec();
				break;
			  case INJ:
			    break;
			  case DQ:
			    break;
		  }
       } else {
          addLoss();
          switch ( b.getMatchResultType() ) {

          case FFT:
			  addLossByFFT();
			    break;
			  case FALL:
			    addLossByFall();
				break;
			  case TECH:
			    addLossByTech();
				break;
			  case MD:
			    addLossByMD();
			    break;
			  case DEC:
			    addLossByDec();
				break;
			  case INJ:
			    if ( lossByInjury) {
			    	lossByInjuryString += ";";
			    } else {
			    	lossByInjury=true;
			    	lossByInjuryString= "Loss by Injury on ";
			    }
			    if ( b.getMatchDate() != null ) {
			    	lossByInjuryString += b.getMatchDate();
			    	lossByInjuryString += " ";
			    }
			    lossByInjuryString += " vs ";
			    lossByInjuryString += b.getOpponentTeam();
			    
			    break;
			  case DQ:
			    break;
		  }		  
       }		  
	}
	public void addWin() { wins++; }
	public void addLoss() { losses++; }
	public void addWinByFFT() { winByFFT++; }
	public void addWinByFall() { winByFall++; }
	public void addWinByTech() { winByTech++; }
	public void addWinByMD() { winByMD++; }
	public void addWinByDec() { winByDec++; }
	
	public void addLossByFFT() { lossByFFT++; }
	public void addLossByFall() { lossByFall++; }
	public void addLossByTech() { lossByTech++; }
	public void addLossByMD() { lossByMD++; }
	public void addLossByDec() { lossByDec++; }

	public boolean equals(Object o) {
	  if ( o == null ) { return false; }
	  if ( this == o ) { return true; }
	  if ( this.getClass() == o.getClass() ){
         Wrestler ow = (Wrestler) o;		  
	     if ( this.getName().equals(ow.getName()) && this.getTeamName().equals(ow.getTeamName())) {
			 return true;
	     }
	  }
	  return false; 
	}
	public int hashCode() {
		return getName().hashCode() + getTeamName().hashCode();
	}


public String getFinWeight() {
	String finWeight = "";
	boolean a = playedMatch();
	
	if(cert != null) {
		finWeight = cert;
	}
	else (this.cert == null&&thisplayedMatch()== true){
		finWeight = getLowestWeightWrestled();
	}
	
	return finWeight;
}

public boolean playedMatch() {
	if (matchWeight == null) {
		return false;
}	
	return true;
}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-13 22:32:38.391
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-13 22:32:38.391
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-13 22:32:39.284
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package JuniorHigh;

import java.util.*;
import java.util.Enumeration;

/*
 *
 *  This is a class to holds an wrestler and all data pertaining to him/her.
 */
class Wrestler {
	private String name;
	private String seed;
	private String cert;
	private String teamName;
	private WrestlingLanguage.Grade grade;
	private WrestlingLanguage.Gender gender;
	private String trackRecord;
	private String trackWtClass;
	private boolean rosteredLastYear;
	private String trackLastYearWtClass;
	private String trackLastYearRecord;
	private WrestlingLanguage.Prestige prestigeLastYear;
	private WrestlingLanguage.Prestige prestige2YearsAgo;
	private WrestlingLanguage.Prestige prestige3YearsAgo;
	
	private Hashtable<String,Integer> matchesAtWeight=new Hashtable<String,Integer>();
	
	private int wins;
	private int losses;
	private boolean lossByInjury=false;
	private String lossByInjuryString;
	private int winByFFT;
	private int lossByFFT;

	private int winByFall;
	private int winByDec;
	private int winByMD;
	private int winByTech;
	
	private int lossByFall;
	private int lossByDec;
	private int lossByMD;
	private int lossByTech;
	
	private int weight;
	
	private Hashtable<Integer,Integer> matchWeight=new Hashtable<Integer,Integer>();

		
	private WeighInHistory wiHistory;
	
	/* These 2 attributes are used to force where we put the wrestler in the reporting
	 * order.
	 */
	private String forceWeight=null;  /* for reporting force the use of this weight class. */
	private Integer forceRank=null;  /* for reporting this is the rank order withing the weight class. */

	public void setLossByInjuryString(String s) {
		lossByInjuryString = s;
	}
	public String getLossByInjuryString() { return lossByInjuryString; }
	
	public String getLowestWeightWrestled() {
		int lowInt=99999;
		
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
			int i =  Integer.parseInt(key);
		    if (i < lowInt ) {
		    	lowInt = i;
		    }
		}
		return Integer.toString(lowInt);
	}
	public String getPrintWeight() {
		if ( forceWeight != null ) {
			if ( forceWeight.length() > 0 ) {
				return forceWeight;
			}
		}
		return getLowestWeightWrestled();
	}
	public int getPrintRank() {
		if (forceRank == null ) {
			return getWins() + getLosses();
		} else {
			return 100000 - forceRank.intValue();
		}
	}
	public String getForceWeight() { return forceWeight; }
	public Integer getForceRank() { return forceRank; }
	
	public void setWeight( int w ) { 
		if (matchWeight.containsKey(w)) {
			int val =matchWeight.get(w);
			matchWeight.put(w, val+1);
			
		}
		else {
		matchWeight.put(w, 1);	
		}
		
	}
	public String getWeight() {
		Enumeration<Integer> e = matchWeight.keys();
		String WeightString="";
		while (e.hasMoreElements()) {
			 
	            // Getting the key of a particular entry
	            int keyWeight = e.nextElement();
	            int valueCount = matchWeight.get(keyWeight);
	            
	            WeightString += Integer.toString(valueCount) + "@" + Integer.toString(keyWeight) + " - ";
	             
	          
	        }
		return WeightString;
		
	}


	
	public void setForceWeight( String w ) { forceWeight = w; }
	public void setForceRank ( Integer i ) { forceRank = i; }
	
	List<Bout> bouts = new ArrayList<Bout> ();

	public List<Bout> getBouts() { return bouts; }
	
	public boolean getLossByInjury() { return lossByInjury; }
	
	public WeighInHistory getWeighInHistory() { return wiHistory; }
	
	public void setWeighInHistory(WeighInHistory wih ) { wiHistory = wih; }

	public void setPrestigeLastYear(WrestlingLanguage.Prestige p) { prestigeLastYear = p; }
	public void setPrestige2YearsAgo(WrestlingLanguage.Prestige p) { prestige2YearsAgo= p; }
	public void setPrestige3YearsAgo(WrestlingLanguage.Prestige p) { prestige3YearsAgo = p; }

	public WrestlingLanguage.Prestige getPrestigeLastYear() { return prestigeLastYear; }
	public WrestlingLanguage.Prestige getPrestige2YearsAgo() { return prestige2YearsAgo; }
	public WrestlingLanguage.Prestige getPrestige3YearsAgo() { return prestige3YearsAgo; }

    public void printVerbose () {
		System.out.println( getName() + 
			" Grade<" + getGrade() + ">" + 
			" Seed<" + getSeed() + ">" +
			" Cert<" + getCert() + ">"); 
			//" Gender<" + getGender() + "> Wt<" + 
			//getTrackWtClass() + ">" + " (" + getWins() + "W-" + 
			//getLosses() + "L) Last Year=<" + rosteredLastYear + "> Last Year Record <" + trackLastYearRecord + ">" );
    }	   
	public String getRecordString() { 
		return String.valueOf(wins) + "-" + String.valueOf(losses); 
	}
	public String getRecordBreakdown() {
		String breakdownString = "";
		boolean addedWins=false;
		if ( getWins() > 0 ) {
			breakdownString += getWins() + "W[";
			if ( getWinByFall() > 0 ) {
				breakdownString += getWinByFall() + " Pin,";
				addedWins=true;
			}
			if ( getWinByTech() > 0 ) {
				breakdownString += getWinByTech() + " TF,";
				addedWins=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getWinByMD() + " MD,";
				addedWins=true;
			}
			if ( getWinByDec() > 0 ) {
				breakdownString += getWinByDec() + " Dec,";
				addedWins=true;
			}
			if ( getWinByFFT() > 0 ) {
				breakdownString += getWinByFFT() + " FFT,";
				addedWins=true;
			}
			if ( addedWins ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "0 W";
		}
		boolean addedLosses=false;
		if ( getLosses() > 0 ) {
			breakdownString += "-" + getLosses() + "L[";
			if ( getLossByFall() > 0 ) {
				breakdownString += getLossByFall() + " Pin,";
				addedLosses=true;
			}
			if ( getLossByTech() > 0 ) {
				breakdownString += getLossByTech() + " TF,";
				addedLosses=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getLossByMD() + " MD,";
				addedLosses=true;
			}
			if ( getLossByDec() > 0 ) {
				breakdownString += getLossByDec() + " Dec,";
				addedLosses=true;
			}
			
			if ( addedLosses ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "-0L";
		}
		if ( getWins() ==0 && getLosses() == 0 ) {
			return "";
		} else {
			return breakdownString +" - "+ getWeight();
		}
	}
	public String getName() { return name; }
	public String getSeed() { return seed; }
	public String getCert() { return cert; }
	public String getTeamName() { return teamName; }
	public WrestlingLanguage.Grade getGrade() { return grade; }
	public WrestlingLanguage.Gender getGender() { return gender; }
	public String getTrackRecord() { return trackRecord; }
	public String getTrackWtClass() { return trackWtClass; }
	
	public int getWins() { return wins; }
	public int getLosses() { return losses; }
	
	public int getWinByFFT() { return winByFFT; }
	public int getWinByFall() { return winByFall; }
	public int getWinByTech() { return winByTech; }
	public int getWinByMD() { return winByMD; }
	public int getWinByDec() { return winByDec; }
	
	public int getLossByFFT() { return lossByFFT; }
	public int getLossByFall() { return lossByFall; }
	public int getLossByTech() { return lossByTech; }
	public int getLossByMD() { return lossByMD; }
	public int getLossByDec() { return lossByDec; }
	
    public Wrestler(String n, String team){
		setName(n);
		setTeamName(team);
		return;
	}
	public boolean getRosteredLastYear() { return rosteredLastYear; }
	
	public void setRosteredLastYearOn() { rosteredLastYear = true; }
	public void setRosteredLastYearOff() { rosteredLastYear = false; }
	
	public String getTrackLastYearWtClass() { return trackLastYearWtClass; }
	public String getTrackLastYearRecord() { return trackLastYearRecord; }
	
	public void setTrackLastYearWtClass(String w) { 
		trackLastYearWtClass = w; 
	}
	public void setTrackLastYearRecord(String r) {
		trackLastYearRecord = r;
	}
	
	
	public void addBout(Bout b) {
		String cmd=b.getMatchDate();
		if (cmd == null ) {
			Event e = b.getEvent();
			if ( e != null ) {
				String sss = e.getEventTitle();
				if ( wiHistory != null ) {
					String s = wiHistory.findWeighInDate(sss);
					if ( s != null ) { 
						b.setMatchDate(s);
					}
				}
			}
		}	
		
		bouts.add(b);
		addToSummary(b);
		addToMatchesAtWeight(b);
	}
	private void addToMatchesAtWeight(Bout b) {
		String w=b.getWeight();
		Integer ct = matchesAtWeight.get(w);
		if ( ct != null ) {
			ct++;
			matchesAtWeight.replace(w,ct);
		} else {
			matchesAtWeight.put(w,1);
		}
		return;
	}
	public String getMatchesAtWeightString() {

		String byWt="";
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
	
			int ct = matchesAtWeight.get(key);
			if ( byWt.length() > 0 ) { byWt=byWt + ";" ; }
			byWt=byWt + ct + "@" + key;
		}
		return byWt;
	}
	
	public void setName( String n ) {
		name = n.strip();
	}
	public void setSeed( String n ) {
		seed = n.strip();
	}
	public void setCert( String n ) {
		cert = n.strip();
	}
	public void setTeamName( String team ) {
		teamName = team;
	}
	public void setGrade5() { grade = WrestlingLanguage.Grade.G5;	}
	public void setGrade6() { grade = WrestlingLanguage.Grade.G6;	}
	public void setGrade7() { grade = WrestlingLanguage.Grade.G7;	}
	public void setGrade8() { grade = WrestlingLanguage.Grade.G8;	}
	public void setGrade(WrestlingLanguage.Grade g ) { grade=g; }
	
	public void setGenderM() { gender = WrestlingLanguage.Gender.M;	}
	public void setGenderF() { gender = WrestlingLanguage.Gender.F;	}
	public void setGender(WrestlingLanguage.Gender g ) { gender = g; }
	
	public void setTrackRecord(String rec) {
		trackRecord = rec;
	}
	public void setTrackWtClass(String w ) {
		trackWtClass = w;
	}
	public String toString() {
		return "Wrestler:" + teamName + ":" + name  ;
	}
	private void addToSummary(Bout b) {
	   if ( b.isAWin() ) {
          addWin();	
          switch ( b.getMatchResultType() ) {
			  case FFT: 
			    addWinByFFT();
				break;
			  case FALL:
			    addWinByFall();
				break;
			  case TECH:
			    addWinByTech();
				break;
			  case MD:
			    addWinByMD();
			    break;
			  case DEC:
			    addWinByDec();
				break;
			  case INJ:
			    break;
			  case DQ:
			    break;
		  }
       } else {
          addLoss();
          switch ( b.getMatchResultType() ) {

          case FFT:
			  addLossByFFT();
			    break;
			  case FALL:
			    addLossByFall();
				break;
			  case TECH:
			    addLossByTech();
				break;
			  case MD:
			    addLossByMD();
			    break;
			  case DEC:
			    addLossByDec();
				break;
			  case INJ:
			    if ( lossByInjury) {
			    	lossByInjuryString += ";";
			    } else {
			    	lossByInjury=true;
			    	lossByInjuryString= "Loss by Injury on ";
			    }
			    if ( b.getMatchDate() != null ) {
			    	lossByInjuryString += b.getMatchDate();
			    	lossByInjuryString += " ";
			    }
			    lossByInjuryString += " vs ";
			    lossByInjuryString += b.getOpponentTeam();
			    
			    break;
			  case DQ:
			    break;
		  }		  
       }		  
	}
	public void addWin() { wins++; }
	public void addLoss() { losses++; }
	public void addWinByFFT() { winByFFT++; }
	public void addWinByFall() { winByFall++; }
	public void addWinByTech() { winByTech++; }
	public void addWinByMD() { winByMD++; }
	public void addWinByDec() { winByDec++; }
	
	public void addLossByFFT() { lossByFFT++; }
	public void addLossByFall() { lossByFall++; }
	public void addLossByTech() { lossByTech++; }
	public void addLossByMD() { lossByMD++; }
	public void addLossByDec() { lossByDec++; }

	public boolean equals(Object o) {
	  if ( o == null ) { return false; }
	  if ( this == o ) { return true; }
	  if ( this.getClass() == o.getClass() ){
         Wrestler ow = (Wrestler) o;		  
	     if ( this.getName().equals(ow.getName()) && this.getTeamName().equals(ow.getTeamName())) {
			 return true;
	     }
	  }
	  return false; 
	}
	public int hashCode() {
		return getName().hashCode() + getTeamName().hashCode();
	}


public String getFinWeight() {
	String finWeight = "";
	boolean a = playedMatch();
	
	if(cert != null) {
		finWeight = cert;
	}
	else (this.cert == null&&this.playedMatch()== true){
		finWeight = getLowestWeightWrestled();
	}
	
	return finWeight;
}

public boolean playedMatch() {
	if (matchWeight == null) {
		return false;
}	
	return true;
}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-10-13 22:32:39.285
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-10-13 22:32:39.286
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-13 22:32:39.340
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package JuniorHigh;

import java.util.*;
import java.util.Enumeration;

/*
 *
 *  This is a class to holds an wrestler and all data pertaining to him/her.
 */
class Wrestler {
	private String name;
	private String seed;
	private String cert;
	private String teamName;
	private WrestlingLanguage.Grade grade;
	private WrestlingLanguage.Gender gender;
	private String trackRecord;
	private String trackWtClass;
	private boolean rosteredLastYear;
	private String trackLastYearWtClass;
	private String trackLastYearRecord;
	private WrestlingLanguage.Prestige prestigeLastYear;
	private WrestlingLanguage.Prestige prestige2YearsAgo;
	private WrestlingLanguage.Prestige prestige3YearsAgo;
	
	private Hashtable<String,Integer> matchesAtWeight=new Hashtable<String,Integer>();
	
	private int wins;
	private int losses;
	private boolean lossByInjury=false;
	private String lossByInjuryString;
	private int winByFFT;
	private int lossByFFT;

	private int winByFall;
	private int winByDec;
	private int winByMD;
	private int winByTech;
	
	private int lossByFall;
	private int lossByDec;
	private int lossByMD;
	private int lossByTech;
	
	private int weight;
	
	private Hashtable<Integer,Integer> matchWeight=new Hashtable<Integer,Integer>();

		
	private WeighInHistory wiHistory;
	
	/* These 2 attributes are used to force where we put the wrestler in the reporting
	 * order.
	 */
	private String forceWeight=null;  /* for reporting force the use of this weight class. */
	private Integer forceRank=null;  /* for reporting this is the rank order withing the weight class. */

	public void setLossByInjuryString(String s) {
		lossByInjuryString = s;
	}
	public String getLossByInjuryString() { return lossByInjuryString; }
	
	public String getLowestWeightWrestled() {
		int lowInt=99999;
		
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
			int i =  Integer.parseInt(key);
		    if (i < lowInt ) {
		    	lowInt = i;
		    }
		}
		return Integer.toString(lowInt);
	}
	public String getPrintWeight() {
		if ( forceWeight != null ) {
			if ( forceWeight.length() > 0 ) {
				return forceWeight;
			}
		}
		return getLowestWeightWrestled();
	}
	public int getPrintRank() {
		if (forceRank == null ) {
			return getWins() + getLosses();
		} else {
			return 100000 - forceRank.intValue();
		}
	}
	public String getForceWeight() { return forceWeight; }
	public Integer getForceRank() { return forceRank; }
	
	public void setWeight( int w ) { 
		if (matchWeight.containsKey(w)) {
			int val =matchWeight.get(w);
			matchWeight.put(w, val+1);
			
		}
		else {
		matchWeight.put(w, 1);	
		}
		
	}
	public String getWeight() {
		Enumeration<Integer> e = matchWeight.keys();
		String WeightString="";
		while (e.hasMoreElements()) {
			 
	            // Getting the key of a particular entry
	            int keyWeight = e.nextElement();
	            int valueCount = matchWeight.get(keyWeight);
	            
	            WeightString += Integer.toString(valueCount) + "@" + Integer.toString(keyWeight) + " - ";
	             
	          
	        }
		return WeightString;
		
	}


	
	public void setForceWeight( String w ) { forceWeight = w; }
	public void setForceRank ( Integer i ) { forceRank = i; }
	
	List<Bout> bouts = new ArrayList<Bout> ();

	public List<Bout> getBouts() { return bouts; }
	
	public boolean getLossByInjury() { return lossByInjury; }
	
	public WeighInHistory getWeighInHistory() { return wiHistory; }
	
	public void setWeighInHistory(WeighInHistory wih ) { wiHistory = wih; }

	public void setPrestigeLastYear(WrestlingLanguage.Prestige p) { prestigeLastYear = p; }
	public void setPrestige2YearsAgo(WrestlingLanguage.Prestige p) { prestige2YearsAgo= p; }
	public void setPrestige3YearsAgo(WrestlingLanguage.Prestige p) { prestige3YearsAgo = p; }

	public WrestlingLanguage.Prestige getPrestigeLastYear() { return prestigeLastYear; }
	public WrestlingLanguage.Prestige getPrestige2YearsAgo() { return prestige2YearsAgo; }
	public WrestlingLanguage.Prestige getPrestige3YearsAgo() { return prestige3YearsAgo; }

    public void printVerbose () {
		System.out.println( getName() + 
			" Grade<" + getGrade() + ">" + 
			" Seed<" + getSeed() + ">" +
			" Cert<" + getCert() + ">"); 
			//" Gender<" + getGender() + "> Wt<" + 
			//getTrackWtClass() + ">" + " (" + getWins() + "W-" + 
			//getLosses() + "L) Last Year=<" + rosteredLastYear + "> Last Year Record <" + trackLastYearRecord + ">" );
    }	   
	public String getRecordString() { 
		return String.valueOf(wins) + "-" + String.valueOf(losses); 
	}
	public String getRecordBreakdown() {
		String breakdownString = "";
		boolean addedWins=false;
		if ( getWins() > 0 ) {
			breakdownString += getWins() + "W[";
			if ( getWinByFall() > 0 ) {
				breakdownString += getWinByFall() + " Pin,";
				addedWins=true;
			}
			if ( getWinByTech() > 0 ) {
				breakdownString += getWinByTech() + " TF,";
				addedWins=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getWinByMD() + " MD,";
				addedWins=true;
			}
			if ( getWinByDec() > 0 ) {
				breakdownString += getWinByDec() + " Dec,";
				addedWins=true;
			}
			if ( getWinByFFT() > 0 ) {
				breakdownString += getWinByFFT() + " FFT,";
				addedWins=true;
			}
			if ( addedWins ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "0 W";
		}
		boolean addedLosses=false;
		if ( getLosses() > 0 ) {
			breakdownString += "-" + getLosses() + "L[";
			if ( getLossByFall() > 0 ) {
				breakdownString += getLossByFall() + " Pin,";
				addedLosses=true;
			}
			if ( getLossByTech() > 0 ) {
				breakdownString += getLossByTech() + " TF,";
				addedLosses=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getLossByMD() + " MD,";
				addedLosses=true;
			}
			if ( getLossByDec() > 0 ) {
				breakdownString += getLossByDec() + " Dec,";
				addedLosses=true;
			}
			
			if ( addedLosses ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "-0L";
		}
		if ( getWins() ==0 && getLosses() == 0 ) {
			return "";
		} else {
			return breakdownString +" - "+ getWeight();
		}
	}
	public String getName() { return name; }
	public String getSeed() { return seed; }
	public String getCert() { return cert; }
	public String getTeamName() { return teamName; }
	public WrestlingLanguage.Grade getGrade() { return grade; }
	public WrestlingLanguage.Gender getGender() { return gender; }
	public String getTrackRecord() { return trackRecord; }
	public String getTrackWtClass() { return trackWtClass; }
	
	public int getWins() { return wins; }
	public int getLosses() { return losses; }
	
	public int getWinByFFT() { return winByFFT; }
	public int getWinByFall() { return winByFall; }
	public int getWinByTech() { return winByTech; }
	public int getWinByMD() { return winByMD; }
	public int getWinByDec() { return winByDec; }
	
	public int getLossByFFT() { return lossByFFT; }
	public int getLossByFall() { return lossByFall; }
	public int getLossByTech() { return lossByTech; }
	public int getLossByMD() { return lossByMD; }
	public int getLossByDec() { return lossByDec; }
	
    public Wrestler(String n, String team){
		setName(n);
		setTeamName(team);
		return;
	}
	public boolean getRosteredLastYear() { return rosteredLastYear; }
	
	public void setRosteredLastYearOn() { rosteredLastYear = true; }
	public void setRosteredLastYearOff() { rosteredLastYear = false; }
	
	public String getTrackLastYearWtClass() { return trackLastYearWtClass; }
	public String getTrackLastYearRecord() { return trackLastYearRecord; }
	
	public void setTrackLastYearWtClass(String w) { 
		trackLastYearWtClass = w; 
	}
	public void setTrackLastYearRecord(String r) {
		trackLastYearRecord = r;
	}
	
	
	public void addBout(Bout b) {
		String cmd=b.getMatchDate();
		if (cmd == null ) {
			Event e = b.getEvent();
			if ( e != null ) {
				String sss = e.getEventTitle();
				if ( wiHistory != null ) {
					String s = wiHistory.findWeighInDate(sss);
					if ( s != null ) { 
						b.setMatchDate(s);
					}
				}
			}
		}	
		
		bouts.add(b);
		addToSummary(b);
		addToMatchesAtWeight(b);
	}
	private void addToMatchesAtWeight(Bout b) {
		String w=b.getWeight();
		Integer ct = matchesAtWeight.get(w);
		if ( ct != null ) {
			ct++;
			matchesAtWeight.replace(w,ct);
		} else {
			matchesAtWeight.put(w,1);
		}
		return;
	}
	public String getMatchesAtWeightString() {

		String byWt="";
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
	
			int ct = matchesAtWeight.get(key);
			if ( byWt.length() > 0 ) { byWt=byWt + ";" ; }
			byWt=byWt + ct + "@" + key;
		}
		return byWt;
	}
	
	public void setName( String n ) {
		name = n.strip();
	}
	public void setSeed( String n ) {
		seed = n.strip();
	}
	public void setCert( String n ) {
		cert = n.strip();
	}
	public void setTeamName( String team ) {
		teamName = team;
	}
	public void setGrade5() { grade = WrestlingLanguage.Grade.G5;	}
	public void setGrade6() { grade = WrestlingLanguage.Grade.G6;	}
	public void setGrade7() { grade = WrestlingLanguage.Grade.G7;	}
	public void setGrade8() { grade = WrestlingLanguage.Grade.G8;	}
	public void setGrade(WrestlingLanguage.Grade g ) { grade=g; }
	
	public void setGenderM() { gender = WrestlingLanguage.Gender.M;	}
	public void setGenderF() { gender = WrestlingLanguage.Gender.F;	}
	public void setGender(WrestlingLanguage.Gender g ) { gender = g; }
	
	public void setTrackRecord(String rec) {
		trackRecord = rec;
	}
	public void setTrackWtClass(String w ) {
		trackWtClass = w;
	}
	public String toString() {
		return "Wrestler:" + teamName + ":" + name  ;
	}
	private void addToSummary(Bout b) {
	   if ( b.isAWin() ) {
          addWin();	
          switch ( b.getMatchResultType() ) {
			  case FFT: 
			    addWinByFFT();
				break;
			  case FALL:
			    addWinByFall();
				break;
			  case TECH:
			    addWinByTech();
				break;
			  case MD:
			    addWinByMD();
			    break;
			  case DEC:
			    addWinByDec();
				break;
			  case INJ:
			    break;
			  case DQ:
			    break;
		  }
       } else {
          addLoss();
          switch ( b.getMatchResultType() ) {

          case FFT:
			  addLossByFFT();
			    break;
			  case FALL:
			    addLossByFall();
				break;
			  case TECH:
			    addLossByTech();
				break;
			  case MD:
			    addLossByMD();
			    break;
			  case DEC:
			    addLossByDec();
				break;
			  case INJ:
			    if ( lossByInjury) {
			    	lossByInjuryString += ";";
			    } else {
			    	lossByInjury=true;
			    	lossByInjuryString= "Loss by Injury on ";
			    }
			    if ( b.getMatchDate() != null ) {
			    	lossByInjuryString += b.getMatchDate();
			    	lossByInjuryString += " ";
			    }
			    lossByInjuryString += " vs ";
			    lossByInjuryString += b.getOpponentTeam();
			    
			    break;
			  case DQ:
			    break;
		  }		  
       }		  
	}
	public void addWin() { wins++; }
	public void addLoss() { losses++; }
	public void addWinByFFT() { winByFFT++; }
	public void addWinByFall() { winByFall++; }
	public void addWinByTech() { winByTech++; }
	public void addWinByMD() { winByMD++; }
	public void addWinByDec() { winByDec++; }
	
	public void addLossByFFT() { lossByFFT++; }
	public void addLossByFall() { lossByFall++; }
	public void addLossByTech() { lossByTech++; }
	public void addLossByMD() { lossByMD++; }
	public void addLossByDec() { lossByDec++; }

	public boolean equals(Object o) {
	  if ( o == null ) { return false; }
	  if ( this == o ) { return true; }
	  if ( this.getClass() == o.getClass() ){
         Wrestler ow = (Wrestler) o;		  
	     if ( this.getName().equals(ow.getName()) && this.getTeamName().equals(ow.getTeamName())) {
			 return true;
	     }
	  }
	  return false; 
	}
	public int hashCode() {
		return getName().hashCode() + getTeamName().hashCode();
	}


public String getFinWeight() {
	String finWeight = "";
	boolean a = playedMatch();
	
	if(cert != null) {
		finWeight = cert;
	}
	else (this.cert == null&&this.playedMatch()== true){
		finWeight = getLowestWeightWrestled();
	}
	
	return finWeight;
}

public boolean playedMatch() {
	if (matchWeight == null) {
		return false;
}	
	return true;
}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-10-13 22:32:39.340
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-10-13 22:32:39.340
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-13 22:32:39.352
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package JuniorHigh;

import java.util.*;
import java.util.Enumeration;

/*
 *
 *  This is a class to holds an wrestler and all data pertaining to him/her.
 */
class Wrestler {
	private String name;
	private String seed;
	private String cert;
	private String teamName;
	private WrestlingLanguage.Grade grade;
	private WrestlingLanguage.Gender gender;
	private String trackRecord;
	private String trackWtClass;
	private boolean rosteredLastYear;
	private String trackLastYearWtClass;
	private String trackLastYearRecord;
	private WrestlingLanguage.Prestige prestigeLastYear;
	private WrestlingLanguage.Prestige prestige2YearsAgo;
	private WrestlingLanguage.Prestige prestige3YearsAgo;
	
	private Hashtable<String,Integer> matchesAtWeight=new Hashtable<String,Integer>();
	
	private int wins;
	private int losses;
	private boolean lossByInjury=false;
	private String lossByInjuryString;
	private int winByFFT;
	private int lossByFFT;

	private int winByFall;
	private int winByDec;
	private int winByMD;
	private int winByTech;
	
	private int lossByFall;
	private int lossByDec;
	private int lossByMD;
	private int lossByTech;
	
	private int weight;
	
	private Hashtable<Integer,Integer> matchWeight=new Hashtable<Integer,Integer>();

		
	private WeighInHistory wiHistory;
	
	/* These 2 attributes are used to force where we put the wrestler in the reporting
	 * order.
	 */
	private String forceWeight=null;  /* for reporting force the use of this weight class. */
	private Integer forceRank=null;  /* for reporting this is the rank order withing the weight class. */

	public void setLossByInjuryString(String s) {
		lossByInjuryString = s;
	}
	public String getLossByInjuryString() { return lossByInjuryString; }
	
	public String getLowestWeightWrestled() {
		int lowInt=99999;
		
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
			int i =  Integer.parseInt(key);
		    if (i < lowInt ) {
		    	lowInt = i;
		    }
		}
		return Integer.toString(lowInt);
	}
	public String getPrintWeight() {
		if ( forceWeight != null ) {
			if ( forceWeight.length() > 0 ) {
				return forceWeight;
			}
		}
		return getLowestWeightWrestled();
	}
	public int getPrintRank() {
		if (forceRank == null ) {
			return getWins() + getLosses();
		} else {
			return 100000 - forceRank.intValue();
		}
	}
	public String getForceWeight() { return forceWeight; }
	public Integer getForceRank() { return forceRank; }
	
	public void setWeight( int w ) { 
		if (matchWeight.containsKey(w)) {
			int val =matchWeight.get(w);
			matchWeight.put(w, val+1);
			
		}
		else {
		matchWeight.put(w, 1);	
		}
		
	}
	public String getWeight() {
		Enumeration<Integer> e = matchWeight.keys();
		String WeightString="";
		while (e.hasMoreElements()) {
			 
	            // Getting the key of a particular entry
	            int keyWeight = e.nextElement();
	            int valueCount = matchWeight.get(keyWeight);
	            
	            WeightString += Integer.toString(valueCount) + "@" + Integer.toString(keyWeight) + " - ";
	             
	          
	        }
		return WeightString;
		
	}


	
	public void setForceWeight( String w ) { forceWeight = w; }
	public void setForceRank ( Integer i ) { forceRank = i; }
	
	List<Bout> bouts = new ArrayList<Bout> ();

	public List<Bout> getBouts() { return bouts; }
	
	public boolean getLossByInjury() { return lossByInjury; }
	
	public WeighInHistory getWeighInHistory() { return wiHistory; }
	
	public void setWeighInHistory(WeighInHistory wih ) { wiHistory = wih; }

	public void setPrestigeLastYear(WrestlingLanguage.Prestige p) { prestigeLastYear = p; }
	public void setPrestige2YearsAgo(WrestlingLanguage.Prestige p) { prestige2YearsAgo= p; }
	public void setPrestige3YearsAgo(WrestlingLanguage.Prestige p) { prestige3YearsAgo = p; }

	public WrestlingLanguage.Prestige getPrestigeLastYear() { return prestigeLastYear; }
	public WrestlingLanguage.Prestige getPrestige2YearsAgo() { return prestige2YearsAgo; }
	public WrestlingLanguage.Prestige getPrestige3YearsAgo() { return prestige3YearsAgo; }

    public void printVerbose () {
		System.out.println( getName() + 
			" Grade<" + getGrade() + ">" + 
			" Seed<" + getSeed() + ">" +
			" Cert<" + getCert() + ">"); 
			//" Gender<" + getGender() + "> Wt<" + 
			//getTrackWtClass() + ">" + " (" + getWins() + "W-" + 
			//getLosses() + "L) Last Year=<" + rosteredLastYear + "> Last Year Record <" + trackLastYearRecord + ">" );
    }	   
	public String getRecordString() { 
		return String.valueOf(wins) + "-" + String.valueOf(losses); 
	}
	public String getRecordBreakdown() {
		String breakdownString = "";
		boolean addedWins=false;
		if ( getWins() > 0 ) {
			breakdownString += getWins() + "W[";
			if ( getWinByFall() > 0 ) {
				breakdownString += getWinByFall() + " Pin,";
				addedWins=true;
			}
			if ( getWinByTech() > 0 ) {
				breakdownString += getWinByTech() + " TF,";
				addedWins=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getWinByMD() + " MD,";
				addedWins=true;
			}
			if ( getWinByDec() > 0 ) {
				breakdownString += getWinByDec() + " Dec,";
				addedWins=true;
			}
			if ( getWinByFFT() > 0 ) {
				breakdownString += getWinByFFT() + " FFT,";
				addedWins=true;
			}
			if ( addedWins ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "0 W";
		}
		boolean addedLosses=false;
		if ( getLosses() > 0 ) {
			breakdownString += "-" + getLosses() + "L[";
			if ( getLossByFall() > 0 ) {
				breakdownString += getLossByFall() + " Pin,";
				addedLosses=true;
			}
			if ( getLossByTech() > 0 ) {
				breakdownString += getLossByTech() + " TF,";
				addedLosses=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getLossByMD() + " MD,";
				addedLosses=true;
			}
			if ( getLossByDec() > 0 ) {
				breakdownString += getLossByDec() + " Dec,";
				addedLosses=true;
			}
			
			if ( addedLosses ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "-0L";
		}
		if ( getWins() ==0 && getLosses() == 0 ) {
			return "";
		} else {
			return breakdownString +" - "+ getWeight();
		}
	}
	public String getName() { return name; }
	public String getSeed() { return seed; }
	public String getCert() { return cert; }
	public String getTeamName() { return teamName; }
	public WrestlingLanguage.Grade getGrade() { return grade; }
	public WrestlingLanguage.Gender getGender() { return gender; }
	public String getTrackRecord() { return trackRecord; }
	public String getTrackWtClass() { return trackWtClass; }
	
	public int getWins() { return wins; }
	public int getLosses() { return losses; }
	
	public int getWinByFFT() { return winByFFT; }
	public int getWinByFall() { return winByFall; }
	public int getWinByTech() { return winByTech; }
	public int getWinByMD() { return winByMD; }
	public int getWinByDec() { return winByDec; }
	
	public int getLossByFFT() { return lossByFFT; }
	public int getLossByFall() { return lossByFall; }
	public int getLossByTech() { return lossByTech; }
	public int getLossByMD() { return lossByMD; }
	public int getLossByDec() { return lossByDec; }
	
    public Wrestler(String n, String team){
		setName(n);
		setTeamName(team);
		return;
	}
	public boolean getRosteredLastYear() { return rosteredLastYear; }
	
	public void setRosteredLastYearOn() { rosteredLastYear = true; }
	public void setRosteredLastYearOff() { rosteredLastYear = false; }
	
	public String getTrackLastYearWtClass() { return trackLastYearWtClass; }
	public String getTrackLastYearRecord() { return trackLastYearRecord; }
	
	public void setTrackLastYearWtClass(String w) { 
		trackLastYearWtClass = w; 
	}
	public void setTrackLastYearRecord(String r) {
		trackLastYearRecord = r;
	}
	
	
	public void addBout(Bout b) {
		String cmd=b.getMatchDate();
		if (cmd == null ) {
			Event e = b.getEvent();
			if ( e != null ) {
				String sss = e.getEventTitle();
				if ( wiHistory != null ) {
					String s = wiHistory.findWeighInDate(sss);
					if ( s != null ) { 
						b.setMatchDate(s);
					}
				}
			}
		}	
		
		bouts.add(b);
		addToSummary(b);
		addToMatchesAtWeight(b);
	}
	private void addToMatchesAtWeight(Bout b) {
		String w=b.getWeight();
		Integer ct = matchesAtWeight.get(w);
		if ( ct != null ) {
			ct++;
			matchesAtWeight.replace(w,ct);
		} else {
			matchesAtWeight.put(w,1);
		}
		return;
	}
	public String getMatchesAtWeightString() {

		String byWt="";
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
	
			int ct = matchesAtWeight.get(key);
			if ( byWt.length() > 0 ) { byWt=byWt + ";" ; }
			byWt=byWt + ct + "@" + key;
		}
		return byWt;
	}
	
	public void setName( String n ) {
		name = n.strip();
	}
	public void setSeed( String n ) {
		seed = n.strip();
	}
	public void setCert( String n ) {
		cert = n.strip();
	}
	public void setTeamName( String team ) {
		teamName = team;
	}
	public void setGrade5() { grade = WrestlingLanguage.Grade.G5;	}
	public void setGrade6() { grade = WrestlingLanguage.Grade.G6;	}
	public void setGrade7() { grade = WrestlingLanguage.Grade.G7;	}
	public void setGrade8() { grade = WrestlingLanguage.Grade.G8;	}
	public void setGrade(WrestlingLanguage.Grade g ) { grade=g; }
	
	public void setGenderM() { gender = WrestlingLanguage.Gender.M;	}
	public void setGenderF() { gender = WrestlingLanguage.Gender.F;	}
	public void setGender(WrestlingLanguage.Gender g ) { gender = g; }
	
	public void setTrackRecord(String rec) {
		trackRecord = rec;
	}
	public void setTrackWtClass(String w ) {
		trackWtClass = w;
	}
	public String toString() {
		return "Wrestler:" + teamName + ":" + name  ;
	}
	private void addToSummary(Bout b) {
	   if ( b.isAWin() ) {
          addWin();	
          switch ( b.getMatchResultType() ) {
			  case FFT: 
			    addWinByFFT();
				break;
			  case FALL:
			    addWinByFall();
				break;
			  case TECH:
			    addWinByTech();
				break;
			  case MD:
			    addWinByMD();
			    break;
			  case DEC:
			    addWinByDec();
				break;
			  case INJ:
			    break;
			  case DQ:
			    break;
		  }
       } else {
          addLoss();
          switch ( b.getMatchResultType() ) {

          case FFT:
			  addLossByFFT();
			    break;
			  case FALL:
			    addLossByFall();
				break;
			  case TECH:
			    addLossByTech();
				break;
			  case MD:
			    addLossByMD();
			    break;
			  case DEC:
			    addLossByDec();
				break;
			  case INJ:
			    if ( lossByInjury) {
			    	lossByInjuryString += ";";
			    } else {
			    	lossByInjury=true;
			    	lossByInjuryString= "Loss by Injury on ";
			    }
			    if ( b.getMatchDate() != null ) {
			    	lossByInjuryString += b.getMatchDate();
			    	lossByInjuryString += " ";
			    }
			    lossByInjuryString += " vs ";
			    lossByInjuryString += b.getOpponentTeam();
			    
			    break;
			  case DQ:
			    break;
		  }		  
       }		  
	}
	public void addWin() { wins++; }
	public void addLoss() { losses++; }
	public void addWinByFFT() { winByFFT++; }
	public void addWinByFall() { winByFall++; }
	public void addWinByTech() { winByTech++; }
	public void addWinByMD() { winByMD++; }
	public void addWinByDec() { winByDec++; }
	
	public void addLossByFFT() { lossByFFT++; }
	public void addLossByFall() { lossByFall++; }
	public void addLossByTech() { lossByTech++; }
	public void addLossByMD() { lossByMD++; }
	public void addLossByDec() { lossByDec++; }

	public boolean equals(Object o) {
	  if ( o == null ) { return false; }
	  if ( this == o ) { return true; }
	  if ( this.getClass() == o.getClass() ){
         Wrestler ow = (Wrestler) o;		  
	     if ( this.getName().equals(ow.getName()) && this.getTeamName().equals(ow.getTeamName())) {
			 return true;
	     }
	  }
	  return false; 
	}
	public int hashCode() {
		return getName().hashCode() + getTeamName().hashCode();
	}


public String getFinWeight() {
	String finWeight = "";
	boolean a = playedMatch();
	
	if(cert != null) {
		finWeight = cert;
	}
	else (this.cert == null&&this.playedMatch()== true){
		finWeight = getLowestWeightWrestled();
	}
	
	return finWeight;
}

public boolean playedMatch() {
	if (matchWeight == null) {
		return false;
}	
	return true;
}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-13 22:32:39.352
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-13 22:32:39.353
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-13 22:32:41.329
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package JuniorHigh;

import java.util.*;
import java.util.Enumeration;

/*
 *
 *  This is a class to holds an wrestler and all data pertaining to him/her.
 */
class Wrestler {
	private String name;
	private String seed;
	private String cert;
	private String teamName;
	private WrestlingLanguage.Grade grade;
	private WrestlingLanguage.Gender gender;
	private String trackRecord;
	private String trackWtClass;
	private boolean rosteredLastYear;
	private String trackLastYearWtClass;
	private String trackLastYearRecord;
	private WrestlingLanguage.Prestige prestigeLastYear;
	private WrestlingLanguage.Prestige prestige2YearsAgo;
	private WrestlingLanguage.Prestige prestige3YearsAgo;
	
	private Hashtable<String,Integer> matchesAtWeight=new Hashtable<String,Integer>();
	
	private int wins;
	private int losses;
	private boolean lossByInjury=false;
	private String lossByInjuryString;
	private int winByFFT;
	private int lossByFFT;

	private int winByFall;
	private int winByDec;
	private int winByMD;
	private int winByTech;
	
	private int lossByFall;
	private int lossByDec;
	private int lossByMD;
	private int lossByTech;
	
	private int weight;
	
	private Hashtable<Integer,Integer> matchWeight=new Hashtable<Integer,Integer>();

		
	private WeighInHistory wiHistory;
	
	/* These 2 attributes are used to force where we put the wrestler in the reporting
	 * order.
	 */
	private String forceWeight=null;  /* for reporting force the use of this weight class. */
	private Integer forceRank=null;  /* for reporting this is the rank order withing the weight class. */

	public void setLossByInjuryString(String s) {
		lossByInjuryString = s;
	}
	public String getLossByInjuryString() { return lossByInjuryString; }
	
	public String getLowestWeightWrestled() {
		int lowInt=99999;
		
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
			int i =  Integer.parseInt(key);
		    if (i < lowInt ) {
		    	lowInt = i;
		    }
		}
		return Integer.toString(lowInt);
	}
	public String getPrintWeight() {
		if ( forceWeight != null ) {
			if ( forceWeight.length() > 0 ) {
				return forceWeight;
			}
		}
		return getLowestWeightWrestled();
	}
	public int getPrintRank() {
		if (forceRank == null ) {
			return getWins() + getLosses();
		} else {
			return 100000 - forceRank.intValue();
		}
	}
	public String getForceWeight() { return forceWeight; }
	public Integer getForceRank() { return forceRank; }
	
	public void setWeight( int w ) { 
		if (matchWeight.containsKey(w)) {
			int val =matchWeight.get(w);
			matchWeight.put(w, val+1);
			
		}
		else {
		matchWeight.put(w, 1);	
		}
		
	}
	public String getWeight() {
		Enumeration<Integer> e = matchWeight.keys();
		String WeightString="";
		while (e.hasMoreElements()) {
			 
	            // Getting the key of a particular entry
	            int keyWeight = e.nextElement();
	            int valueCount = matchWeight.get(keyWeight);
	            
	            WeightString += Integer.toString(valueCount) + "@" + Integer.toString(keyWeight) + " - ";
	             
	          
	        }
		return WeightString;
		
	}


	
	public void setForceWeight( String w ) { forceWeight = w; }
	public void setForceRank ( Integer i ) { forceRank = i; }
	
	List<Bout> bouts = new ArrayList<Bout> ();

	public List<Bout> getBouts() { return bouts; }
	
	public boolean getLossByInjury() { return lossByInjury; }
	
	public WeighInHistory getWeighInHistory() { return wiHistory; }
	
	public void setWeighInHistory(WeighInHistory wih ) { wiHistory = wih; }

	public void setPrestigeLastYear(WrestlingLanguage.Prestige p) { prestigeLastYear = p; }
	public void setPrestige2YearsAgo(WrestlingLanguage.Prestige p) { prestige2YearsAgo= p; }
	public void setPrestige3YearsAgo(WrestlingLanguage.Prestige p) { prestige3YearsAgo = p; }

	public WrestlingLanguage.Prestige getPrestigeLastYear() { return prestigeLastYear; }
	public WrestlingLanguage.Prestige getPrestige2YearsAgo() { return prestige2YearsAgo; }
	public WrestlingLanguage.Prestige getPrestige3YearsAgo() { return prestige3YearsAgo; }

    public void printVerbose () {
		System.out.println( getName() + 
			" Grade<" + getGrade() + ">" + 
			" Seed<" + getSeed() + ">" +
			" Cert<" + getCert() + ">"); 
			//" Gender<" + getGender() + "> Wt<" + 
			//getTrackWtClass() + ">" + " (" + getWins() + "W-" + 
			//getLosses() + "L) Last Year=<" + rosteredLastYear + "> Last Year Record <" + trackLastYearRecord + ">" );
    }	   
	public String getRecordString() { 
		return String.valueOf(wins) + "-" + String.valueOf(losses); 
	}
	public String getRecordBreakdown() {
		String breakdownString = "";
		boolean addedWins=false;
		if ( getWins() > 0 ) {
			breakdownString += getWins() + "W[";
			if ( getWinByFall() > 0 ) {
				breakdownString += getWinByFall() + " Pin,";
				addedWins=true;
			}
			if ( getWinByTech() > 0 ) {
				breakdownString += getWinByTech() + " TF,";
				addedWins=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getWinByMD() + " MD,";
				addedWins=true;
			}
			if ( getWinByDec() > 0 ) {
				breakdownString += getWinByDec() + " Dec,";
				addedWins=true;
			}
			if ( getWinByFFT() > 0 ) {
				breakdownString += getWinByFFT() + " FFT,";
				addedWins=true;
			}
			if ( addedWins ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "0 W";
		}
		boolean addedLosses=false;
		if ( getLosses() > 0 ) {
			breakdownString += "-" + getLosses() + "L[";
			if ( getLossByFall() > 0 ) {
				breakdownString += getLossByFall() + " Pin,";
				addedLosses=true;
			}
			if ( getLossByTech() > 0 ) {
				breakdownString += getLossByTech() + " TF,";
				addedLosses=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getLossByMD() + " MD,";
				addedLosses=true;
			}
			if ( getLossByDec() > 0 ) {
				breakdownString += getLossByDec() + " Dec,";
				addedLosses=true;
			}
			
			if ( addedLosses ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "-0L";
		}
		if ( getWins() ==0 && getLosses() == 0 ) {
			return "";
		} else {
			return breakdownString +" - "+ getWeight();
		}
	}
	public String getName() { return name; }
	public String getSeed() { return seed; }
	public String getCert() { return cert; }
	public String getTeamName() { return teamName; }
	public WrestlingLanguage.Grade getGrade() { return grade; }
	public WrestlingLanguage.Gender getGender() { return gender; }
	public String getTrackRecord() { return trackRecord; }
	public String getTrackWtClass() { return trackWtClass; }
	
	public int getWins() { return wins; }
	public int getLosses() { return losses; }
	
	public int getWinByFFT() { return winByFFT; }
	public int getWinByFall() { return winByFall; }
	public int getWinByTech() { return winByTech; }
	public int getWinByMD() { return winByMD; }
	public int getWinByDec() { return winByDec; }
	
	public int getLossByFFT() { return lossByFFT; }
	public int getLossByFall() { return lossByFall; }
	public int getLossByTech() { return lossByTech; }
	public int getLossByMD() { return lossByMD; }
	public int getLossByDec() { return lossByDec; }
	
    public Wrestler(String n, String team){
		setName(n);
		setTeamName(team);
		return;
	}
	public boolean getRosteredLastYear() { return rosteredLastYear; }
	
	public void setRosteredLastYearOn() { rosteredLastYear = true; }
	public void setRosteredLastYearOff() { rosteredLastYear = false; }
	
	public String getTrackLastYearWtClass() { return trackLastYearWtClass; }
	public String getTrackLastYearRecord() { return trackLastYearRecord; }
	
	public void setTrackLastYearWtClass(String w) { 
		trackLastYearWtClass = w; 
	}
	public void setTrackLastYearRecord(String r) {
		trackLastYearRecord = r;
	}
	
	
	public void addBout(Bout b) {
		String cmd=b.getMatchDate();
		if (cmd == null ) {
			Event e = b.getEvent();
			if ( e != null ) {
				String sss = e.getEventTitle();
				if ( wiHistory != null ) {
					String s = wiHistory.findWeighInDate(sss);
					if ( s != null ) { 
						b.setMatchDate(s);
					}
				}
			}
		}	
		
		bouts.add(b);
		addToSummary(b);
		addToMatchesAtWeight(b);
	}
	private void addToMatchesAtWeight(Bout b) {
		String w=b.getWeight();
		Integer ct = matchesAtWeight.get(w);
		if ( ct != null ) {
			ct++;
			matchesAtWeight.replace(w,ct);
		} else {
			matchesAtWeight.put(w,1);
		}
		return;
	}
	public String getMatchesAtWeightString() {

		String byWt="";
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
	
			int ct = matchesAtWeight.get(key);
			if ( byWt.length() > 0 ) { byWt=byWt + ";" ; }
			byWt=byWt + ct + "@" + key;
		}
		return byWt;
	}
	
	public void setName( String n ) {
		name = n.strip();
	}
	public void setSeed( String n ) {
		seed = n.strip();
	}
	public void setCert( String n ) {
		cert = n.strip();
	}
	public void setTeamName( String team ) {
		teamName = team;
	}
	public void setGrade5() { grade = WrestlingLanguage.Grade.G5;	}
	public void setGrade6() { grade = WrestlingLanguage.Grade.G6;	}
	public void setGrade7() { grade = WrestlingLanguage.Grade.G7;	}
	public void setGrade8() { grade = WrestlingLanguage.Grade.G8;	}
	public void setGrade(WrestlingLanguage.Grade g ) { grade=g; }
	
	public void setGenderM() { gender = WrestlingLanguage.Gender.M;	}
	public void setGenderF() { gender = WrestlingLanguage.Gender.F;	}
	public void setGender(WrestlingLanguage.Gender g ) { gender = g; }
	
	public void setTrackRecord(String rec) {
		trackRecord = rec;
	}
	public void setTrackWtClass(String w ) {
		trackWtClass = w;
	}
	public String toString() {
		return "Wrestler:" + teamName + ":" + name  ;
	}
	private void addToSummary(Bout b) {
	   if ( b.isAWin() ) {
          addWin();	
          switch ( b.getMatchResultType() ) {
			  case FFT: 
			    addWinByFFT();
				break;
			  case FALL:
			    addWinByFall();
				break;
			  case TECH:
			    addWinByTech();
				break;
			  case MD:
			    addWinByMD();
			    break;
			  case DEC:
			    addWinByDec();
				break;
			  case INJ:
			    break;
			  case DQ:
			    break;
		  }
       } else {
          addLoss();
          switch ( b.getMatchResultType() ) {

          case FFT:
			  addLossByFFT();
			    break;
			  case FALL:
			    addLossByFall();
				break;
			  case TECH:
			    addLossByTech();
				break;
			  case MD:
			    addLossByMD();
			    break;
			  case DEC:
			    addLossByDec();
				break;
			  case INJ:
			    if ( lossByInjury) {
			    	lossByInjuryString += ";";
			    } else {
			    	lossByInjury=true;
			    	lossByInjuryString= "Loss by Injury on ";
			    }
			    if ( b.getMatchDate() != null ) {
			    	lossByInjuryString += b.getMatchDate();
			    	lossByInjuryString += " ";
			    }
			    lossByInjuryString += " vs ";
			    lossByInjuryString += b.getOpponentTeam();
			    
			    break;
			  case DQ:
			    break;
		  }		  
       }		  
	}
	public void addWin() { wins++; }
	public void addLoss() { losses++; }
	public void addWinByFFT() { winByFFT++; }
	public void addWinByFall() { winByFall++; }
	public void addWinByTech() { winByTech++; }
	public void addWinByMD() { winByMD++; }
	public void addWinByDec() { winByDec++; }
	
	public void addLossByFFT() { lossByFFT++; }
	public void addLossByFall() { lossByFall++; }
	public void addLossByTech() { lossByTech++; }
	public void addLossByMD() { lossByMD++; }
	public void addLossByDec() { lossByDec++; }

	public boolean equals(Object o) {
	  if ( o == null ) { return false; }
	  if ( this == o ) { return true; }
	  if ( this.getClass() == o.getClass() ){
         Wrestler ow = (Wrestler) o;		  
	     if ( this.getName().equals(ow.getName()) && this.getTeamName().equals(ow.getTeamName())) {
			 return true;
	     }
	  }
	  return false; 
	}
	public int hashCode() {
		return getName().hashCode() + getTeamName().hashCode();
	}


public String getFinWeight() {
	String finWeight = "";
	boolean a = playedMatch();
	
	if(cert != null) {
		finWeight = cert;
	}
	else (this.cert == null&&this.playedMatch()== true){
		finWeight = getLowestWeightWrestled();
	}
	
	return finWeight;
}

public boolean playedMatch() {
	if (matchWeight == null) {
		return false;
}	
	return true;
}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-13 22:32:41.332
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-13 22:32:41.333
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-13 22:32:44.301
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package JuniorHigh;

import java.util.*;
import java.util.Enumeration;

/*
 *
 *  This is a class to holds an wrestler and all data pertaining to him/her.
 */
class Wrestler {
	private String name;
	private String seed;
	private String cert;
	private String teamName;
	private WrestlingLanguage.Grade grade;
	private WrestlingLanguage.Gender gender;
	private String trackRecord;
	private String trackWtClass;
	private boolean rosteredLastYear;
	private String trackLastYearWtClass;
	private String trackLastYearRecord;
	private WrestlingLanguage.Prestige prestigeLastYear;
	private WrestlingLanguage.Prestige prestige2YearsAgo;
	private WrestlingLanguage.Prestige prestige3YearsAgo;
	
	private Hashtable<String,Integer> matchesAtWeight=new Hashtable<String,Integer>();
	
	private int wins;
	private int losses;
	private boolean lossByInjury=false;
	private String lossByInjuryString;
	private int winByFFT;
	private int lossByFFT;

	private int winByFall;
	private int winByDec;
	private int winByMD;
	private int winByTech;
	
	private int lossByFall;
	private int lossByDec;
	private int lossByMD;
	private int lossByTech;
	
	private int weight;
	
	private Hashtable<Integer,Integer> matchWeight=new Hashtable<Integer,Integer>();

		
	private WeighInHistory wiHistory;
	
	/* These 2 attributes are used to force where we put the wrestler in the reporting
	 * order.
	 */
	private String forceWeight=null;  /* for reporting force the use of this weight class. */
	private Integer forceRank=null;  /* for reporting this is the rank order withing the weight class. */

	public void setLossByInjuryString(String s) {
		lossByInjuryString = s;
	}
	public String getLossByInjuryString() { return lossByInjuryString; }
	
	public String getLowestWeightWrestled() {
		int lowInt=99999;
		
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
			int i =  Integer.parseInt(key);
		    if (i < lowInt ) {
		    	lowInt = i;
		    }
		}
		return Integer.toString(lowInt);
	}
	public String getPrintWeight() {
		if ( forceWeight != null ) {
			if ( forceWeight.length() > 0 ) {
				return forceWeight;
			}
		}
		return getLowestWeightWrestled();
	}
	public int getPrintRank() {
		if (forceRank == null ) {
			return getWins() + getLosses();
		} else {
			return 100000 - forceRank.intValue();
		}
	}
	public String getForceWeight() { return forceWeight; }
	public Integer getForceRank() { return forceRank; }
	
	public void setWeight( int w ) { 
		if (matchWeight.containsKey(w)) {
			int val =matchWeight.get(w);
			matchWeight.put(w, val+1);
			
		}
		else {
		matchWeight.put(w, 1);	
		}
		
	}
	public String getWeight() {
		Enumeration<Integer> e = matchWeight.keys();
		String WeightString="";
		while (e.hasMoreElements()) {
			 
	            // Getting the key of a particular entry
	            int keyWeight = e.nextElement();
	            int valueCount = matchWeight.get(keyWeight);
	            
	            WeightString += Integer.toString(valueCount) + "@" + Integer.toString(keyWeight) + " - ";
	             
	          
	        }
		return WeightString;
		
	}


	
	public void setForceWeight( String w ) { forceWeight = w; }
	public void setForceRank ( Integer i ) { forceRank = i; }
	
	List<Bout> bouts = new ArrayList<Bout> ();

	public List<Bout> getBouts() { return bouts; }
	
	public boolean getLossByInjury() { return lossByInjury; }
	
	public WeighInHistory getWeighInHistory() { return wiHistory; }
	
	public void setWeighInHistory(WeighInHistory wih ) { wiHistory = wih; }

	public void setPrestigeLastYear(WrestlingLanguage.Prestige p) { prestigeLastYear = p; }
	public void setPrestige2YearsAgo(WrestlingLanguage.Prestige p) { prestige2YearsAgo= p; }
	public void setPrestige3YearsAgo(WrestlingLanguage.Prestige p) { prestige3YearsAgo = p; }

	public WrestlingLanguage.Prestige getPrestigeLastYear() { return prestigeLastYear; }
	public WrestlingLanguage.Prestige getPrestige2YearsAgo() { return prestige2YearsAgo; }
	public WrestlingLanguage.Prestige getPrestige3YearsAgo() { return prestige3YearsAgo; }

    public void printVerbose () {
		System.out.println( getName() + 
			" Grade<" + getGrade() + ">" + 
			" Seed<" + getSeed() + ">" +
			" Cert<" + getCert() + ">"); 
			//" Gender<" + getGender() + "> Wt<" + 
			//getTrackWtClass() + ">" + " (" + getWins() + "W-" + 
			//getLosses() + "L) Last Year=<" + rosteredLastYear + "> Last Year Record <" + trackLastYearRecord + ">" );
    }	   
	public String getRecordString() { 
		return String.valueOf(wins) + "-" + String.valueOf(losses); 
	}
	public String getRecordBreakdown() {
		String breakdownString = "";
		boolean addedWins=false;
		if ( getWins() > 0 ) {
			breakdownString += getWins() + "W[";
			if ( getWinByFall() > 0 ) {
				breakdownString += getWinByFall() + " Pin,";
				addedWins=true;
			}
			if ( getWinByTech() > 0 ) {
				breakdownString += getWinByTech() + " TF,";
				addedWins=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getWinByMD() + " MD,";
				addedWins=true;
			}
			if ( getWinByDec() > 0 ) {
				breakdownString += getWinByDec() + " Dec,";
				addedWins=true;
			}
			if ( getWinByFFT() > 0 ) {
				breakdownString += getWinByFFT() + " FFT,";
				addedWins=true;
			}
			if ( addedWins ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "0 W";
		}
		boolean addedLosses=false;
		if ( getLosses() > 0 ) {
			breakdownString += "-" + getLosses() + "L[";
			if ( getLossByFall() > 0 ) {
				breakdownString += getLossByFall() + " Pin,";
				addedLosses=true;
			}
			if ( getLossByTech() > 0 ) {
				breakdownString += getLossByTech() + " TF,";
				addedLosses=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getLossByMD() + " MD,";
				addedLosses=true;
			}
			if ( getLossByDec() > 0 ) {
				breakdownString += getLossByDec() + " Dec,";
				addedLosses=true;
			}
			
			if ( addedLosses ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "-0L";
		}
		if ( getWins() ==0 && getLosses() == 0 ) {
			return "";
		} else {
			return breakdownString +" - "+ getWeight();
		}
	}
	public String getName() { return name; }
	public String getSeed() { return seed; }
	public String getCert() { return cert; }
	public String getTeamName() { return teamName; }
	public WrestlingLanguage.Grade getGrade() { return grade; }
	public WrestlingLanguage.Gender getGender() { return gender; }
	public String getTrackRecord() { return trackRecord; }
	public String getTrackWtClass() { return trackWtClass; }
	
	public int getWins() { return wins; }
	public int getLosses() { return losses; }
	
	public int getWinByFFT() { return winByFFT; }
	public int getWinByFall() { return winByFall; }
	public int getWinByTech() { return winByTech; }
	public int getWinByMD() { return winByMD; }
	public int getWinByDec() { return winByDec; }
	
	public int getLossByFFT() { return lossByFFT; }
	public int getLossByFall() { return lossByFall; }
	public int getLossByTech() { return lossByTech; }
	public int getLossByMD() { return lossByMD; }
	public int getLossByDec() { return lossByDec; }
	
    public Wrestler(String n, String team){
		setName(n);
		setTeamName(team);
		return;
	}
	public boolean getRosteredLastYear() { return rosteredLastYear; }
	
	public void setRosteredLastYearOn() { rosteredLastYear = true; }
	public void setRosteredLastYearOff() { rosteredLastYear = false; }
	
	public String getTrackLastYearWtClass() { return trackLastYearWtClass; }
	public String getTrackLastYearRecord() { return trackLastYearRecord; }
	
	public void setTrackLastYearWtClass(String w) { 
		trackLastYearWtClass = w; 
	}
	public void setTrackLastYearRecord(String r) {
		trackLastYearRecord = r;
	}
	
	
	public void addBout(Bout b) {
		String cmd=b.getMatchDate();
		if (cmd == null ) {
			Event e = b.getEvent();
			if ( e != null ) {
				String sss = e.getEventTitle();
				if ( wiHistory != null ) {
					String s = wiHistory.findWeighInDate(sss);
					if ( s != null ) { 
						b.setMatchDate(s);
					}
				}
			}
		}	
		
		bouts.add(b);
		addToSummary(b);
		addToMatchesAtWeight(b);
	}
	private void addToMatchesAtWeight(Bout b) {
		String w=b.getWeight();
		Integer ct = matchesAtWeight.get(w);
		if ( ct != null ) {
			ct++;
			matchesAtWeight.replace(w,ct);
		} else {
			matchesAtWeight.put(w,1);
		}
		return;
	}
	public String getMatchesAtWeightString() {

		String byWt="";
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
	
			int ct = matchesAtWeight.get(key);
			if ( byWt.length() > 0 ) { byWt=byWt + ";" ; }
			byWt=byWt + ct + "@" + key;
		}
		return byWt;
	}
	
	public void setName( String n ) {
		name = n.strip();
	}
	public void setSeed( String n ) {
		seed = n.strip();
	}
	public void setCert( String n ) {
		cert = n.strip();
	}
	public void setTeamName( String team ) {
		teamName = team;
	}
	public void setGrade5() { grade = WrestlingLanguage.Grade.G5;	}
	public void setGrade6() { grade = WrestlingLanguage.Grade.G6;	}
	public void setGrade7() { grade = WrestlingLanguage.Grade.G7;	}
	public void setGrade8() { grade = WrestlingLanguage.Grade.G8;	}
	public void setGrade(WrestlingLanguage.Grade g ) { grade=g; }
	
	public void setGenderM() { gender = WrestlingLanguage.Gender.M;	}
	public void setGenderF() { gender = WrestlingLanguage.Gender.F;	}
	public void setGender(WrestlingLanguage.Gender g ) { gender = g; }
	
	public void setTrackRecord(String rec) {
		trackRecord = rec;
	}
	public void setTrackWtClass(String w ) {
		trackWtClass = w;
	}
	public String toString() {
		return "Wrestler:" + teamName + ":" + name  ;
	}
	private void addToSummary(Bout b) {
	   if ( b.isAWin() ) {
          addWin();	
          switch ( b.getMatchResultType() ) {
			  case FFT: 
			    addWinByFFT();
				break;
			  case FALL:
			    addWinByFall();
				break;
			  case TECH:
			    addWinByTech();
				break;
			  case MD:
			    addWinByMD();
			    break;
			  case DEC:
			    addWinByDec();
				break;
			  case INJ:
			    break;
			  case DQ:
			    break;
		  }
       } else {
          addLoss();
          switch ( b.getMatchResultType() ) {

          case FFT:
			  addLossByFFT();
			    break;
			  case FALL:
			    addLossByFall();
				break;
			  case TECH:
			    addLossByTech();
				break;
			  case MD:
			    addLossByMD();
			    break;
			  case DEC:
			    addLossByDec();
				break;
			  case INJ:
			    if ( lossByInjury) {
			    	lossByInjuryString += ";";
			    } else {
			    	lossByInjury=true;
			    	lossByInjuryString= "Loss by Injury on ";
			    }
			    if ( b.getMatchDate() != null ) {
			    	lossByInjuryString += b.getMatchDate();
			    	lossByInjuryString += " ";
			    }
			    lossByInjuryString += " vs ";
			    lossByInjuryString += b.getOpponentTeam();
			    
			    break;
			  case DQ:
			    break;
		  }		  
       }		  
	}
	public void addWin() { wins++; }
	public void addLoss() { losses++; }
	public void addWinByFFT() { winByFFT++; }
	public void addWinByFall() { winByFall++; }
	public void addWinByTech() { winByTech++; }
	public void addWinByMD() { winByMD++; }
	public void addWinByDec() { winByDec++; }
	
	public void addLossByFFT() { lossByFFT++; }
	public void addLossByFall() { lossByFall++; }
	public void addLossByTech() { lossByTech++; }
	public void addLossByMD() { lossByMD++; }
	public void addLossByDec() { lossByDec++; }

	public boolean equals(Object o) {
	  if ( o == null ) { return false; }
	  if ( this == o ) { return true; }
	  if ( this.getClass() == o.getClass() ){
         Wrestler ow = (Wrestler) o;		  
	     if ( this.getName().equals(ow.getName()) && this.getTeamName().equals(ow.getTeamName())) {
			 return true;
	     }
	  }
	  return false; 
	}
	public int hashCode() {
		return getName().hashCode() + getTeamName().hashCode();
	}


public String getFinWeight() {
	String finWeight = "";
	boolean a = playedMatch();
	
	if(cert != null) {
		finWeight = cert;
	}
	else (this.cert == null&&this.playedMatch()== true){
		finWeight = getLowestWeightWrestled();
	}
	
	return finWeight;
}

public boolean playedMatch() {
	if (matchWeight == null) {
		return false;
}	
	return true;
}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-10-13 22:32:44.304
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-10-13 22:32:44.304
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-13 22:32:44.317
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package JuniorHigh;

import java.util.*;
import java.util.Enumeration;

/*
 *
 *  This is a class to holds an wrestler and all data pertaining to him/her.
 */
class Wrestler {
	private String name;
	private String seed;
	private String cert;
	private String teamName;
	private WrestlingLanguage.Grade grade;
	private WrestlingLanguage.Gender gender;
	private String trackRecord;
	private String trackWtClass;
	private boolean rosteredLastYear;
	private String trackLastYearWtClass;
	private String trackLastYearRecord;
	private WrestlingLanguage.Prestige prestigeLastYear;
	private WrestlingLanguage.Prestige prestige2YearsAgo;
	private WrestlingLanguage.Prestige prestige3YearsAgo;
	
	private Hashtable<String,Integer> matchesAtWeight=new Hashtable<String,Integer>();
	
	private int wins;
	private int losses;
	private boolean lossByInjury=false;
	private String lossByInjuryString;
	private int winByFFT;
	private int lossByFFT;

	private int winByFall;
	private int winByDec;
	private int winByMD;
	private int winByTech;
	
	private int lossByFall;
	private int lossByDec;
	private int lossByMD;
	private int lossByTech;
	
	private int weight;
	
	private Hashtable<Integer,Integer> matchWeight=new Hashtable<Integer,Integer>();

		
	private WeighInHistory wiHistory;
	
	/* These 2 attributes are used to force where we put the wrestler in the reporting
	 * order.
	 */
	private String forceWeight=null;  /* for reporting force the use of this weight class. */
	private Integer forceRank=null;  /* for reporting this is the rank order withing the weight class. */

	public void setLossByInjuryString(String s) {
		lossByInjuryString = s;
	}
	public String getLossByInjuryString() { return lossByInjuryString; }
	
	public String getLowestWeightWrestled() {
		int lowInt=99999;
		
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
			int i =  Integer.parseInt(key);
		    if (i < lowInt ) {
		    	lowInt = i;
		    }
		}
		return Integer.toString(lowInt);
	}
	public String getPrintWeight() {
		if ( forceWeight != null ) {
			if ( forceWeight.length() > 0 ) {
				return forceWeight;
			}
		}
		return getLowestWeightWrestled();
	}
	public int getPrintRank() {
		if (forceRank == null ) {
			return getWins() + getLosses();
		} else {
			return 100000 - forceRank.intValue();
		}
	}
	public String getForceWeight() { return forceWeight; }
	public Integer getForceRank() { return forceRank; }
	
	public void setWeight( int w ) { 
		if (matchWeight.containsKey(w)) {
			int val =matchWeight.get(w);
			matchWeight.put(w, val+1);
			
		}
		else {
		matchWeight.put(w, 1);	
		}
		
	}
	public String getWeight() {
		Enumeration<Integer> e = matchWeight.keys();
		String WeightString="";
		while (e.hasMoreElements()) {
			 
	            // Getting the key of a particular entry
	            int keyWeight = e.nextElement();
	            int valueCount = matchWeight.get(keyWeight);
	            
	            WeightString += Integer.toString(valueCount) + "@" + Integer.toString(keyWeight) + " - ";
	             
	          
	        }
		return WeightString;
		
	}


	
	public void setForceWeight( String w ) { forceWeight = w; }
	public void setForceRank ( Integer i ) { forceRank = i; }
	
	List<Bout> bouts = new ArrayList<Bout> ();

	public List<Bout> getBouts() { return bouts; }
	
	public boolean getLossByInjury() { return lossByInjury; }
	
	public WeighInHistory getWeighInHistory() { return wiHistory; }
	
	public void setWeighInHistory(WeighInHistory wih ) { wiHistory = wih; }

	public void setPrestigeLastYear(WrestlingLanguage.Prestige p) { prestigeLastYear = p; }
	public void setPrestige2YearsAgo(WrestlingLanguage.Prestige p) { prestige2YearsAgo= p; }
	public void setPrestige3YearsAgo(WrestlingLanguage.Prestige p) { prestige3YearsAgo = p; }

	public WrestlingLanguage.Prestige getPrestigeLastYear() { return prestigeLastYear; }
	public WrestlingLanguage.Prestige getPrestige2YearsAgo() { return prestige2YearsAgo; }
	public WrestlingLanguage.Prestige getPrestige3YearsAgo() { return prestige3YearsAgo; }

    public void printVerbose () {
		System.out.println( getName() + 
			" Grade<" + getGrade() + ">" + 
			" Seed<" + getSeed() + ">" +
			" Cert<" + getCert() + ">"); 
			//" Gender<" + getGender() + "> Wt<" + 
			//getTrackWtClass() + ">" + " (" + getWins() + "W-" + 
			//getLosses() + "L) Last Year=<" + rosteredLastYear + "> Last Year Record <" + trackLastYearRecord + ">" );
    }	   
	public String getRecordString() { 
		return String.valueOf(wins) + "-" + String.valueOf(losses); 
	}
	public String getRecordBreakdown() {
		String breakdownString = "";
		boolean addedWins=false;
		if ( getWins() > 0 ) {
			breakdownString += getWins() + "W[";
			if ( getWinByFall() > 0 ) {
				breakdownString += getWinByFall() + " Pin,";
				addedWins=true;
			}
			if ( getWinByTech() > 0 ) {
				breakdownString += getWinByTech() + " TF,";
				addedWins=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getWinByMD() + " MD,";
				addedWins=true;
			}
			if ( getWinByDec() > 0 ) {
				breakdownString += getWinByDec() + " Dec,";
				addedWins=true;
			}
			if ( getWinByFFT() > 0 ) {
				breakdownString += getWinByFFT() + " FFT,";
				addedWins=true;
			}
			if ( addedWins ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "0 W";
		}
		boolean addedLosses=false;
		if ( getLosses() > 0 ) {
			breakdownString += "-" + getLosses() + "L[";
			if ( getLossByFall() > 0 ) {
				breakdownString += getLossByFall() + " Pin,";
				addedLosses=true;
			}
			if ( getLossByTech() > 0 ) {
				breakdownString += getLossByTech() + " TF,";
				addedLosses=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getLossByMD() + " MD,";
				addedLosses=true;
			}
			if ( getLossByDec() > 0 ) {
				breakdownString += getLossByDec() + " Dec,";
				addedLosses=true;
			}
			
			if ( addedLosses ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "-0L";
		}
		if ( getWins() ==0 && getLosses() == 0 ) {
			return "";
		} else {
			return breakdownString +" - "+ getWeight();
		}
	}
	public String getName() { return name; }
	public String getSeed() { return seed; }
	public String getCert() { return cert; }
	public String getTeamName() { return teamName; }
	public WrestlingLanguage.Grade getGrade() { return grade; }
	public WrestlingLanguage.Gender getGender() { return gender; }
	public String getTrackRecord() { return trackRecord; }
	public String getTrackWtClass() { return trackWtClass; }
	
	public int getWins() { return wins; }
	public int getLosses() { return losses; }
	
	public int getWinByFFT() { return winByFFT; }
	public int getWinByFall() { return winByFall; }
	public int getWinByTech() { return winByTech; }
	public int getWinByMD() { return winByMD; }
	public int getWinByDec() { return winByDec; }
	
	public int getLossByFFT() { return lossByFFT; }
	public int getLossByFall() { return lossByFall; }
	public int getLossByTech() { return lossByTech; }
	public int getLossByMD() { return lossByMD; }
	public int getLossByDec() { return lossByDec; }
	
    public Wrestler(String n, String team){
		setName(n);
		setTeamName(team);
		return;
	}
	public boolean getRosteredLastYear() { return rosteredLastYear; }
	
	public void setRosteredLastYearOn() { rosteredLastYear = true; }
	public void setRosteredLastYearOff() { rosteredLastYear = false; }
	
	public String getTrackLastYearWtClass() { return trackLastYearWtClass; }
	public String getTrackLastYearRecord() { return trackLastYearRecord; }
	
	public void setTrackLastYearWtClass(String w) { 
		trackLastYearWtClass = w; 
	}
	public void setTrackLastYearRecord(String r) {
		trackLastYearRecord = r;
	}
	
	
	public void addBout(Bout b) {
		String cmd=b.getMatchDate();
		if (cmd == null ) {
			Event e = b.getEvent();
			if ( e != null ) {
				String sss = e.getEventTitle();
				if ( wiHistory != null ) {
					String s = wiHistory.findWeighInDate(sss);
					if ( s != null ) { 
						b.setMatchDate(s);
					}
				}
			}
		}	
		
		bouts.add(b);
		addToSummary(b);
		addToMatchesAtWeight(b);
	}
	private void addToMatchesAtWeight(Bout b) {
		String w=b.getWeight();
		Integer ct = matchesAtWeight.get(w);
		if ( ct != null ) {
			ct++;
			matchesAtWeight.replace(w,ct);
		} else {
			matchesAtWeight.put(w,1);
		}
		return;
	}
	public String getMatchesAtWeightString() {

		String byWt="";
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
	
			int ct = matchesAtWeight.get(key);
			if ( byWt.length() > 0 ) { byWt=byWt + ";" ; }
			byWt=byWt + ct + "@" + key;
		}
		return byWt;
	}
	
	public void setName( String n ) {
		name = n.strip();
	}
	public void setSeed( String n ) {
		seed = n.strip();
	}
	public void setCert( String n ) {
		cert = n.strip();
	}
	public void setTeamName( String team ) {
		teamName = team;
	}
	public void setGrade5() { grade = WrestlingLanguage.Grade.G5;	}
	public void setGrade6() { grade = WrestlingLanguage.Grade.G6;	}
	public void setGrade7() { grade = WrestlingLanguage.Grade.G7;	}
	public void setGrade8() { grade = WrestlingLanguage.Grade.G8;	}
	public void setGrade(WrestlingLanguage.Grade g ) { grade=g; }
	
	public void setGenderM() { gender = WrestlingLanguage.Gender.M;	}
	public void setGenderF() { gender = WrestlingLanguage.Gender.F;	}
	public void setGender(WrestlingLanguage.Gender g ) { gender = g; }
	
	public void setTrackRecord(String rec) {
		trackRecord = rec;
	}
	public void setTrackWtClass(String w ) {
		trackWtClass = w;
	}
	public String toString() {
		return "Wrestler:" + teamName + ":" + name  ;
	}
	private void addToSummary(Bout b) {
	   if ( b.isAWin() ) {
          addWin();	
          switch ( b.getMatchResultType() ) {
			  case FFT: 
			    addWinByFFT();
				break;
			  case FALL:
			    addWinByFall();
				break;
			  case TECH:
			    addWinByTech();
				break;
			  case MD:
			    addWinByMD();
			    break;
			  case DEC:
			    addWinByDec();
				break;
			  case INJ:
			    break;
			  case DQ:
			    break;
		  }
       } else {
          addLoss();
          switch ( b.getMatchResultType() ) {

          case FFT:
			  addLossByFFT();
			    break;
			  case FALL:
			    addLossByFall();
				break;
			  case TECH:
			    addLossByTech();
				break;
			  case MD:
			    addLossByMD();
			    break;
			  case DEC:
			    addLossByDec();
				break;
			  case INJ:
			    if ( lossByInjury) {
			    	lossByInjuryString += ";";
			    } else {
			    	lossByInjury=true;
			    	lossByInjuryString= "Loss by Injury on ";
			    }
			    if ( b.getMatchDate() != null ) {
			    	lossByInjuryString += b.getMatchDate();
			    	lossByInjuryString += " ";
			    }
			    lossByInjuryString += " vs ";
			    lossByInjuryString += b.getOpponentTeam();
			    
			    break;
			  case DQ:
			    break;
		  }		  
       }		  
	}
	public void addWin() { wins++; }
	public void addLoss() { losses++; }
	public void addWinByFFT() { winByFFT++; }
	public void addWinByFall() { winByFall++; }
	public void addWinByTech() { winByTech++; }
	public void addWinByMD() { winByMD++; }
	public void addWinByDec() { winByDec++; }
	
	public void addLossByFFT() { lossByFFT++; }
	public void addLossByFall() { lossByFall++; }
	public void addLossByTech() { lossByTech++; }
	public void addLossByMD() { lossByMD++; }
	public void addLossByDec() { lossByDec++; }

	public boolean equals(Object o) {
	  if ( o == null ) { return false; }
	  if ( this == o ) { return true; }
	  if ( this.getClass() == o.getClass() ){
         Wrestler ow = (Wrestler) o;		  
	     if ( this.getName().equals(ow.getName()) && this.getTeamName().equals(ow.getTeamName())) {
			 return true;
	     }
	  }
	  return false; 
	}
	public int hashCode() {
		return getName().hashCode() + getTeamName().hashCode();
	}


public String getFinWeight() {
	String finWeight = "";
	boolean a = playedMatch();
	
	if(cert != null) {
		finWeight = cert;
	}
	else (this.cert == null&&this.playedMatch()== true){
		finWeight = getLowestWeightWrestled();
	}
	
	return finWeight;
}

public boolean playedMatch() {
	if (matchWeight == null) {
		return false;
}	
	return true;
}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:254)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-13 22:32:44.318
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:254)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-13 22:32:44.318
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:254)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-13 22:32:44.456
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package JuniorHigh;

import java.util.*;
import java.util.Enumeration;

/*
 *
 *  This is a class to holds an wrestler and all data pertaining to him/her.
 */
class Wrestler {
	private String name;
	private String seed;
	private String cert;
	private String teamName;
	private WrestlingLanguage.Grade grade;
	private WrestlingLanguage.Gender gender;
	private String trackRecord;
	private String trackWtClass;
	private boolean rosteredLastYear;
	private String trackLastYearWtClass;
	private String trackLastYearRecord;
	private WrestlingLanguage.Prestige prestigeLastYear;
	private WrestlingLanguage.Prestige prestige2YearsAgo;
	private WrestlingLanguage.Prestige prestige3YearsAgo;
	
	private Hashtable<String,Integer> matchesAtWeight=new Hashtable<String,Integer>();
	
	private int wins;
	private int losses;
	private boolean lossByInjury=false;
	private String lossByInjuryString;
	private int winByFFT;
	private int lossByFFT;

	private int winByFall;
	private int winByDec;
	private int winByMD;
	private int winByTech;
	
	private int lossByFall;
	private int lossByDec;
	private int lossByMD;
	private int lossByTech;
	
	private int weight;
	
	private Hashtable<Integer,Integer> matchWeight=new Hashtable<Integer,Integer>();

		
	private WeighInHistory wiHistory;
	
	/* These 2 attributes are used to force where we put the wrestler in the reporting
	 * order.
	 */
	private String forceWeight=null;  /* for reporting force the use of this weight class. */
	private Integer forceRank=null;  /* for reporting this is the rank order withing the weight class. */

	public void setLossByInjuryString(String s) {
		lossByInjuryString = s;
	}
	public String getLossByInjuryString() { return lossByInjuryString; }
	
	public String getLowestWeightWrestled() {
		int lowInt=99999;
		
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
			int i =  Integer.parseInt(key);
		    if (i < lowInt ) {
		    	lowInt = i;
		    }
		}
		return Integer.toString(lowInt);
	}
	public String getPrintWeight() {
		if ( forceWeight != null ) {
			if ( forceWeight.length() > 0 ) {
				return forceWeight;
			}
		}
		return getLowestWeightWrestled();
	}
	public int getPrintRank() {
		if (forceRank == null ) {
			return getWins() + getLosses();
		} else {
			return 100000 - forceRank.intValue();
		}
	}
	public String getForceWeight() { return forceWeight; }
	public Integer getForceRank() { return forceRank; }
	
	public void setWeight( int w ) { 
		if (matchWeight.containsKey(w)) {
			int val =matchWeight.get(w);
			matchWeight.put(w, val+1);
			
		}
		else {
		matchWeight.put(w, 1);	
		}
		
	}
	public String getWeight() {
		Enumeration<Integer> e = matchWeight.keys();
		String WeightString="";
		while (e.hasMoreElements()) {
			 
	            // Getting the key of a particular entry
	            int keyWeight = e.nextElement();
	            int valueCount = matchWeight.get(keyWeight);
	            
	            WeightString += Integer.toString(valueCount) + "@" + Integer.toString(keyWeight) + " - ";
	             
	          
	        }
		return WeightString;
		
	}


	
	public void setForceWeight( String w ) { forceWeight = w; }
	public void setForceRank ( Integer i ) { forceRank = i; }
	
	List<Bout> bouts = new ArrayList<Bout> ();

	public List<Bout> getBouts() { return bouts; }
	
	public boolean getLossByInjury() { return lossByInjury; }
	
	public WeighInHistory getWeighInHistory() { return wiHistory; }
	
	public void setWeighInHistory(WeighInHistory wih ) { wiHistory = wih; }

	public void setPrestigeLastYear(WrestlingLanguage.Prestige p) { prestigeLastYear = p; }
	public void setPrestige2YearsAgo(WrestlingLanguage.Prestige p) { prestige2YearsAgo= p; }
	public void setPrestige3YearsAgo(WrestlingLanguage.Prestige p) { prestige3YearsAgo = p; }

	public WrestlingLanguage.Prestige getPrestigeLastYear() { return prestigeLastYear; }
	public WrestlingLanguage.Prestige getPrestige2YearsAgo() { return prestige2YearsAgo; }
	public WrestlingLanguage.Prestige getPrestige3YearsAgo() { return prestige3YearsAgo; }

    public void printVerbose () {
		System.out.println( getName() + 
			" Grade<" + getGrade() + ">" + 
			" Seed<" + getSeed() + ">" +
			" Cert<" + getCert() + ">"); 
			//" Gender<" + getGender() + "> Wt<" + 
			//getTrackWtClass() + ">" + " (" + getWins() + "W-" + 
			//getLosses() + "L) Last Year=<" + rosteredLastYear + "> Last Year Record <" + trackLastYearRecord + ">" );
    }	   
	public String getRecordString() { 
		return String.valueOf(wins) + "-" + String.valueOf(losses); 
	}
	public String getRecordBreakdown() {
		String breakdownString = "";
		boolean addedWins=false;
		if ( getWins() > 0 ) {
			breakdownString += getWins() + "W[";
			if ( getWinByFall() > 0 ) {
				breakdownString += getWinByFall() + " Pin,";
				addedWins=true;
			}
			if ( getWinByTech() > 0 ) {
				breakdownString += getWinByTech() + " TF,";
				addedWins=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getWinByMD() + " MD,";
				addedWins=true;
			}
			if ( getWinByDec() > 0 ) {
				breakdownString += getWinByDec() + " Dec,";
				addedWins=true;
			}
			if ( getWinByFFT() > 0 ) {
				breakdownString += getWinByFFT() + " FFT,";
				addedWins=true;
			}
			if ( addedWins ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "0 W";
		}
		boolean addedLosses=false;
		if ( getLosses() > 0 ) {
			breakdownString += "-" + getLosses() + "L[";
			if ( getLossByFall() > 0 ) {
				breakdownString += getLossByFall() + " Pin,";
				addedLosses=true;
			}
			if ( getLossByTech() > 0 ) {
				breakdownString += getLossByTech() + " TF,";
				addedLosses=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getLossByMD() + " MD,";
				addedLosses=true;
			}
			if ( getLossByDec() > 0 ) {
				breakdownString += getLossByDec() + " Dec,";
				addedLosses=true;
			}
			
			if ( addedLosses ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "-0L";
		}
		if ( getWins() ==0 && getLosses() == 0 ) {
			return "";
		} else {
			return breakdownString +" - "+ getWeight();
		}
	}
	public String getName() { return name; }
	public String getSeed() { return seed; }
	public String getCert() { return cert; }
	public String getTeamName() { return teamName; }
	public WrestlingLanguage.Grade getGrade() { return grade; }
	public WrestlingLanguage.Gender getGender() { return gender; }
	public String getTrackRecord() { return trackRecord; }
	public String getTrackWtClass() { return trackWtClass; }
	
	public int getWins() { return wins; }
	public int getLosses() { return losses; }
	
	public int getWinByFFT() { return winByFFT; }
	public int getWinByFall() { return winByFall; }
	public int getWinByTech() { return winByTech; }
	public int getWinByMD() { return winByMD; }
	public int getWinByDec() { return winByDec; }
	
	public int getLossByFFT() { return lossByFFT; }
	public int getLossByFall() { return lossByFall; }
	public int getLossByTech() { return lossByTech; }
	public int getLossByMD() { return lossByMD; }
	public int getLossByDec() { return lossByDec; }
	
    public Wrestler(String n, String team){
		setName(n);
		setTeamName(team);
		return;
	}
	public boolean getRosteredLastYear() { return rosteredLastYear; }
	
	public void setRosteredLastYearOn() { rosteredLastYear = true; }
	public void setRosteredLastYearOff() { rosteredLastYear = false; }
	
	public String getTrackLastYearWtClass() { return trackLastYearWtClass; }
	public String getTrackLastYearRecord() { return trackLastYearRecord; }
	
	public void setTrackLastYearWtClass(String w) { 
		trackLastYearWtClass = w; 
	}
	public void setTrackLastYearRecord(String r) {
		trackLastYearRecord = r;
	}
	
	
	public void addBout(Bout b) {
		String cmd=b.getMatchDate();
		if (cmd == null ) {
			Event e = b.getEvent();
			if ( e != null ) {
				String sss = e.getEventTitle();
				if ( wiHistory != null ) {
					String s = wiHistory.findWeighInDate(sss);
					if ( s != null ) { 
						b.setMatchDate(s);
					}
				}
			}
		}	
		
		bouts.add(b);
		addToSummary(b);
		addToMatchesAtWeight(b);
	}
	private void addToMatchesAtWeight(Bout b) {
		String w=b.getWeight();
		Integer ct = matchesAtWeight.get(w);
		if ( ct != null ) {
			ct++;
			matchesAtWeight.replace(w,ct);
		} else {
			matchesAtWeight.put(w,1);
		}
		return;
	}
	public String getMatchesAtWeightString() {

		String byWt="";
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
	
			int ct = matchesAtWeight.get(key);
			if ( byWt.length() > 0 ) { byWt=byWt + ";" ; }
			byWt=byWt + ct + "@" + key;
		}
		return byWt;
	}
	
	public void setName( String n ) {
		name = n.strip();
	}
	public void setSeed( String n ) {
		seed = n.strip();
	}
	public void setCert( String n ) {
		cert = n.strip();
	}
	public void setTeamName( String team ) {
		teamName = team;
	}
	public void setGrade5() { grade = WrestlingLanguage.Grade.G5;	}
	public void setGrade6() { grade = WrestlingLanguage.Grade.G6;	}
	public void setGrade7() { grade = WrestlingLanguage.Grade.G7;	}
	public void setGrade8() { grade = WrestlingLanguage.Grade.G8;	}
	public void setGrade(WrestlingLanguage.Grade g ) { grade=g; }
	
	public void setGenderM() { gender = WrestlingLanguage.Gender.M;	}
	public void setGenderF() { gender = WrestlingLanguage.Gender.F;	}
	public void setGender(WrestlingLanguage.Gender g ) { gender = g; }
	
	public void setTrackRecord(String rec) {
		trackRecord = rec;
	}
	public void setTrackWtClass(String w ) {
		trackWtClass = w;
	}
	public String toString() {
		return "Wrestler:" + teamName + ":" + name  ;
	}
	private void addToSummary(Bout b) {
	   if ( b.isAWin() ) {
          addWin();	
          switch ( b.getMatchResultType() ) {
			  case FFT: 
			    addWinByFFT();
				break;
			  case FALL:
			    addWinByFall();
				break;
			  case TECH:
			    addWinByTech();
				break;
			  case MD:
			    addWinByMD();
			    break;
			  case DEC:
			    addWinByDec();
				break;
			  case INJ:
			    break;
			  case DQ:
			    break;
		  }
       } else {
          addLoss();
          switch ( b.getMatchResultType() ) {

          case FFT:
			  addLossByFFT();
			    break;
			  case FALL:
			    addLossByFall();
				break;
			  case TECH:
			    addLossByTech();
				break;
			  case MD:
			    addLossByMD();
			    break;
			  case DEC:
			    addLossByDec();
				break;
			  case INJ:
			    if ( lossByInjury) {
			    	lossByInjuryString += ";";
			    } else {
			    	lossByInjury=true;
			    	lossByInjuryString= "Loss by Injury on ";
			    }
			    if ( b.getMatchDate() != null ) {
			    	lossByInjuryString += b.getMatchDate();
			    	lossByInjuryString += " ";
			    }
			    lossByInjuryString += " vs ";
			    lossByInjuryString += b.getOpponentTeam();
			    
			    break;
			  case DQ:
			    break;
		  }		  
       }		  
	}
	public void addWin() { wins++; }
	public void addLoss() { losses++; }
	public void addWinByFFT() { winByFFT++; }
	public void addWinByFall() { winByFall++; }
	public void addWinByTech() { winByTech++; }
	public void addWinByMD() { winByMD++; }
	public void addWinByDec() { winByDec++; }
	
	public void addLossByFFT() { lossByFFT++; }
	public void addLossByFall() { lossByFall++; }
	public void addLossByTech() { lossByTech++; }
	public void addLossByMD() { lossByMD++; }
	public void addLossByDec() { lossByDec++; }

	public boolean equals(Object o) {
	  if ( o == null ) { return false; }
	  if ( this == o ) { return true; }
	  if ( this.getClass() == o.getClass() ){
         Wrestler ow = (Wrestler) o;		  
	     if ( this.getName().equals(ow.getName()) && this.getTeamName().equals(ow.getTeamName())) {
			 return true;
	     }
	  }
	  return false; 
	}
	public int hashCode() {
		return getName().hashCode() + getTeamName().hashCode();
	}


public String getFinWeight() {
	String finWeight = "";
	boolean a = playedMatch();
	
	if(cert != null) {
		finWeight = cert;
	}
	else (this.cert == null&&this.playedMatch()== true){
		finWeight = getLowestWeightWrestled();
	}
	
	return finWeight;
}

public boolean playedMatch() {
	if (matchWeight == null) {
		return false;
}	
	return true;
}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:254)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-13 22:32:44.457
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:254)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-13 22:32:44.458
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:254)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-13 22:32:47.511
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package JuniorHigh;

import java.util.*;
import java.util.Enumeration;

/*
 *
 *  This is a class to holds an wrestler and all data pertaining to him/her.
 */
class Wrestler {
	private String name;
	private String seed;
	private String cert;
	private String teamName;
	private WrestlingLanguage.Grade grade;
	private WrestlingLanguage.Gender gender;
	private String trackRecord;
	private String trackWtClass;
	private boolean rosteredLastYear;
	private String trackLastYearWtClass;
	private String trackLastYearRecord;
	private WrestlingLanguage.Prestige prestigeLastYear;
	private WrestlingLanguage.Prestige prestige2YearsAgo;
	private WrestlingLanguage.Prestige prestige3YearsAgo;
	
	private Hashtable<String,Integer> matchesAtWeight=new Hashtable<String,Integer>();
	
	private int wins;
	private int losses;
	private boolean lossByInjury=false;
	private String lossByInjuryString;
	private int winByFFT;
	private int lossByFFT;

	private int winByFall;
	private int winByDec;
	private int winByMD;
	private int winByTech;
	
	private int lossByFall;
	private int lossByDec;
	private int lossByMD;
	private int lossByTech;
	
	private int weight;
	
	private Hashtable<Integer,Integer> matchWeight=new Hashtable<Integer,Integer>();

		
	private WeighInHistory wiHistory;
	
	/* These 2 attributes are used to force where we put the wrestler in the reporting
	 * order.
	 */
	private String forceWeight=null;  /* for reporting force the use of this weight class. */
	private Integer forceRank=null;  /* for reporting this is the rank order withing the weight class. */

	public void setLossByInjuryString(String s) {
		lossByInjuryString = s;
	}
	public String getLossByInjuryString() { return lossByInjuryString; }
	
	public String getLowestWeightWrestled() {
		int lowInt=99999;
		
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
			int i =  Integer.parseInt(key);
		    if (i < lowInt ) {
		    	lowInt = i;
		    }
		}
		return Integer.toString(lowInt);
	}
	public String getPrintWeight() {
		if ( forceWeight != null ) {
			if ( forceWeight.length() > 0 ) {
				return forceWeight;
			}
		}
		return getLowestWeightWrestled();
	}
	public int getPrintRank() {
		if (forceRank == null ) {
			return getWins() + getLosses();
		} else {
			return 100000 - forceRank.intValue();
		}
	}
	public String getForceWeight() { return forceWeight; }
	public Integer getForceRank() { return forceRank; }
	
	public void setWeight( int w ) { 
		if (matchWeight.containsKey(w)) {
			int val =matchWeight.get(w);
			matchWeight.put(w, val+1);
			
		}
		else {
		matchWeight.put(w, 1);	
		}
		
	}
	public String getWeight() {
		Enumeration<Integer> e = matchWeight.keys();
		String WeightString="";
		while (e.hasMoreElements()) {
			 
	            // Getting the key of a particular entry
	            int keyWeight = e.nextElement();
	            int valueCount = matchWeight.get(keyWeight);
	            
	            WeightString += Integer.toString(valueCount) + "@" + Integer.toString(keyWeight) + " - ";
	             
	          
	        }
		return WeightString;
		
	}


	
	public void setForceWeight( String w ) { forceWeight = w; }
	public void setForceRank ( Integer i ) { forceRank = i; }
	
	List<Bout> bouts = new ArrayList<Bout> ();

	public List<Bout> getBouts() { return bouts; }
	
	public boolean getLossByInjury() { return lossByInjury; }
	
	public WeighInHistory getWeighInHistory() { return wiHistory; }
	
	public void setWeighInHistory(WeighInHistory wih ) { wiHistory = wih; }

	public void setPrestigeLastYear(WrestlingLanguage.Prestige p) { prestigeLastYear = p; }
	public void setPrestige2YearsAgo(WrestlingLanguage.Prestige p) { prestige2YearsAgo= p; }
	public void setPrestige3YearsAgo(WrestlingLanguage.Prestige p) { prestige3YearsAgo = p; }

	public WrestlingLanguage.Prestige getPrestigeLastYear() { return prestigeLastYear; }
	public WrestlingLanguage.Prestige getPrestige2YearsAgo() { return prestige2YearsAgo; }
	public WrestlingLanguage.Prestige getPrestige3YearsAgo() { return prestige3YearsAgo; }

    public void printVerbose () {
		System.out.println( getName() + 
			" Grade<" + getGrade() + ">" + 
			" Seed<" + getSeed() + ">" +
			" Cert<" + getCert() + ">"); 
			//" Gender<" + getGender() + "> Wt<" + 
			//getTrackWtClass() + ">" + " (" + getWins() + "W-" + 
			//getLosses() + "L) Last Year=<" + rosteredLastYear + "> Last Year Record <" + trackLastYearRecord + ">" );
    }	   
	public String getRecordString() { 
		return String.valueOf(wins) + "-" + String.valueOf(losses); 
	}
	public String getRecordBreakdown() {
		String breakdownString = "";
		boolean addedWins=false;
		if ( getWins() > 0 ) {
			breakdownString += getWins() + "W[";
			if ( getWinByFall() > 0 ) {
				breakdownString += getWinByFall() + " Pin,";
				addedWins=true;
			}
			if ( getWinByTech() > 0 ) {
				breakdownString += getWinByTech() + " TF,";
				addedWins=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getWinByMD() + " MD,";
				addedWins=true;
			}
			if ( getWinByDec() > 0 ) {
				breakdownString += getWinByDec() + " Dec,";
				addedWins=true;
			}
			if ( getWinByFFT() > 0 ) {
				breakdownString += getWinByFFT() + " FFT,";
				addedWins=true;
			}
			if ( addedWins ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "0 W";
		}
		boolean addedLosses=false;
		if ( getLosses() > 0 ) {
			breakdownString += "-" + getLosses() + "L[";
			if ( getLossByFall() > 0 ) {
				breakdownString += getLossByFall() + " Pin,";
				addedLosses=true;
			}
			if ( getLossByTech() > 0 ) {
				breakdownString += getLossByTech() + " TF,";
				addedLosses=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getLossByMD() + " MD,";
				addedLosses=true;
			}
			if ( getLossByDec() > 0 ) {
				breakdownString += getLossByDec() + " Dec,";
				addedLosses=true;
			}
			
			if ( addedLosses ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "-0L";
		}
		if ( getWins() ==0 && getLosses() == 0 ) {
			return "";
		} else {
			return breakdownString +" - "+ getWeight();
		}
	}
	public String getName() { return name; }
	public String getSeed() { return seed; }
	public String getCert() { return cert; }
	public String getTeamName() { return teamName; }
	public WrestlingLanguage.Grade getGrade() { return grade; }
	public WrestlingLanguage.Gender getGender() { return gender; }
	public String getTrackRecord() { return trackRecord; }
	public String getTrackWtClass() { return trackWtClass; }
	
	public int getWins() { return wins; }
	public int getLosses() { return losses; }
	
	public int getWinByFFT() { return winByFFT; }
	public int getWinByFall() { return winByFall; }
	public int getWinByTech() { return winByTech; }
	public int getWinByMD() { return winByMD; }
	public int getWinByDec() { return winByDec; }
	
	public int getLossByFFT() { return lossByFFT; }
	public int getLossByFall() { return lossByFall; }
	public int getLossByTech() { return lossByTech; }
	public int getLossByMD() { return lossByMD; }
	public int getLossByDec() { return lossByDec; }
	
    public Wrestler(String n, String team){
		setName(n);
		setTeamName(team);
		return;
	}
	public boolean getRosteredLastYear() { return rosteredLastYear; }
	
	public void setRosteredLastYearOn() { rosteredLastYear = true; }
	public void setRosteredLastYearOff() { rosteredLastYear = false; }
	
	public String getTrackLastYearWtClass() { return trackLastYearWtClass; }
	public String getTrackLastYearRecord() { return trackLastYearRecord; }
	
	public void setTrackLastYearWtClass(String w) { 
		trackLastYearWtClass = w; 
	}
	public void setTrackLastYearRecord(String r) {
		trackLastYearRecord = r;
	}
	
	
	public void addBout(Bout b) {
		String cmd=b.getMatchDate();
		if (cmd == null ) {
			Event e = b.getEvent();
			if ( e != null ) {
				String sss = e.getEventTitle();
				if ( wiHistory != null ) {
					String s = wiHistory.findWeighInDate(sss);
					if ( s != null ) { 
						b.setMatchDate(s);
					}
				}
			}
		}	
		
		bouts.add(b);
		addToSummary(b);
		addToMatchesAtWeight(b);
	}
	private void addToMatchesAtWeight(Bout b) {
		String w=b.getWeight();
		Integer ct = matchesAtWeight.get(w);
		if ( ct != null ) {
			ct++;
			matchesAtWeight.replace(w,ct);
		} else {
			matchesAtWeight.put(w,1);
		}
		return;
	}
	public String getMatchesAtWeightString() {

		String byWt="";
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
	
			int ct = matchesAtWeight.get(key);
			if ( byWt.length() > 0 ) { byWt=byWt + ";" ; }
			byWt=byWt + ct + "@" + key;
		}
		return byWt;
	}
	
	public void setName( String n ) {
		name = n.strip();
	}
	public void setSeed( String n ) {
		seed = n.strip();
	}
	public void setCert( String n ) {
		cert = n.strip();
	}
	public void setTeamName( String team ) {
		teamName = team;
	}
	public void setGrade5() { grade = WrestlingLanguage.Grade.G5;	}
	public void setGrade6() { grade = WrestlingLanguage.Grade.G6;	}
	public void setGrade7() { grade = WrestlingLanguage.Grade.G7;	}
	public void setGrade8() { grade = WrestlingLanguage.Grade.G8;	}
	public void setGrade(WrestlingLanguage.Grade g ) { grade=g; }
	
	public void setGenderM() { gender = WrestlingLanguage.Gender.M;	}
	public void setGenderF() { gender = WrestlingLanguage.Gender.F;	}
	public void setGender(WrestlingLanguage.Gender g ) { gender = g; }
	
	public void setTrackRecord(String rec) {
		trackRecord = rec;
	}
	public void setTrackWtClass(String w ) {
		trackWtClass = w;
	}
	public String toString() {
		return "Wrestler:" + teamName + ":" + name  ;
	}
	private void addToSummary(Bout b) {
	   if ( b.isAWin() ) {
          addWin();	
          switch ( b.getMatchResultType() ) {
			  case FFT: 
			    addWinByFFT();
				break;
			  case FALL:
			    addWinByFall();
				break;
			  case TECH:
			    addWinByTech();
				break;
			  case MD:
			    addWinByMD();
			    break;
			  case DEC:
			    addWinByDec();
				break;
			  case INJ:
			    break;
			  case DQ:
			    break;
		  }
       } else {
          addLoss();
          switch ( b.getMatchResultType() ) {

          case FFT:
			  addLossByFFT();
			    break;
			  case FALL:
			    addLossByFall();
				break;
			  case TECH:
			    addLossByTech();
				break;
			  case MD:
			    addLossByMD();
			    break;
			  case DEC:
			    addLossByDec();
				break;
			  case INJ:
			    if ( lossByInjury) {
			    	lossByInjuryString += ";";
			    } else {
			    	lossByInjury=true;
			    	lossByInjuryString= "Loss by Injury on ";
			    }
			    if ( b.getMatchDate() != null ) {
			    	lossByInjuryString += b.getMatchDate();
			    	lossByInjuryString += " ";
			    }
			    lossByInjuryString += " vs ";
			    lossByInjuryString += b.getOpponentTeam();
			    
			    break;
			  case DQ:
			    break;
		  }		  
       }		  
	}
	public void addWin() { wins++; }
	public void addLoss() { losses++; }
	public void addWinByFFT() { winByFFT++; }
	public void addWinByFall() { winByFall++; }
	public void addWinByTech() { winByTech++; }
	public void addWinByMD() { winByMD++; }
	public void addWinByDec() { winByDec++; }
	
	public void addLossByFFT() { lossByFFT++; }
	public void addLossByFall() { lossByFall++; }
	public void addLossByTech() { lossByTech++; }
	public void addLossByMD() { lossByMD++; }
	public void addLossByDec() { lossByDec++; }

	public boolean equals(Object o) {
	  if ( o == null ) { return false; }
	  if ( this == o ) { return true; }
	  if ( this.getClass() == o.getClass() ){
         Wrestler ow = (Wrestler) o;		  
	     if ( this.getName().equals(ow.getName()) && this.getTeamName().equals(ow.getTeamName())) {
			 return true;
	     }
	  }
	  return false; 
	}
	public int hashCode() {
		return getName().hashCode() + getTeamName().hashCode();
	}


public String getFinWeight() {
	String finWeight = "";
	boolean a = playedMatch();
	
	if(cert != null) {
		finWeight = cert;
	}
	else (this.cert == null&&this.playedMatch()== true){
		finWeight = getLowestWeightWrestled();
	}
	
	return finWeight;
}

public boolean playedMatch() {
	if (matchWeight == null) {
		return false;
}	
	return true;
}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4320)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3943)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:577)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-13 22:32:47.512
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4320)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3943)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:577)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-13 22:32:47.512
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4320)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3943)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:577)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-13 22:32:47.525
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package JuniorHigh;

import java.util.*;
import java.util.Enumeration;

/*
 *
 *  This is a class to holds an wrestler and all data pertaining to him/her.
 */
class Wrestler {
	private String name;
	private String seed;
	private String cert;
	private String teamName;
	private WrestlingLanguage.Grade grade;
	private WrestlingLanguage.Gender gender;
	private String trackRecord;
	private String trackWtClass;
	private boolean rosteredLastYear;
	private String trackLastYearWtClass;
	private String trackLastYearRecord;
	private WrestlingLanguage.Prestige prestigeLastYear;
	private WrestlingLanguage.Prestige prestige2YearsAgo;
	private WrestlingLanguage.Prestige prestige3YearsAgo;
	
	private Hashtable<String,Integer> matchesAtWeight=new Hashtable<String,Integer>();
	
	private int wins;
	private int losses;
	private boolean lossByInjury=false;
	private String lossByInjuryString;
	private int winByFFT;
	private int lossByFFT;

	private int winByFall;
	private int winByDec;
	private int winByMD;
	private int winByTech;
	
	private int lossByFall;
	private int lossByDec;
	private int lossByMD;
	private int lossByTech;
	
	private int weight;
	
	private Hashtable<Integer,Integer> matchWeight=new Hashtable<Integer,Integer>();

		
	private WeighInHistory wiHistory;
	
	/* These 2 attributes are used to force where we put the wrestler in the reporting
	 * order.
	 */
	private String forceWeight=null;  /* for reporting force the use of this weight class. */
	private Integer forceRank=null;  /* for reporting this is the rank order withing the weight class. */

	public void setLossByInjuryString(String s) {
		lossByInjuryString = s;
	}
	public String getLossByInjuryString() { return lossByInjuryString; }
	
	public String getLowestWeightWrestled() {
		int lowInt=99999;
		
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
			int i =  Integer.parseInt(key);
		    if (i < lowInt ) {
		    	lowInt = i;
		    }
		}
		return Integer.toString(lowInt);
	}
	public String getPrintWeight() {
		if ( forceWeight != null ) {
			if ( forceWeight.length() > 0 ) {
				return forceWeight;
			}
		}
		return getLowestWeightWrestled();
	}
	public int getPrintRank() {
		if (forceRank == null ) {
			return getWins() + getLosses();
		} else {
			return 100000 - forceRank.intValue();
		}
	}
	public String getForceWeight() { return forceWeight; }
	public Integer getForceRank() { return forceRank; }
	
	public void setWeight( int w ) { 
		if (matchWeight.containsKey(w)) {
			int val =matchWeight.get(w);
			matchWeight.put(w, val+1);
			
		}
		else {
		matchWeight.put(w, 1);	
		}
		
	}
	public String getWeight() {
		Enumeration<Integer> e = matchWeight.keys();
		String WeightString="";
		while (e.hasMoreElements()) {
			 
	            // Getting the key of a particular entry
	            int keyWeight = e.nextElement();
	            int valueCount = matchWeight.get(keyWeight);
	            
	            WeightString += Integer.toString(valueCount) + "@" + Integer.toString(keyWeight) + " - ";
	             
	          
	        }
		return WeightString;
		
	}


	
	public void setForceWeight( String w ) { forceWeight = w; }
	public void setForceRank ( Integer i ) { forceRank = i; }
	
	List<Bout> bouts = new ArrayList<Bout> ();

	public List<Bout> getBouts() { return bouts; }
	
	public boolean getLossByInjury() { return lossByInjury; }
	
	public WeighInHistory getWeighInHistory() { return wiHistory; }
	
	public void setWeighInHistory(WeighInHistory wih ) { wiHistory = wih; }

	public void setPrestigeLastYear(WrestlingLanguage.Prestige p) { prestigeLastYear = p; }
	public void setPrestige2YearsAgo(WrestlingLanguage.Prestige p) { prestige2YearsAgo= p; }
	public void setPrestige3YearsAgo(WrestlingLanguage.Prestige p) { prestige3YearsAgo = p; }

	public WrestlingLanguage.Prestige getPrestigeLastYear() { return prestigeLastYear; }
	public WrestlingLanguage.Prestige getPrestige2YearsAgo() { return prestige2YearsAgo; }
	public WrestlingLanguage.Prestige getPrestige3YearsAgo() { return prestige3YearsAgo; }

    public void printVerbose () {
		System.out.println( getName() + 
			" Grade<" + getGrade() + ">" + 
			" Seed<" + getSeed() + ">" +
			" Cert<" + getCert() + ">"); 
			//" Gender<" + getGender() + "> Wt<" + 
			//getTrackWtClass() + ">" + " (" + getWins() + "W-" + 
			//getLosses() + "L) Last Year=<" + rosteredLastYear + "> Last Year Record <" + trackLastYearRecord + ">" );
    }	   
	public String getRecordString() { 
		return String.valueOf(wins) + "-" + String.valueOf(losses); 
	}
	public String getRecordBreakdown() {
		String breakdownString = "";
		boolean addedWins=false;
		if ( getWins() > 0 ) {
			breakdownString += getWins() + "W[";
			if ( getWinByFall() > 0 ) {
				breakdownString += getWinByFall() + " Pin,";
				addedWins=true;
			}
			if ( getWinByTech() > 0 ) {
				breakdownString += getWinByTech() + " TF,";
				addedWins=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getWinByMD() + " MD,";
				addedWins=true;
			}
			if ( getWinByDec() > 0 ) {
				breakdownString += getWinByDec() + " Dec,";
				addedWins=true;
			}
			if ( getWinByFFT() > 0 ) {
				breakdownString += getWinByFFT() + " FFT,";
				addedWins=true;
			}
			if ( addedWins ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "0 W";
		}
		boolean addedLosses=false;
		if ( getLosses() > 0 ) {
			breakdownString += "-" + getLosses() + "L[";
			if ( getLossByFall() > 0 ) {
				breakdownString += getLossByFall() + " Pin,";
				addedLosses=true;
			}
			if ( getLossByTech() > 0 ) {
				breakdownString += getLossByTech() + " TF,";
				addedLosses=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getLossByMD() + " MD,";
				addedLosses=true;
			}
			if ( getLossByDec() > 0 ) {
				breakdownString += getLossByDec() + " Dec,";
				addedLosses=true;
			}
			
			if ( addedLosses ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "-0L";
		}
		if ( getWins() ==0 && getLosses() == 0 ) {
			return "";
		} else {
			return breakdownString +" - "+ getWeight();
		}
	}
	public String getName() { return name; }
	public String getSeed() { return seed; }
	public String getCert() { return cert; }
	public String getTeamName() { return teamName; }
	public WrestlingLanguage.Grade getGrade() { return grade; }
	public WrestlingLanguage.Gender getGender() { return gender; }
	public String getTrackRecord() { return trackRecord; }
	public String getTrackWtClass() { return trackWtClass; }
	
	public int getWins() { return wins; }
	public int getLosses() { return losses; }
	
	public int getWinByFFT() { return winByFFT; }
	public int getWinByFall() { return winByFall; }
	public int getWinByTech() { return winByTech; }
	public int getWinByMD() { return winByMD; }
	public int getWinByDec() { return winByDec; }
	
	public int getLossByFFT() { return lossByFFT; }
	public int getLossByFall() { return lossByFall; }
	public int getLossByTech() { return lossByTech; }
	public int getLossByMD() { return lossByMD; }
	public int getLossByDec() { return lossByDec; }
	
    public Wrestler(String n, String team){
		setName(n);
		setTeamName(team);
		return;
	}
	public boolean getRosteredLastYear() { return rosteredLastYear; }
	
	public void setRosteredLastYearOn() { rosteredLastYear = true; }
	public void setRosteredLastYearOff() { rosteredLastYear = false; }
	
	public String getTrackLastYearWtClass() { return trackLastYearWtClass; }
	public String getTrackLastYearRecord() { return trackLastYearRecord; }
	
	public void setTrackLastYearWtClass(String w) { 
		trackLastYearWtClass = w; 
	}
	public void setTrackLastYearRecord(String r) {
		trackLastYearRecord = r;
	}
	
	
	public void addBout(Bout b) {
		String cmd=b.getMatchDate();
		if (cmd == null ) {
			Event e = b.getEvent();
			if ( e != null ) {
				String sss = e.getEventTitle();
				if ( wiHistory != null ) {
					String s = wiHistory.findWeighInDate(sss);
					if ( s != null ) { 
						b.setMatchDate(s);
					}
				}
			}
		}	
		
		bouts.add(b);
		addToSummary(b);
		addToMatchesAtWeight(b);
	}
	private void addToMatchesAtWeight(Bout b) {
		String w=b.getWeight();
		Integer ct = matchesAtWeight.get(w);
		if ( ct != null ) {
			ct++;
			matchesAtWeight.replace(w,ct);
		} else {
			matchesAtWeight.put(w,1);
		}
		return;
	}
	public String getMatchesAtWeightString() {

		String byWt="";
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
	
			int ct = matchesAtWeight.get(key);
			if ( byWt.length() > 0 ) { byWt=byWt + ";" ; }
			byWt=byWt + ct + "@" + key;
		}
		return byWt;
	}
	
	public void setName( String n ) {
		name = n.strip();
	}
	public void setSeed( String n ) {
		seed = n.strip();
	}
	public void setCert( String n ) {
		cert = n.strip();
	}
	public void setTeamName( String team ) {
		teamName = team;
	}
	public void setGrade5() { grade = WrestlingLanguage.Grade.G5;	}
	public void setGrade6() { grade = WrestlingLanguage.Grade.G6;	}
	public void setGrade7() { grade = WrestlingLanguage.Grade.G7;	}
	public void setGrade8() { grade = WrestlingLanguage.Grade.G8;	}
	public void setGrade(WrestlingLanguage.Grade g ) { grade=g; }
	
	public void setGenderM() { gender = WrestlingLanguage.Gender.M;	}
	public void setGenderF() { gender = WrestlingLanguage.Gender.F;	}
	public void setGender(WrestlingLanguage.Gender g ) { gender = g; }
	
	public void setTrackRecord(String rec) {
		trackRecord = rec;
	}
	public void setTrackWtClass(String w ) {
		trackWtClass = w;
	}
	public String toString() {
		return "Wrestler:" + teamName + ":" + name  ;
	}
	private void addToSummary(Bout b) {
	   if ( b.isAWin() ) {
          addWin();	
          switch ( b.getMatchResultType() ) {
			  case FFT: 
			    addWinByFFT();
				break;
			  case FALL:
			    addWinByFall();
				break;
			  case TECH:
			    addWinByTech();
				break;
			  case MD:
			    addWinByMD();
			    break;
			  case DEC:
			    addWinByDec();
				break;
			  case INJ:
			    break;
			  case DQ:
			    break;
		  }
       } else {
          addLoss();
          switch ( b.getMatchResultType() ) {

          case FFT:
			  addLossByFFT();
			    break;
			  case FALL:
			    addLossByFall();
				break;
			  case TECH:
			    addLossByTech();
				break;
			  case MD:
			    addLossByMD();
			    break;
			  case DEC:
			    addLossByDec();
				break;
			  case INJ:
			    if ( lossByInjury) {
			    	lossByInjuryString += ";";
			    } else {
			    	lossByInjury=true;
			    	lossByInjuryString= "Loss by Injury on ";
			    }
			    if ( b.getMatchDate() != null ) {
			    	lossByInjuryString += b.getMatchDate();
			    	lossByInjuryString += " ";
			    }
			    lossByInjuryString += " vs ";
			    lossByInjuryString += b.getOpponentTeam();
			    
			    break;
			  case DQ:
			    break;
		  }		  
       }		  
	}
	public void addWin() { wins++; }
	public void addLoss() { losses++; }
	public void addWinByFFT() { winByFFT++; }
	public void addWinByFall() { winByFall++; }
	public void addWinByTech() { winByTech++; }
	public void addWinByMD() { winByMD++; }
	public void addWinByDec() { winByDec++; }
	
	public void addLossByFFT() { lossByFFT++; }
	public void addLossByFall() { lossByFall++; }
	public void addLossByTech() { lossByTech++; }
	public void addLossByMD() { lossByMD++; }
	public void addLossByDec() { lossByDec++; }

	public boolean equals(Object o) {
	  if ( o == null ) { return false; }
	  if ( this == o ) { return true; }
	  if ( this.getClass() == o.getClass() ){
         Wrestler ow = (Wrestler) o;		  
	     if ( this.getName().equals(ow.getName()) && this.getTeamName().equals(ow.getTeamName())) {
			 return true;
	     }
	  }
	  return false; 
	}
	public int hashCode() {
		return getName().hashCode() + getTeamName().hashCode();
	}


public String getFinWeight() {
	String finWeight = "";
	boolean a = playedMatch();
	
	if(cert != null) {
		finWeight = cert;
	}
	else (this.cert == null&&this.playedMatch()== true){
		finWeight = getLowestWeightWrestled();
	}
	
	return finWeight;
}

public boolean playedMatch() {
	if (matchWeight == null) {
		return false;
}	
	return true;
}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4320)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3943)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:577)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui 4 0 2022-10-13 22:32:47.525
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4320)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3943)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:577)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-13 22:32:47.929
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package JuniorHigh;

import java.util.*;
import java.util.Enumeration;

/*
 *
 *  This is a class to holds an wrestler and all data pertaining to him/her.
 */
class Wrestler {
	private String name;
	private String seed;
	private String cert;
	private String teamName;
	private WrestlingLanguage.Grade grade;
	private WrestlingLanguage.Gender gender;
	private String trackRecord;
	private String trackWtClass;
	private boolean rosteredLastYear;
	private String trackLastYearWtClass;
	private String trackLastYearRecord;
	private WrestlingLanguage.Prestige prestigeLastYear;
	private WrestlingLanguage.Prestige prestige2YearsAgo;
	private WrestlingLanguage.Prestige prestige3YearsAgo;
	
	private Hashtable<String,Integer> matchesAtWeight=new Hashtable<String,Integer>();
	
	private int wins;
	private int losses;
	private boolean lossByInjury=false;
	private String lossByInjuryString;
	private int winByFFT;
	private int lossByFFT;

	private int winByFall;
	private int winByDec;
	private int winByMD;
	private int winByTech;
	
	private int lossByFall;
	private int lossByDec;
	private int lossByMD;
	private int lossByTech;
	
	private int weight;
	
	private Hashtable<Integer,Integer> matchWeight=new Hashtable<Integer,Integer>();

		
	private WeighInHistory wiHistory;
	
	/* These 2 attributes are used to force where we put the wrestler in the reporting
	 * order.
	 */
	private String forceWeight=null;  /* for reporting force the use of this weight class. */
	private Integer forceRank=null;  /* for reporting this is the rank order withing the weight class. */

	public void setLossByInjuryString(String s) {
		lossByInjuryString = s;
	}
	public String getLossByInjuryString() { return lossByInjuryString; }
	
	public String getLowestWeightWrestled() {
		int lowInt=99999;
		
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
			int i =  Integer.parseInt(key);
		    if (i < lowInt ) {
		    	lowInt = i;
		    }
		}
		return Integer.toString(lowInt);
	}
	public String getPrintWeight() {
		if ( forceWeight != null ) {
			if ( forceWeight.length() > 0 ) {
				return forceWeight;
			}
		}
		return getLowestWeightWrestled();
	}
	public int getPrintRank() {
		if (forceRank == null ) {
			return getWins() + getLosses();
		} else {
			return 100000 - forceRank.intValue();
		}
	}
	public String getForceWeight() { return forceWeight; }
	public Integer getForceRank() { return forceRank; }
	
	public void setWeight( int w ) { 
		if (matchWeight.containsKey(w)) {
			int val =matchWeight.get(w);
			matchWeight.put(w, val+1);
			
		}
		else {
		matchWeight.put(w, 1);	
		}
		
	}
	public String getWeight() {
		Enumeration<Integer> e = matchWeight.keys();
		String WeightString="";
		while (e.hasMoreElements()) {
			 
	            // Getting the key of a particular entry
	            int keyWeight = e.nextElement();
	            int valueCount = matchWeight.get(keyWeight);
	            
	            WeightString += Integer.toString(valueCount) + "@" + Integer.toString(keyWeight) + " - ";
	             
	          
	        }
		return WeightString;
		
	}


	
	public void setForceWeight( String w ) { forceWeight = w; }
	public void setForceRank ( Integer i ) { forceRank = i; }
	
	List<Bout> bouts = new ArrayList<Bout> ();

	public List<Bout> getBouts() { return bouts; }
	
	public boolean getLossByInjury() { return lossByInjury; }
	
	public WeighInHistory getWeighInHistory() { return wiHistory; }
	
	public void setWeighInHistory(WeighInHistory wih ) { wiHistory = wih; }

	public void setPrestigeLastYear(WrestlingLanguage.Prestige p) { prestigeLastYear = p; }
	public void setPrestige2YearsAgo(WrestlingLanguage.Prestige p) { prestige2YearsAgo= p; }
	public void setPrestige3YearsAgo(WrestlingLanguage.Prestige p) { prestige3YearsAgo = p; }

	public WrestlingLanguage.Prestige getPrestigeLastYear() { return prestigeLastYear; }
	public WrestlingLanguage.Prestige getPrestige2YearsAgo() { return prestige2YearsAgo; }
	public WrestlingLanguage.Prestige getPrestige3YearsAgo() { return prestige3YearsAgo; }

    public void printVerbose () {
		System.out.println( getName() + 
			" Grade<" + getGrade() + ">" + 
			" Seed<" + getSeed() + ">" +
			" Cert<" + getCert() + ">"); 
			//" Gender<" + getGender() + "> Wt<" + 
			//getTrackWtClass() + ">" + " (" + getWins() + "W-" + 
			//getLosses() + "L) Last Year=<" + rosteredLastYear + "> Last Year Record <" + trackLastYearRecord + ">" );
    }	   
	public String getRecordString() { 
		return String.valueOf(wins) + "-" + String.valueOf(losses); 
	}
	public String getRecordBreakdown() {
		String breakdownString = "";
		boolean addedWins=false;
		if ( getWins() > 0 ) {
			breakdownString += getWins() + "W[";
			if ( getWinByFall() > 0 ) {
				breakdownString += getWinByFall() + " Pin,";
				addedWins=true;
			}
			if ( getWinByTech() > 0 ) {
				breakdownString += getWinByTech() + " TF,";
				addedWins=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getWinByMD() + " MD,";
				addedWins=true;
			}
			if ( getWinByDec() > 0 ) {
				breakdownString += getWinByDec() + " Dec,";
				addedWins=true;
			}
			if ( getWinByFFT() > 0 ) {
				breakdownString += getWinByFFT() + " FFT,";
				addedWins=true;
			}
			if ( addedWins ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "0 W";
		}
		boolean addedLosses=false;
		if ( getLosses() > 0 ) {
			breakdownString += "-" + getLosses() + "L[";
			if ( getLossByFall() > 0 ) {
				breakdownString += getLossByFall() + " Pin,";
				addedLosses=true;
			}
			if ( getLossByTech() > 0 ) {
				breakdownString += getLossByTech() + " TF,";
				addedLosses=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getLossByMD() + " MD,";
				addedLosses=true;
			}
			if ( getLossByDec() > 0 ) {
				breakdownString += getLossByDec() + " Dec,";
				addedLosses=true;
			}
			
			if ( addedLosses ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "-0L";
		}
		if ( getWins() ==0 && getLosses() == 0 ) {
			return "";
		} else {
			return breakdownString +" - "+ getWeight();
		}
	}
	public String getName() { return name; }
	public String getSeed() { return seed; }
	public String getCert() { return cert; }
	public String getTeamName() { return teamName; }
	public WrestlingLanguage.Grade getGrade() { return grade; }
	public WrestlingLanguage.Gender getGender() { return gender; }
	public String getTrackRecord() { return trackRecord; }
	public String getTrackWtClass() { return trackWtClass; }
	
	public int getWins() { return wins; }
	public int getLosses() { return losses; }
	
	public int getWinByFFT() { return winByFFT; }
	public int getWinByFall() { return winByFall; }
	public int getWinByTech() { return winByTech; }
	public int getWinByMD() { return winByMD; }
	public int getWinByDec() { return winByDec; }
	
	public int getLossByFFT() { return lossByFFT; }
	public int getLossByFall() { return lossByFall; }
	public int getLossByTech() { return lossByTech; }
	public int getLossByMD() { return lossByMD; }
	public int getLossByDec() { return lossByDec; }
	
    public Wrestler(String n, String team){
		setName(n);
		setTeamName(team);
		return;
	}
	public boolean getRosteredLastYear() { return rosteredLastYear; }
	
	public void setRosteredLastYearOn() { rosteredLastYear = true; }
	public void setRosteredLastYearOff() { rosteredLastYear = false; }
	
	public String getTrackLastYearWtClass() { return trackLastYearWtClass; }
	public String getTrackLastYearRecord() { return trackLastYearRecord; }
	
	public void setTrackLastYearWtClass(String w) { 
		trackLastYearWtClass = w; 
	}
	public void setTrackLastYearRecord(String r) {
		trackLastYearRecord = r;
	}
	
	
	public void addBout(Bout b) {
		String cmd=b.getMatchDate();
		if (cmd == null ) {
			Event e = b.getEvent();
			if ( e != null ) {
				String sss = e.getEventTitle();
				if ( wiHistory != null ) {
					String s = wiHistory.findWeighInDate(sss);
					if ( s != null ) { 
						b.setMatchDate(s);
					}
				}
			}
		}	
		
		bouts.add(b);
		addToSummary(b);
		addToMatchesAtWeight(b);
	}
	private void addToMatchesAtWeight(Bout b) {
		String w=b.getWeight();
		Integer ct = matchesAtWeight.get(w);
		if ( ct != null ) {
			ct++;
			matchesAtWeight.replace(w,ct);
		} else {
			matchesAtWeight.put(w,1);
		}
		return;
	}
	public String getMatchesAtWeightString() {

		String byWt="";
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
	
			int ct = matchesAtWeight.get(key);
			if ( byWt.length() > 0 ) { byWt=byWt + ";" ; }
			byWt=byWt + ct + "@" + key;
		}
		return byWt;
	}
	
	public void setName( String n ) {
		name = n.strip();
	}
	public void setSeed( String n ) {
		seed = n.strip();
	}
	public void setCert( String n ) {
		cert = n.strip();
	}
	public void setTeamName( String team ) {
		teamName = team;
	}
	public void setGrade5() { grade = WrestlingLanguage.Grade.G5;	}
	public void setGrade6() { grade = WrestlingLanguage.Grade.G6;	}
	public void setGrade7() { grade = WrestlingLanguage.Grade.G7;	}
	public void setGrade8() { grade = WrestlingLanguage.Grade.G8;	}
	public void setGrade(WrestlingLanguage.Grade g ) { grade=g; }
	
	public void setGenderM() { gender = WrestlingLanguage.Gender.M;	}
	public void setGenderF() { gender = WrestlingLanguage.Gender.F;	}
	public void setGender(WrestlingLanguage.Gender g ) { gender = g; }
	
	public void setTrackRecord(String rec) {
		trackRecord = rec;
	}
	public void setTrackWtClass(String w ) {
		trackWtClass = w;
	}
	public String toString() {
		return "Wrestler:" + teamName + ":" + name  ;
	}
	private void addToSummary(Bout b) {
	   if ( b.isAWin() ) {
          addWin();	
          switch ( b.getMatchResultType() ) {
			  case FFT: 
			    addWinByFFT();
				break;
			  case FALL:
			    addWinByFall();
				break;
			  case TECH:
			    addWinByTech();
				break;
			  case MD:
			    addWinByMD();
			    break;
			  case DEC:
			    addWinByDec();
				break;
			  case INJ:
			    break;
			  case DQ:
			    break;
		  }
       } else {
          addLoss();
          switch ( b.getMatchResultType() ) {

          case FFT:
			  addLossByFFT();
			    break;
			  case FALL:
			    addLossByFall();
				break;
			  case TECH:
			    addLossByTech();
				break;
			  case MD:
			    addLossByMD();
			    break;
			  case DEC:
			    addLossByDec();
				break;
			  case INJ:
			    if ( lossByInjury) {
			    	lossByInjuryString += ";";
			    } else {
			    	lossByInjury=true;
			    	lossByInjuryString= "Loss by Injury on ";
			    }
			    if ( b.getMatchDate() != null ) {
			    	lossByInjuryString += b.getMatchDate();
			    	lossByInjuryString += " ";
			    }
			    lossByInjuryString += " vs ";
			    lossByInjuryString += b.getOpponentTeam();
			    
			    break;
			  case DQ:
			    break;
		  }		  
       }		  
	}
	public void addWin() { wins++; }
	public void addLoss() { losses++; }
	public void addWinByFFT() { winByFFT++; }
	public void addWinByFall() { winByFall++; }
	public void addWinByTech() { winByTech++; }
	public void addWinByMD() { winByMD++; }
	public void addWinByDec() { winByDec++; }
	
	public void addLossByFFT() { lossByFFT++; }
	public void addLossByFall() { lossByFall++; }
	public void addLossByTech() { lossByTech++; }
	public void addLossByMD() { lossByMD++; }
	public void addLossByDec() { lossByDec++; }

	public boolean equals(Object o) {
	  if ( o == null ) { return false; }
	  if ( this == o ) { return true; }
	  if ( this.getClass() == o.getClass() ){
         Wrestler ow = (Wrestler) o;		  
	     if ( this.getName().equals(ow.getName()) && this.getTeamName().equals(ow.getTeamName())) {
			 return true;
	     }
	  }
	  return false; 
	}
	public int hashCode() {
		return getName().hashCode() + getTeamName().hashCode();
	}


public String getFinWeight() {
	String finWeight = "";
	boolean a = playedMatch();
	
	if(cert != null) {
		finWeight = cert;
	}
	else (this.cert == null&&this.playedMatch()== true){
		finWeight = getLowestWeightWrestled();
	}
	
	return finWeight;
}

public boolean playedMatch() {
	if (matchWeight == null) {
		return false;
}	
	return true;
}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-13 22:32:47.937
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-13 22:32:47.937
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-13 22:32:54.785
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package JuniorHigh;

import java.util.*;
import java.util.Enumeration;

/*
 *
 *  This is a class to holds an wrestler and all data pertaining to him/her.
 */
class Wrestler {
	private String name;
	private String seed;
	private String cert;
	private String teamName;
	private WrestlingLanguage.Grade grade;
	private WrestlingLanguage.Gender gender;
	private String trackRecord;
	private String trackWtClass;
	private boolean rosteredLastYear;
	private String trackLastYearWtClass;
	private String trackLastYearRecord;
	private WrestlingLanguage.Prestige prestigeLastYear;
	private WrestlingLanguage.Prestige prestige2YearsAgo;
	private WrestlingLanguage.Prestige prestige3YearsAgo;
	
	private Hashtable<String,Integer> matchesAtWeight=new Hashtable<String,Integer>();
	
	private int wins;
	private int losses;
	private boolean lossByInjury=false;
	private String lossByInjuryString;
	private int winByFFT;
	private int lossByFFT;

	private int winByFall;
	private int winByDec;
	private int winByMD;
	private int winByTech;
	
	private int lossByFall;
	private int lossByDec;
	private int lossByMD;
	private int lossByTech;
	
	private int weight;
	
	private Hashtable<Integer,Integer> matchWeight=new Hashtable<Integer,Integer>();

		
	private WeighInHistory wiHistory;
	
	/* These 2 attributes are used to force where we put the wrestler in the reporting
	 * order.
	 */
	private String forceWeight=null;  /* for reporting force the use of this weight class. */
	private Integer forceRank=null;  /* for reporting this is the rank order withing the weight class. */

	public void setLossByInjuryString(String s) {
		lossByInjuryString = s;
	}
	public String getLossByInjuryString() { return lossByInjuryString; }
	
	public String getLowestWeightWrestled() {
		int lowInt=99999;
		
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
			int i =  Integer.parseInt(key);
		    if (i < lowInt ) {
		    	lowInt = i;
		    }
		}
		return Integer.toString(lowInt);
	}
	public String getPrintWeight() {
		if ( forceWeight != null ) {
			if ( forceWeight.length() > 0 ) {
				return forceWeight;
			}
		}
		return getLowestWeightWrestled();
	}
	public int getPrintRank() {
		if (forceRank == null ) {
			return getWins() + getLosses();
		} else {
			return 100000 - forceRank.intValue();
		}
	}
	public String getForceWeight() { return forceWeight; }
	public Integer getForceRank() { return forceRank; }
	
	public void setWeight( int w ) { 
		if (matchWeight.containsKey(w)) {
			int val =matchWeight.get(w);
			matchWeight.put(w, val+1);
			
		}
		else {
		matchWeight.put(w, 1);	
		}
		
	}
	public String getWeight() {
		Enumeration<Integer> e = matchWeight.keys();
		String WeightString="";
		while (e.hasMoreElements()) {
			 
	            // Getting the key of a particular entry
	            int keyWeight = e.nextElement();
	            int valueCount = matchWeight.get(keyWeight);
	            
	            WeightString += Integer.toString(valueCount) + "@" + Integer.toString(keyWeight) + " - ";
	             
	          
	        }
		return WeightString;
		
	}


	
	public void setForceWeight( String w ) { forceWeight = w; }
	public void setForceRank ( Integer i ) { forceRank = i; }
	
	List<Bout> bouts = new ArrayList<Bout> ();

	public List<Bout> getBouts() { return bouts; }
	
	public boolean getLossByInjury() { return lossByInjury; }
	
	public WeighInHistory getWeighInHistory() { return wiHistory; }
	
	public void setWeighInHistory(WeighInHistory wih ) { wiHistory = wih; }

	public void setPrestigeLastYear(WrestlingLanguage.Prestige p) { prestigeLastYear = p; }
	public void setPrestige2YearsAgo(WrestlingLanguage.Prestige p) { prestige2YearsAgo= p; }
	public void setPrestige3YearsAgo(WrestlingLanguage.Prestige p) { prestige3YearsAgo = p; }

	public WrestlingLanguage.Prestige getPrestigeLastYear() { return prestigeLastYear; }
	public WrestlingLanguage.Prestige getPrestige2YearsAgo() { return prestige2YearsAgo; }
	public WrestlingLanguage.Prestige getPrestige3YearsAgo() { return prestige3YearsAgo; }

    public void printVerbose () {
		System.out.println( getName() + 
			" Grade<" + getGrade() + ">" + 
			" Seed<" + getSeed() + ">" +
			" Cert<" + getCert() + ">"); 
			//" Gender<" + getGender() + "> Wt<" + 
			//getTrackWtClass() + ">" + " (" + getWins() + "W-" + 
			//getLosses() + "L) Last Year=<" + rosteredLastYear + "> Last Year Record <" + trackLastYearRecord + ">" );
    }	   
	public String getRecordString() { 
		return String.valueOf(wins) + "-" + String.valueOf(losses); 
	}
	public String getRecordBreakdown() {
		String breakdownString = "";
		boolean addedWins=false;
		if ( getWins() > 0 ) {
			breakdownString += getWins() + "W[";
			if ( getWinByFall() > 0 ) {
				breakdownString += getWinByFall() + " Pin,";
				addedWins=true;
			}
			if ( getWinByTech() > 0 ) {
				breakdownString += getWinByTech() + " TF,";
				addedWins=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getWinByMD() + " MD,";
				addedWins=true;
			}
			if ( getWinByDec() > 0 ) {
				breakdownString += getWinByDec() + " Dec,";
				addedWins=true;
			}
			if ( getWinByFFT() > 0 ) {
				breakdownString += getWinByFFT() + " FFT,";
				addedWins=true;
			}
			if ( addedWins ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "0 W";
		}
		boolean addedLosses=false;
		if ( getLosses() > 0 ) {
			breakdownString += "-" + getLosses() + "L[";
			if ( getLossByFall() > 0 ) {
				breakdownString += getLossByFall() + " Pin,";
				addedLosses=true;
			}
			if ( getLossByTech() > 0 ) {
				breakdownString += getLossByTech() + " TF,";
				addedLosses=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getLossByMD() + " MD,";
				addedLosses=true;
			}
			if ( getLossByDec() > 0 ) {
				breakdownString += getLossByDec() + " Dec,";
				addedLosses=true;
			}
			
			if ( addedLosses ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "-0L";
		}
		if ( getWins() ==0 && getLosses() == 0 ) {
			return "";
		} else {
			return breakdownString +" - "+ getWeight();
		}
	}
	public String getName() { return name; }
	public String getSeed() { return seed; }
	public String getCert() { return cert; }
	public String getTeamName() { return teamName; }
	public WrestlingLanguage.Grade getGrade() { return grade; }
	public WrestlingLanguage.Gender getGender() { return gender; }
	public String getTrackRecord() { return trackRecord; }
	public String getTrackWtClass() { return trackWtClass; }
	
	public int getWins() { return wins; }
	public int getLosses() { return losses; }
	
	public int getWinByFFT() { return winByFFT; }
	public int getWinByFall() { return winByFall; }
	public int getWinByTech() { return winByTech; }
	public int getWinByMD() { return winByMD; }
	public int getWinByDec() { return winByDec; }
	
	public int getLossByFFT() { return lossByFFT; }
	public int getLossByFall() { return lossByFall; }
	public int getLossByTech() { return lossByTech; }
	public int getLossByMD() { return lossByMD; }
	public int getLossByDec() { return lossByDec; }
	
    public Wrestler(String n, String team){
		setName(n);
		setTeamName(team);
		return;
	}
	public boolean getRosteredLastYear() { return rosteredLastYear; }
	
	public void setRosteredLastYearOn() { rosteredLastYear = true; }
	public void setRosteredLastYearOff() { rosteredLastYear = false; }
	
	public String getTrackLastYearWtClass() { return trackLastYearWtClass; }
	public String getTrackLastYearRecord() { return trackLastYearRecord; }
	
	public void setTrackLastYearWtClass(String w) { 
		trackLastYearWtClass = w; 
	}
	public void setTrackLastYearRecord(String r) {
		trackLastYearRecord = r;
	}
	
	
	public void addBout(Bout b) {
		String cmd=b.getMatchDate();
		if (cmd == null ) {
			Event e = b.getEvent();
			if ( e != null ) {
				String sss = e.getEventTitle();
				if ( wiHistory != null ) {
					String s = wiHistory.findWeighInDate(sss);
					if ( s != null ) { 
						b.setMatchDate(s);
					}
				}
			}
		}	
		
		bouts.add(b);
		addToSummary(b);
		addToMatchesAtWeight(b);
	}
	private void addToMatchesAtWeight(Bout b) {
		String w=b.getWeight();
		Integer ct = matchesAtWeight.get(w);
		if ( ct != null ) {
			ct++;
			matchesAtWeight.replace(w,ct);
		} else {
			matchesAtWeight.put(w,1);
		}
		return;
	}
	public String getMatchesAtWeightString() {

		String byWt="";
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
	
			int ct = matchesAtWeight.get(key);
			if ( byWt.length() > 0 ) { byWt=byWt + ";" ; }
			byWt=byWt + ct + "@" + key;
		}
		return byWt;
	}
	
	public void setName( String n ) {
		name = n.strip();
	}
	public void setSeed( String n ) {
		seed = n.strip();
	}
	public void setCert( String n ) {
		cert = n.strip();
	}
	public void setTeamName( String team ) {
		teamName = team;
	}
	public void setGrade5() { grade = WrestlingLanguage.Grade.G5;	}
	public void setGrade6() { grade = WrestlingLanguage.Grade.G6;	}
	public void setGrade7() { grade = WrestlingLanguage.Grade.G7;	}
	public void setGrade8() { grade = WrestlingLanguage.Grade.G8;	}
	public void setGrade(WrestlingLanguage.Grade g ) { grade=g; }
	
	public void setGenderM() { gender = WrestlingLanguage.Gender.M;	}
	public void setGenderF() { gender = WrestlingLanguage.Gender.F;	}
	public void setGender(WrestlingLanguage.Gender g ) { gender = g; }
	
	public void setTrackRecord(String rec) {
		trackRecord = rec;
	}
	public void setTrackWtClass(String w ) {
		trackWtClass = w;
	}
	public String toString() {
		return "Wrestler:" + teamName + ":" + name  ;
	}
	private void addToSummary(Bout b) {
	   if ( b.isAWin() ) {
          addWin();	
          switch ( b.getMatchResultType() ) {
			  case FFT: 
			    addWinByFFT();
				break;
			  case FALL:
			    addWinByFall();
				break;
			  case TECH:
			    addWinByTech();
				break;
			  case MD:
			    addWinByMD();
			    break;
			  case DEC:
			    addWinByDec();
				break;
			  case INJ:
			    break;
			  case DQ:
			    break;
		  }
       } else {
          addLoss();
          switch ( b.getMatchResultType() ) {

          case FFT:
			  addLossByFFT();
			    break;
			  case FALL:
			    addLossByFall();
				break;
			  case TECH:
			    addLossByTech();
				break;
			  case MD:
			    addLossByMD();
			    break;
			  case DEC:
			    addLossByDec();
				break;
			  case INJ:
			    if ( lossByInjury) {
			    	lossByInjuryString += ";";
			    } else {
			    	lossByInjury=true;
			    	lossByInjuryString= "Loss by Injury on ";
			    }
			    if ( b.getMatchDate() != null ) {
			    	lossByInjuryString += b.getMatchDate();
			    	lossByInjuryString += " ";
			    }
			    lossByInjuryString += " vs ";
			    lossByInjuryString += b.getOpponentTeam();
			    
			    break;
			  case DQ:
			    break;
		  }		  
       }		  
	}
	public void addWin() { wins++; }
	public void addLoss() { losses++; }
	public void addWinByFFT() { winByFFT++; }
	public void addWinByFall() { winByFall++; }
	public void addWinByTech() { winByTech++; }
	public void addWinByMD() { winByMD++; }
	public void addWinByDec() { winByDec++; }
	
	public void addLossByFFT() { lossByFFT++; }
	public void addLossByFall() { lossByFall++; }
	public void addLossByTech() { lossByTech++; }
	public void addLossByMD() { lossByMD++; }
	public void addLossByDec() { lossByDec++; }

	public boolean equals(Object o) {
	  if ( o == null ) { return false; }
	  if ( this == o ) { return true; }
	  if ( this.getClass() == o.getClass() ){
         Wrestler ow = (Wrestler) o;		  
	     if ( this.getName().equals(ow.getName()) && this.getTeamName().equals(ow.getTeamName())) {
			 return true;
	     }
	  }
	  return false; 
	}
	public int hashCode() {
		return getName().hashCode() + getTeamName().hashCode();
	}


public String getFinWeight() {
	String finWeight = "";
	boolean a = playedMatch();
	
	if(cert != null) {
		finWeight = cert;
	}
	else (this.cert == null&&this.playedMatch()== true){
		finWeight = getLowestWeightWrestled();
	}
	
	return finWeight;
}

public boolean playedMatch() {
	if (matchWeight == null) {
		return false;
}	
	return true;
}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-13 22:32:54.785
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-13 22:32:54.786
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-13 22:32:54.818
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package JuniorHigh;

import java.util.*;
import java.util.Enumeration;

/*
 *
 *  This is a class to holds an wrestler and all data pertaining to him/her.
 */
class Wrestler {
	private String name;
	private String seed;
	private String cert;
	private String teamName;
	private WrestlingLanguage.Grade grade;
	private WrestlingLanguage.Gender gender;
	private String trackRecord;
	private String trackWtClass;
	private boolean rosteredLastYear;
	private String trackLastYearWtClass;
	private String trackLastYearRecord;
	private WrestlingLanguage.Prestige prestigeLastYear;
	private WrestlingLanguage.Prestige prestige2YearsAgo;
	private WrestlingLanguage.Prestige prestige3YearsAgo;
	
	private Hashtable<String,Integer> matchesAtWeight=new Hashtable<String,Integer>();
	
	private int wins;
	private int losses;
	private boolean lossByInjury=false;
	private String lossByInjuryString;
	private int winByFFT;
	private int lossByFFT;

	private int winByFall;
	private int winByDec;
	private int winByMD;
	private int winByTech;
	
	private int lossByFall;
	private int lossByDec;
	private int lossByMD;
	private int lossByTech;
	
	private int weight;
	
	private Hashtable<Integer,Integer> matchWeight=new Hashtable<Integer,Integer>();

		
	private WeighInHistory wiHistory;
	
	/* These 2 attributes are used to force where we put the wrestler in the reporting
	 * order.
	 */
	private String forceWeight=null;  /* for reporting force the use of this weight class. */
	private Integer forceRank=null;  /* for reporting this is the rank order withing the weight class. */

	public void setLossByInjuryString(String s) {
		lossByInjuryString = s;
	}
	public String getLossByInjuryString() { return lossByInjuryString; }
	
	public String getLowestWeightWrestled() {
		int lowInt=99999;
		
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
			int i =  Integer.parseInt(key);
		    if (i < lowInt ) {
		    	lowInt = i;
		    }
		}
		return Integer.toString(lowInt);
	}
	public String getPrintWeight() {
		if ( forceWeight != null ) {
			if ( forceWeight.length() > 0 ) {
				return forceWeight;
			}
		}
		return getLowestWeightWrestled();
	}
	public int getPrintRank() {
		if (forceRank == null ) {
			return getWins() + getLosses();
		} else {
			return 100000 - forceRank.intValue();
		}
	}
	public String getForceWeight() { return forceWeight; }
	public Integer getForceRank() { return forceRank; }
	
	public void setWeight( int w ) { 
		if (matchWeight.containsKey(w)) {
			int val =matchWeight.get(w);
			matchWeight.put(w, val+1);
			
		}
		else {
		matchWeight.put(w, 1);	
		}
		
	}
	public String getWeight() {
		Enumeration<Integer> e = matchWeight.keys();
		String WeightString="";
		while (e.hasMoreElements()) {
			 
	            // Getting the key of a particular entry
	            int keyWeight = e.nextElement();
	            int valueCount = matchWeight.get(keyWeight);
	            
	            WeightString += Integer.toString(valueCount) + "@" + Integer.toString(keyWeight) + " - ";
	             
	          
	        }
		return WeightString;
		
	}


	
	public void setForceWeight( String w ) { forceWeight = w; }
	public void setForceRank ( Integer i ) { forceRank = i; }
	
	List<Bout> bouts = new ArrayList<Bout> ();

	public List<Bout> getBouts() { return bouts; }
	
	public boolean getLossByInjury() { return lossByInjury; }
	
	public WeighInHistory getWeighInHistory() { return wiHistory; }
	
	public void setWeighInHistory(WeighInHistory wih ) { wiHistory = wih; }

	public void setPrestigeLastYear(WrestlingLanguage.Prestige p) { prestigeLastYear = p; }
	public void setPrestige2YearsAgo(WrestlingLanguage.Prestige p) { prestige2YearsAgo= p; }
	public void setPrestige3YearsAgo(WrestlingLanguage.Prestige p) { prestige3YearsAgo = p; }

	public WrestlingLanguage.Prestige getPrestigeLastYear() { return prestigeLastYear; }
	public WrestlingLanguage.Prestige getPrestige2YearsAgo() { return prestige2YearsAgo; }
	public WrestlingLanguage.Prestige getPrestige3YearsAgo() { return prestige3YearsAgo; }

    public void printVerbose () {
		System.out.println( getName() + 
			" Grade<" + getGrade() + ">" + 
			" Seed<" + getSeed() + ">" +
			" Cert<" + getCert() + ">"); 
			//" Gender<" + getGender() + "> Wt<" + 
			//getTrackWtClass() + ">" + " (" + getWins() + "W-" + 
			//getLosses() + "L) Last Year=<" + rosteredLastYear + "> Last Year Record <" + trackLastYearRecord + ">" );
    }	   
	public String getRecordString() { 
		return String.valueOf(wins) + "-" + String.valueOf(losses); 
	}
	public String getRecordBreakdown() {
		String breakdownString = "";
		boolean addedWins=false;
		if ( getWins() > 0 ) {
			breakdownString += getWins() + "W[";
			if ( getWinByFall() > 0 ) {
				breakdownString += getWinByFall() + " Pin,";
				addedWins=true;
			}
			if ( getWinByTech() > 0 ) {
				breakdownString += getWinByTech() + " TF,";
				addedWins=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getWinByMD() + " MD,";
				addedWins=true;
			}
			if ( getWinByDec() > 0 ) {
				breakdownString += getWinByDec() + " Dec,";
				addedWins=true;
			}
			if ( getWinByFFT() > 0 ) {
				breakdownString += getWinByFFT() + " FFT,";
				addedWins=true;
			}
			if ( addedWins ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "0 W";
		}
		boolean addedLosses=false;
		if ( getLosses() > 0 ) {
			breakdownString += "-" + getLosses() + "L[";
			if ( getLossByFall() > 0 ) {
				breakdownString += getLossByFall() + " Pin,";
				addedLosses=true;
			}
			if ( getLossByTech() > 0 ) {
				breakdownString += getLossByTech() + " TF,";
				addedLosses=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getLossByMD() + " MD,";
				addedLosses=true;
			}
			if ( getLossByDec() > 0 ) {
				breakdownString += getLossByDec() + " Dec,";
				addedLosses=true;
			}
			
			if ( addedLosses ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "-0L";
		}
		if ( getWins() ==0 && getLosses() == 0 ) {
			return "";
		} else {
			return breakdownString +" - "+ getWeight();
		}
	}
	public String getName() { return name; }
	public String getSeed() { return seed; }
	public String getCert() { return cert; }
	public String getTeamName() { return teamName; }
	public WrestlingLanguage.Grade getGrade() { return grade; }
	public WrestlingLanguage.Gender getGender() { return gender; }
	public String getTrackRecord() { return trackRecord; }
	public String getTrackWtClass() { return trackWtClass; }
	
	public int getWins() { return wins; }
	public int getLosses() { return losses; }
	
	public int getWinByFFT() { return winByFFT; }
	public int getWinByFall() { return winByFall; }
	public int getWinByTech() { return winByTech; }
	public int getWinByMD() { return winByMD; }
	public int getWinByDec() { return winByDec; }
	
	public int getLossByFFT() { return lossByFFT; }
	public int getLossByFall() { return lossByFall; }
	public int getLossByTech() { return lossByTech; }
	public int getLossByMD() { return lossByMD; }
	public int getLossByDec() { return lossByDec; }
	
    public Wrestler(String n, String team){
		setName(n);
		setTeamName(team);
		return;
	}
	public boolean getRosteredLastYear() { return rosteredLastYear; }
	
	public void setRosteredLastYearOn() { rosteredLastYear = true; }
	public void setRosteredLastYearOff() { rosteredLastYear = false; }
	
	public String getTrackLastYearWtClass() { return trackLastYearWtClass; }
	public String getTrackLastYearRecord() { return trackLastYearRecord; }
	
	public void setTrackLastYearWtClass(String w) { 
		trackLastYearWtClass = w; 
	}
	public void setTrackLastYearRecord(String r) {
		trackLastYearRecord = r;
	}
	
	
	public void addBout(Bout b) {
		String cmd=b.getMatchDate();
		if (cmd == null ) {
			Event e = b.getEvent();
			if ( e != null ) {
				String sss = e.getEventTitle();
				if ( wiHistory != null ) {
					String s = wiHistory.findWeighInDate(sss);
					if ( s != null ) { 
						b.setMatchDate(s);
					}
				}
			}
		}	
		
		bouts.add(b);
		addToSummary(b);
		addToMatchesAtWeight(b);
	}
	private void addToMatchesAtWeight(Bout b) {
		String w=b.getWeight();
		Integer ct = matchesAtWeight.get(w);
		if ( ct != null ) {
			ct++;
			matchesAtWeight.replace(w,ct);
		} else {
			matchesAtWeight.put(w,1);
		}
		return;
	}
	public String getMatchesAtWeightString() {

		String byWt="";
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
	
			int ct = matchesAtWeight.get(key);
			if ( byWt.length() > 0 ) { byWt=byWt + ";" ; }
			byWt=byWt + ct + "@" + key;
		}
		return byWt;
	}
	
	public void setName( String n ) {
		name = n.strip();
	}
	public void setSeed( String n ) {
		seed = n.strip();
	}
	public void setCert( String n ) {
		cert = n.strip();
	}
	public void setTeamName( String team ) {
		teamName = team;
	}
	public void setGrade5() { grade = WrestlingLanguage.Grade.G5;	}
	public void setGrade6() { grade = WrestlingLanguage.Grade.G6;	}
	public void setGrade7() { grade = WrestlingLanguage.Grade.G7;	}
	public void setGrade8() { grade = WrestlingLanguage.Grade.G8;	}
	public void setGrade(WrestlingLanguage.Grade g ) { grade=g; }
	
	public void setGenderM() { gender = WrestlingLanguage.Gender.M;	}
	public void setGenderF() { gender = WrestlingLanguage.Gender.F;	}
	public void setGender(WrestlingLanguage.Gender g ) { gender = g; }
	
	public void setTrackRecord(String rec) {
		trackRecord = rec;
	}
	public void setTrackWtClass(String w ) {
		trackWtClass = w;
	}
	public String toString() {
		return "Wrestler:" + teamName + ":" + name  ;
	}
	private void addToSummary(Bout b) {
	   if ( b.isAWin() ) {
          addWin();	
          switch ( b.getMatchResultType() ) {
			  case FFT: 
			    addWinByFFT();
				break;
			  case FALL:
			    addWinByFall();
				break;
			  case TECH:
			    addWinByTech();
				break;
			  case MD:
			    addWinByMD();
			    break;
			  case DEC:
			    addWinByDec();
				break;
			  case INJ:
			    break;
			  case DQ:
			    break;
		  }
       } else {
          addLoss();
          switch ( b.getMatchResultType() ) {

          case FFT:
			  addLossByFFT();
			    break;
			  case FALL:
			    addLossByFall();
				break;
			  case TECH:
			    addLossByTech();
				break;
			  case MD:
			    addLossByMD();
			    break;
			  case DEC:
			    addLossByDec();
				break;
			  case INJ:
			    if ( lossByInjury) {
			    	lossByInjuryString += ";";
			    } else {
			    	lossByInjury=true;
			    	lossByInjuryString= "Loss by Injury on ";
			    }
			    if ( b.getMatchDate() != null ) {
			    	lossByInjuryString += b.getMatchDate();
			    	lossByInjuryString += " ";
			    }
			    lossByInjuryString += " vs ";
			    lossByInjuryString += b.getOpponentTeam();
			    
			    break;
			  case DQ:
			    break;
		  }		  
       }		  
	}
	public void addWin() { wins++; }
	public void addLoss() { losses++; }
	public void addWinByFFT() { winByFFT++; }
	public void addWinByFall() { winByFall++; }
	public void addWinByTech() { winByTech++; }
	public void addWinByMD() { winByMD++; }
	public void addWinByDec() { winByDec++; }
	
	public void addLossByFFT() { lossByFFT++; }
	public void addLossByFall() { lossByFall++; }
	public void addLossByTech() { lossByTech++; }
	public void addLossByMD() { lossByMD++; }
	public void addLossByDec() { lossByDec++; }

	public boolean equals(Object o) {
	  if ( o == null ) { return false; }
	  if ( this == o ) { return true; }
	  if ( this.getClass() == o.getClass() ){
         Wrestler ow = (Wrestler) o;		  
	     if ( this.getName().equals(ow.getName()) && this.getTeamName().equals(ow.getTeamName())) {
			 return true;
	     }
	  }
	  return false; 
	}
	public int hashCode() {
		return getName().hashCode() + getTeamName().hashCode();
	}


public String getFinWeight() {
	String finWeight = "";
	boolean a = playedMatch();
	
	if(cert != null) {
		finWeight = cert;
	}
	else (this.cert == null&&this.playedMatch()== true){
		finWeight = getLowestWeightWrestled();
	}
	
	return finWeight;
}

public boolean playedMatch() {
	if (matchWeight == null) {
		return false;
}	
	return true;
}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-13 22:32:54.820
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-13 22:32:54.821
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-13 22:32:55.047
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package JuniorHigh;

import java.util.*;
import java.util.Enumeration;

/*
 *
 *  This is a class to holds an wrestler and all data pertaining to him/her.
 */
class Wrestler {
	private String name;
	private String seed;
	private String cert;
	private String teamName;
	private WrestlingLanguage.Grade grade;
	private WrestlingLanguage.Gender gender;
	private String trackRecord;
	private String trackWtClass;
	private boolean rosteredLastYear;
	private String trackLastYearWtClass;
	private String trackLastYearRecord;
	private WrestlingLanguage.Prestige prestigeLastYear;
	private WrestlingLanguage.Prestige prestige2YearsAgo;
	private WrestlingLanguage.Prestige prestige3YearsAgo;
	
	private Hashtable<String,Integer> matchesAtWeight=new Hashtable<String,Integer>();
	
	private int wins;
	private int losses;
	private boolean lossByInjury=false;
	private String lossByInjuryString;
	private int winByFFT;
	private int lossByFFT;

	private int winByFall;
	private int winByDec;
	private int winByMD;
	private int winByTech;
	
	private int lossByFall;
	private int lossByDec;
	private int lossByMD;
	private int lossByTech;
	
	private int weight;
	
	private Hashtable<Integer,Integer> matchWeight=new Hashtable<Integer,Integer>();

		
	private WeighInHistory wiHistory;
	
	/* These 2 attributes are used to force where we put the wrestler in the reporting
	 * order.
	 */
	private String forceWeight=null;  /* for reporting force the use of this weight class. */
	private Integer forceRank=null;  /* for reporting this is the rank order withing the weight class. */

	public void setLossByInjuryString(String s) {
		lossByInjuryString = s;
	}
	public String getLossByInjuryString() { return lossByInjuryString; }
	
	public String getLowestWeightWrestled() {
		int lowInt=99999;
		
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
			int i =  Integer.parseInt(key);
		    if (i < lowInt ) {
		    	lowInt = i;
		    }
		}
		return Integer.toString(lowInt);
	}
	public String getPrintWeight() {
		if ( forceWeight != null ) {
			if ( forceWeight.length() > 0 ) {
				return forceWeight;
			}
		}
		return getLowestWeightWrestled();
	}
	public int getPrintRank() {
		if (forceRank == null ) {
			return getWins() + getLosses();
		} else {
			return 100000 - forceRank.intValue();
		}
	}
	public String getForceWeight() { return forceWeight; }
	public Integer getForceRank() { return forceRank; }
	
	public void setWeight( int w ) { 
		if (matchWeight.containsKey(w)) {
			int val =matchWeight.get(w);
			matchWeight.put(w, val+1);
			
		}
		else {
		matchWeight.put(w, 1);	
		}
		
	}
	public String getWeight() {
		Enumeration<Integer> e = matchWeight.keys();
		String WeightString="";
		while (e.hasMoreElements()) {
			 
	            // Getting the key of a particular entry
	            int keyWeight = e.nextElement();
	            int valueCount = matchWeight.get(keyWeight);
	            
	            WeightString += Integer.toString(valueCount) + "@" + Integer.toString(keyWeight) + " - ";
	             
	          
	        }
		return WeightString;
		
	}


	
	public void setForceWeight( String w ) { forceWeight = w; }
	public void setForceRank ( Integer i ) { forceRank = i; }
	
	List<Bout> bouts = new ArrayList<Bout> ();

	public List<Bout> getBouts() { return bouts; }
	
	public boolean getLossByInjury() { return lossByInjury; }
	
	public WeighInHistory getWeighInHistory() { return wiHistory; }
	
	public void setWeighInHistory(WeighInHistory wih ) { wiHistory = wih; }

	public void setPrestigeLastYear(WrestlingLanguage.Prestige p) { prestigeLastYear = p; }
	public void setPrestige2YearsAgo(WrestlingLanguage.Prestige p) { prestige2YearsAgo= p; }
	public void setPrestige3YearsAgo(WrestlingLanguage.Prestige p) { prestige3YearsAgo = p; }

	public WrestlingLanguage.Prestige getPrestigeLastYear() { return prestigeLastYear; }
	public WrestlingLanguage.Prestige getPrestige2YearsAgo() { return prestige2YearsAgo; }
	public WrestlingLanguage.Prestige getPrestige3YearsAgo() { return prestige3YearsAgo; }

    public void printVerbose () {
		System.out.println( getName() + 
			" Grade<" + getGrade() + ">" + 
			" Seed<" + getSeed() + ">" +
			" Cert<" + getCert() + ">"); 
			//" Gender<" + getGender() + "> Wt<" + 
			//getTrackWtClass() + ">" + " (" + getWins() + "W-" + 
			//getLosses() + "L) Last Year=<" + rosteredLastYear + "> Last Year Record <" + trackLastYearRecord + ">" );
    }	   
	public String getRecordString() { 
		return String.valueOf(wins) + "-" + String.valueOf(losses); 
	}
	public String getRecordBreakdown() {
		String breakdownString = "";
		boolean addedWins=false;
		if ( getWins() > 0 ) {
			breakdownString += getWins() + "W[";
			if ( getWinByFall() > 0 ) {
				breakdownString += getWinByFall() + " Pin,";
				addedWins=true;
			}
			if ( getWinByTech() > 0 ) {
				breakdownString += getWinByTech() + " TF,";
				addedWins=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getWinByMD() + " MD,";
				addedWins=true;
			}
			if ( getWinByDec() > 0 ) {
				breakdownString += getWinByDec() + " Dec,";
				addedWins=true;
			}
			if ( getWinByFFT() > 0 ) {
				breakdownString += getWinByFFT() + " FFT,";
				addedWins=true;
			}
			if ( addedWins ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "0 W";
		}
		boolean addedLosses=false;
		if ( getLosses() > 0 ) {
			breakdownString += "-" + getLosses() + "L[";
			if ( getLossByFall() > 0 ) {
				breakdownString += getLossByFall() + " Pin,";
				addedLosses=true;
			}
			if ( getLossByTech() > 0 ) {
				breakdownString += getLossByTech() + " TF,";
				addedLosses=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getLossByMD() + " MD,";
				addedLosses=true;
			}
			if ( getLossByDec() > 0 ) {
				breakdownString += getLossByDec() + " Dec,";
				addedLosses=true;
			}
			
			if ( addedLosses ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "-0L";
		}
		if ( getWins() ==0 && getLosses() == 0 ) {
			return "";
		} else {
			return breakdownString +" - "+ getWeight();
		}
	}
	public String getName() { return name; }
	public String getSeed() { return seed; }
	public String getCert() { return cert; }
	public String getTeamName() { return teamName; }
	public WrestlingLanguage.Grade getGrade() { return grade; }
	public WrestlingLanguage.Gender getGender() { return gender; }
	public String getTrackRecord() { return trackRecord; }
	public String getTrackWtClass() { return trackWtClass; }
	
	public int getWins() { return wins; }
	public int getLosses() { return losses; }
	
	public int getWinByFFT() { return winByFFT; }
	public int getWinByFall() { return winByFall; }
	public int getWinByTech() { return winByTech; }
	public int getWinByMD() { return winByMD; }
	public int getWinByDec() { return winByDec; }
	
	public int getLossByFFT() { return lossByFFT; }
	public int getLossByFall() { return lossByFall; }
	public int getLossByTech() { return lossByTech; }
	public int getLossByMD() { return lossByMD; }
	public int getLossByDec() { return lossByDec; }
	
    public Wrestler(String n, String team){
		setName(n);
		setTeamName(team);
		return;
	}
	public boolean getRosteredLastYear() { return rosteredLastYear; }
	
	public void setRosteredLastYearOn() { rosteredLastYear = true; }
	public void setRosteredLastYearOff() { rosteredLastYear = false; }
	
	public String getTrackLastYearWtClass() { return trackLastYearWtClass; }
	public String getTrackLastYearRecord() { return trackLastYearRecord; }
	
	public void setTrackLastYearWtClass(String w) { 
		trackLastYearWtClass = w; 
	}
	public void setTrackLastYearRecord(String r) {
		trackLastYearRecord = r;
	}
	
	
	public void addBout(Bout b) {
		String cmd=b.getMatchDate();
		if (cmd == null ) {
			Event e = b.getEvent();
			if ( e != null ) {
				String sss = e.getEventTitle();
				if ( wiHistory != null ) {
					String s = wiHistory.findWeighInDate(sss);
					if ( s != null ) { 
						b.setMatchDate(s);
					}
				}
			}
		}	
		
		bouts.add(b);
		addToSummary(b);
		addToMatchesAtWeight(b);
	}
	private void addToMatchesAtWeight(Bout b) {
		String w=b.getWeight();
		Integer ct = matchesAtWeight.get(w);
		if ( ct != null ) {
			ct++;
			matchesAtWeight.replace(w,ct);
		} else {
			matchesAtWeight.put(w,1);
		}
		return;
	}
	public String getMatchesAtWeightString() {

		String byWt="";
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
	
			int ct = matchesAtWeight.get(key);
			if ( byWt.length() > 0 ) { byWt=byWt + ";" ; }
			byWt=byWt + ct + "@" + key;
		}
		return byWt;
	}
	
	public void setName( String n ) {
		name = n.strip();
	}
	public void setSeed( String n ) {
		seed = n.strip();
	}
	public void setCert( String n ) {
		cert = n.strip();
	}
	public void setTeamName( String team ) {
		teamName = team;
	}
	public void setGrade5() { grade = WrestlingLanguage.Grade.G5;	}
	public void setGrade6() { grade = WrestlingLanguage.Grade.G6;	}
	public void setGrade7() { grade = WrestlingLanguage.Grade.G7;	}
	public void setGrade8() { grade = WrestlingLanguage.Grade.G8;	}
	public void setGrade(WrestlingLanguage.Grade g ) { grade=g; }
	
	public void setGenderM() { gender = WrestlingLanguage.Gender.M;	}
	public void setGenderF() { gender = WrestlingLanguage.Gender.F;	}
	public void setGender(WrestlingLanguage.Gender g ) { gender = g; }
	
	public void setTrackRecord(String rec) {
		trackRecord = rec;
	}
	public void setTrackWtClass(String w ) {
		trackWtClass = w;
	}
	public String toString() {
		return "Wrestler:" + teamName + ":" + name  ;
	}
	private void addToSummary(Bout b) {
	   if ( b.isAWin() ) {
          addWin();	
          switch ( b.getMatchResultType() ) {
			  case FFT: 
			    addWinByFFT();
				break;
			  case FALL:
			    addWinByFall();
				break;
			  case TECH:
			    addWinByTech();
				break;
			  case MD:
			    addWinByMD();
			    break;
			  case DEC:
			    addWinByDec();
				break;
			  case INJ:
			    break;
			  case DQ:
			    break;
		  }
       } else {
          addLoss();
          switch ( b.getMatchResultType() ) {

          case FFT:
			  addLossByFFT();
			    break;
			  case FALL:
			    addLossByFall();
				break;
			  case TECH:
			    addLossByTech();
				break;
			  case MD:
			    addLossByMD();
			    break;
			  case DEC:
			    addLossByDec();
				break;
			  case INJ:
			    if ( lossByInjury) {
			    	lossByInjuryString += ";";
			    } else {
			    	lossByInjury=true;
			    	lossByInjuryString= "Loss by Injury on ";
			    }
			    if ( b.getMatchDate() != null ) {
			    	lossByInjuryString += b.getMatchDate();
			    	lossByInjuryString += " ";
			    }
			    lossByInjuryString += " vs ";
			    lossByInjuryString += b.getOpponentTeam();
			    
			    break;
			  case DQ:
			    break;
		  }		  
       }		  
	}
	public void addWin() { wins++; }
	public void addLoss() { losses++; }
	public void addWinByFFT() { winByFFT++; }
	public void addWinByFall() { winByFall++; }
	public void addWinByTech() { winByTech++; }
	public void addWinByMD() { winByMD++; }
	public void addWinByDec() { winByDec++; }
	
	public void addLossByFFT() { lossByFFT++; }
	public void addLossByFall() { lossByFall++; }
	public void addLossByTech() { lossByTech++; }
	public void addLossByMD() { lossByMD++; }
	public void addLossByDec() { lossByDec++; }

	public boolean equals(Object o) {
	  if ( o == null ) { return false; }
	  if ( this == o ) { return true; }
	  if ( this.getClass() == o.getClass() ){
         Wrestler ow = (Wrestler) o;		  
	     if ( this.getName().equals(ow.getName()) && this.getTeamName().equals(ow.getTeamName())) {
			 return true;
	     }
	  }
	  return false; 
	}
	public int hashCode() {
		return getName().hashCode() + getTeamName().hashCode();
	}


public String getFinWeight() {
	String finWeight = "";
	boolean a = playedMatch();
	
	if(cert != null) {
		finWeight = cert;
	}
	else (this.cert == null&&this.playedMatch()== true){
		finWeight = getLowestWeightWrestled();
	}
	
	return finWeight;
}

public boolean playedMatch() {
	if (matchWeight == null) {
		return false;
}	
	return true;
}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-13 22:32:55.049
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-13 22:32:55.050
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-13 22:33:03.985
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package JuniorHigh;

import java.util.*;
import java.util.Enumeration;

/*
 *
 *  This is a class to holds an wrestler and all data pertaining to him/her.
 */
class Wrestler {
	private String name;
	private String seed;
	private String cert;
	private String teamName;
	private WrestlingLanguage.Grade grade;
	private WrestlingLanguage.Gender gender;
	private String trackRecord;
	private String trackWtClass;
	private boolean rosteredLastYear;
	private String trackLastYearWtClass;
	private String trackLastYearRecord;
	private WrestlingLanguage.Prestige prestigeLastYear;
	private WrestlingLanguage.Prestige prestige2YearsAgo;
	private WrestlingLanguage.Prestige prestige3YearsAgo;
	
	private Hashtable<String,Integer> matchesAtWeight=new Hashtable<String,Integer>();
	
	private int wins;
	private int losses;
	private boolean lossByInjury=false;
	private String lossByInjuryString;
	private int winByFFT;
	private int lossByFFT;

	private int winByFall;
	private int winByDec;
	private int winByMD;
	private int winByTech;
	
	private int lossByFall;
	private int lossByDec;
	private int lossByMD;
	private int lossByTech;
	
	private int weight;
	
	private Hashtable<Integer,Integer> matchWeight=new Hashtable<Integer,Integer>();

		
	private WeighInHistory wiHistory;
	
	/* These 2 attributes are used to force where we put the wrestler in the reporting
	 * order.
	 */
	private String forceWeight=null;  /* for reporting force the use of this weight class. */
	private Integer forceRank=null;  /* for reporting this is the rank order withing the weight class. */

	public void setLossByInjuryString(String s) {
		lossByInjuryString = s;
	}
	public String getLossByInjuryString() { return lossByInjuryString; }
	
	public String getLowestWeightWrestled() {
		int lowInt=99999;
		
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
			int i =  Integer.parseInt(key);
		    if (i < lowInt ) {
		    	lowInt = i;
		    }
		}
		return Integer.toString(lowInt);
	}
	public String getPrintWeight() {
		if ( forceWeight != null ) {
			if ( forceWeight.length() > 0 ) {
				return forceWeight;
			}
		}
		return getLowestWeightWrestled();
	}
	public int getPrintRank() {
		if (forceRank == null ) {
			return getWins() + getLosses();
		} else {
			return 100000 - forceRank.intValue();
		}
	}
	public String getForceWeight() { return forceWeight; }
	public Integer getForceRank() { return forceRank; }
	
	public void setWeight( int w ) { 
		if (matchWeight.containsKey(w)) {
			int val =matchWeight.get(w);
			matchWeight.put(w, val+1);
			
		}
		else {
		matchWeight.put(w, 1);	
		}
		
	}
	public String getWeight() {
		Enumeration<Integer> e = matchWeight.keys();
		String WeightString="";
		while (e.hasMoreElements()) {
			 
	            // Getting the key of a particular entry
	            int keyWeight = e.nextElement();
	            int valueCount = matchWeight.get(keyWeight);
	            
	            WeightString += Integer.toString(valueCount) + "@" + Integer.toString(keyWeight) + " - ";
	             
	          
	        }
		return WeightString;
		
	}


	
	public void setForceWeight( String w ) { forceWeight = w; }
	public void setForceRank ( Integer i ) { forceRank = i; }
	
	List<Bout> bouts = new ArrayList<Bout> ();

	public List<Bout> getBouts() { return bouts; }
	
	public boolean getLossByInjury() { return lossByInjury; }
	
	public WeighInHistory getWeighInHistory() { return wiHistory; }
	
	public void setWeighInHistory(WeighInHistory wih ) { wiHistory = wih; }

	public void setPrestigeLastYear(WrestlingLanguage.Prestige p) { prestigeLastYear = p; }
	public void setPrestige2YearsAgo(WrestlingLanguage.Prestige p) { prestige2YearsAgo= p; }
	public void setPrestige3YearsAgo(WrestlingLanguage.Prestige p) { prestige3YearsAgo = p; }

	public WrestlingLanguage.Prestige getPrestigeLastYear() { return prestigeLastYear; }
	public WrestlingLanguage.Prestige getPrestige2YearsAgo() { return prestige2YearsAgo; }
	public WrestlingLanguage.Prestige getPrestige3YearsAgo() { return prestige3YearsAgo; }

    public void printVerbose () {
		System.out.println( getName() + 
			" Grade<" + getGrade() + ">" + 
			" Seed<" + getSeed() + ">" +
			" Cert<" + getCert() + ">"); 
			//" Gender<" + getGender() + "> Wt<" + 
			//getTrackWtClass() + ">" + " (" + getWins() + "W-" + 
			//getLosses() + "L) Last Year=<" + rosteredLastYear + "> Last Year Record <" + trackLastYearRecord + ">" );
    }	   
	public String getRecordString() { 
		return String.valueOf(wins) + "-" + String.valueOf(losses); 
	}
	public String getRecordBreakdown() {
		String breakdownString = "";
		boolean addedWins=false;
		if ( getWins() > 0 ) {
			breakdownString += getWins() + "W[";
			if ( getWinByFall() > 0 ) {
				breakdownString += getWinByFall() + " Pin,";
				addedWins=true;
			}
			if ( getWinByTech() > 0 ) {
				breakdownString += getWinByTech() + " TF,";
				addedWins=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getWinByMD() + " MD,";
				addedWins=true;
			}
			if ( getWinByDec() > 0 ) {
				breakdownString += getWinByDec() + " Dec,";
				addedWins=true;
			}
			if ( getWinByFFT() > 0 ) {
				breakdownString += getWinByFFT() + " FFT,";
				addedWins=true;
			}
			if ( addedWins ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "0 W";
		}
		boolean addedLosses=false;
		if ( getLosses() > 0 ) {
			breakdownString += "-" + getLosses() + "L[";
			if ( getLossByFall() > 0 ) {
				breakdownString += getLossByFall() + " Pin,";
				addedLosses=true;
			}
			if ( getLossByTech() > 0 ) {
				breakdownString += getLossByTech() + " TF,";
				addedLosses=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getLossByMD() + " MD,";
				addedLosses=true;
			}
			if ( getLossByDec() > 0 ) {
				breakdownString += getLossByDec() + " Dec,";
				addedLosses=true;
			}
			
			if ( addedLosses ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "-0L";
		}
		if ( getWins() ==0 && getLosses() == 0 ) {
			return "";
		} else {
			return breakdownString +" - "+ getWeight();
		}
	}
	public String getName() { return name; }
	public String getSeed() { return seed; }
	public String getCert() { return cert; }
	public String getTeamName() { return teamName; }
	public WrestlingLanguage.Grade getGrade() { return grade; }
	public WrestlingLanguage.Gender getGender() { return gender; }
	public String getTrackRecord() { return trackRecord; }
	public String getTrackWtClass() { return trackWtClass; }
	
	public int getWins() { return wins; }
	public int getLosses() { return losses; }
	
	public int getWinByFFT() { return winByFFT; }
	public int getWinByFall() { return winByFall; }
	public int getWinByTech() { return winByTech; }
	public int getWinByMD() { return winByMD; }
	public int getWinByDec() { return winByDec; }
	
	public int getLossByFFT() { return lossByFFT; }
	public int getLossByFall() { return lossByFall; }
	public int getLossByTech() { return lossByTech; }
	public int getLossByMD() { return lossByMD; }
	public int getLossByDec() { return lossByDec; }
	
    public Wrestler(String n, String team){
		setName(n);
		setTeamName(team);
		return;
	}
	public boolean getRosteredLastYear() { return rosteredLastYear; }
	
	public void setRosteredLastYearOn() { rosteredLastYear = true; }
	public void setRosteredLastYearOff() { rosteredLastYear = false; }
	
	public String getTrackLastYearWtClass() { return trackLastYearWtClass; }
	public String getTrackLastYearRecord() { return trackLastYearRecord; }
	
	public void setTrackLastYearWtClass(String w) { 
		trackLastYearWtClass = w; 
	}
	public void setTrackLastYearRecord(String r) {
		trackLastYearRecord = r;
	}
	
	
	public void addBout(Bout b) {
		String cmd=b.getMatchDate();
		if (cmd == null ) {
			Event e = b.getEvent();
			if ( e != null ) {
				String sss = e.getEventTitle();
				if ( wiHistory != null ) {
					String s = wiHistory.findWeighInDate(sss);
					if ( s != null ) { 
						b.setMatchDate(s);
					}
				}
			}
		}	
		
		bouts.add(b);
		addToSummary(b);
		addToMatchesAtWeight(b);
	}
	private void addToMatchesAtWeight(Bout b) {
		String w=b.getWeight();
		Integer ct = matchesAtWeight.get(w);
		if ( ct != null ) {
			ct++;
			matchesAtWeight.replace(w,ct);
		} else {
			matchesAtWeight.put(w,1);
		}
		return;
	}
	public String getMatchesAtWeightString() {

		String byWt="";
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
	
			int ct = matchesAtWeight.get(key);
			if ( byWt.length() > 0 ) { byWt=byWt + ";" ; }
			byWt=byWt + ct + "@" + key;
		}
		return byWt;
	}
	
	public void setName( String n ) {
		name = n.strip();
	}
	public void setSeed( String n ) {
		seed = n.strip();
	}
	public void setCert( String n ) {
		cert = n.strip();
	}
	public void setTeamName( String team ) {
		teamName = team;
	}
	public void setGrade5() { grade = WrestlingLanguage.Grade.G5;	}
	public void setGrade6() { grade = WrestlingLanguage.Grade.G6;	}
	public void setGrade7() { grade = WrestlingLanguage.Grade.G7;	}
	public void setGrade8() { grade = WrestlingLanguage.Grade.G8;	}
	public void setGrade(WrestlingLanguage.Grade g ) { grade=g; }
	
	public void setGenderM() { gender = WrestlingLanguage.Gender.M;	}
	public void setGenderF() { gender = WrestlingLanguage.Gender.F;	}
	public void setGender(WrestlingLanguage.Gender g ) { gender = g; }
	
	public void setTrackRecord(String rec) {
		trackRecord = rec;
	}
	public void setTrackWtClass(String w ) {
		trackWtClass = w;
	}
	public String toString() {
		return "Wrestler:" + teamName + ":" + name  ;
	}
	private void addToSummary(Bout b) {
	   if ( b.isAWin() ) {
          addWin();	
          switch ( b.getMatchResultType() ) {
			  case FFT: 
			    addWinByFFT();
				break;
			  case FALL:
			    addWinByFall();
				break;
			  case TECH:
			    addWinByTech();
				break;
			  case MD:
			    addWinByMD();
			    break;
			  case DEC:
			    addWinByDec();
				break;
			  case INJ:
			    break;
			  case DQ:
			    break;
		  }
       } else {
          addLoss();
          switch ( b.getMatchResultType() ) {

          case FFT:
			  addLossByFFT();
			    break;
			  case FALL:
			    addLossByFall();
				break;
			  case TECH:
			    addLossByTech();
				break;
			  case MD:
			    addLossByMD();
			    break;
			  case DEC:
			    addLossByDec();
				break;
			  case INJ:
			    if ( lossByInjury) {
			    	lossByInjuryString += ";";
			    } else {
			    	lossByInjury=true;
			    	lossByInjuryString= "Loss by Injury on ";
			    }
			    if ( b.getMatchDate() != null ) {
			    	lossByInjuryString += b.getMatchDate();
			    	lossByInjuryString += " ";
			    }
			    lossByInjuryString += " vs ";
			    lossByInjuryString += b.getOpponentTeam();
			    
			    break;
			  case DQ:
			    break;
		  }		  
       }		  
	}
	public void addWin() { wins++; }
	public void addLoss() { losses++; }
	public void addWinByFFT() { winByFFT++; }
	public void addWinByFall() { winByFall++; }
	public void addWinByTech() { winByTech++; }
	public void addWinByMD() { winByMD++; }
	public void addWinByDec() { winByDec++; }
	
	public void addLossByFFT() { lossByFFT++; }
	public void addLossByFall() { lossByFall++; }
	public void addLossByTech() { lossByTech++; }
	public void addLossByMD() { lossByMD++; }
	public void addLossByDec() { lossByDec++; }

	public boolean equals(Object o) {
	  if ( o == null ) { return false; }
	  if ( this == o ) { return true; }
	  if ( this.getClass() == o.getClass() ){
         Wrestler ow = (Wrestler) o;		  
	     if ( this.getName().equals(ow.getName()) && this.getTeamName().equals(ow.getTeamName())) {
			 return true;
	     }
	  }
	  return false; 
	}
	public int hashCode() {
		return getName().hashCode() + getTeamName().hashCode();
	}


public String getFinWeight() {
	String finWeight = "";
	boolean a = playedMatch();
	
	if(cert != null) {
		finWeight = cert;
	}
	else (this.cert == null&&this.playedMatch()== true){
		finWeight = getLowestWeightWrestled();
	}
	
	return finWeight;
}

public boolean playedMatch() {
	if (matchWeight == null) {
		return false;
}	
	return true;
}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-13 22:33:03.986
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-13 22:33:03.986
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-13 22:33:04.007
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package JuniorHigh;

import java.util.*;
import java.util.Enumeration;

/*
 *
 *  This is a class to holds an wrestler and all data pertaining to him/her.
 */
class Wrestler {
	private String name;
	private String seed;
	private String cert;
	private String teamName;
	private WrestlingLanguage.Grade grade;
	private WrestlingLanguage.Gender gender;
	private String trackRecord;
	private String trackWtClass;
	private boolean rosteredLastYear;
	private String trackLastYearWtClass;
	private String trackLastYearRecord;
	private WrestlingLanguage.Prestige prestigeLastYear;
	private WrestlingLanguage.Prestige prestige2YearsAgo;
	private WrestlingLanguage.Prestige prestige3YearsAgo;
	
	private Hashtable<String,Integer> matchesAtWeight=new Hashtable<String,Integer>();
	
	private int wins;
	private int losses;
	private boolean lossByInjury=false;
	private String lossByInjuryString;
	private int winByFFT;
	private int lossByFFT;

	private int winByFall;
	private int winByDec;
	private int winByMD;
	private int winByTech;
	
	private int lossByFall;
	private int lossByDec;
	private int lossByMD;
	private int lossByTech;
	
	private int weight;
	
	private Hashtable<Integer,Integer> matchWeight=new Hashtable<Integer,Integer>();

		
	private WeighInHistory wiHistory;
	
	/* These 2 attributes are used to force where we put the wrestler in the reporting
	 * order.
	 */
	private String forceWeight=null;  /* for reporting force the use of this weight class. */
	private Integer forceRank=null;  /* for reporting this is the rank order withing the weight class. */

	public void setLossByInjuryString(String s) {
		lossByInjuryString = s;
	}
	public String getLossByInjuryString() { return lossByInjuryString; }
	
	public String getLowestWeightWrestled() {
		int lowInt=99999;
		
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
			int i =  Integer.parseInt(key);
		    if (i < lowInt ) {
		    	lowInt = i;
		    }
		}
		return Integer.toString(lowInt);
	}
	public String getPrintWeight() {
		if ( forceWeight != null ) {
			if ( forceWeight.length() > 0 ) {
				return forceWeight;
			}
		}
		return getLowestWeightWrestled();
	}
	public int getPrintRank() {
		if (forceRank == null ) {
			return getWins() + getLosses();
		} else {
			return 100000 - forceRank.intValue();
		}
	}
	public String getForceWeight() { return forceWeight; }
	public Integer getForceRank() { return forceRank; }
	
	public void setWeight( int w ) { 
		if (matchWeight.containsKey(w)) {
			int val =matchWeight.get(w);
			matchWeight.put(w, val+1);
			
		}
		else {
		matchWeight.put(w, 1);	
		}
		
	}
	public String getWeight() {
		Enumeration<Integer> e = matchWeight.keys();
		String WeightString="";
		while (e.hasMoreElements()) {
			 
	            // Getting the key of a particular entry
	            int keyWeight = e.nextElement();
	            int valueCount = matchWeight.get(keyWeight);
	            
	            WeightString += Integer.toString(valueCount) + "@" + Integer.toString(keyWeight) + " - ";
	             
	          
	        }
		return WeightString;
		
	}


	
	public void setForceWeight( String w ) { forceWeight = w; }
	public void setForceRank ( Integer i ) { forceRank = i; }
	
	List<Bout> bouts = new ArrayList<Bout> ();

	public List<Bout> getBouts() { return bouts; }
	
	public boolean getLossByInjury() { return lossByInjury; }
	
	public WeighInHistory getWeighInHistory() { return wiHistory; }
	
	public void setWeighInHistory(WeighInHistory wih ) { wiHistory = wih; }

	public void setPrestigeLastYear(WrestlingLanguage.Prestige p) { prestigeLastYear = p; }
	public void setPrestige2YearsAgo(WrestlingLanguage.Prestige p) { prestige2YearsAgo= p; }
	public void setPrestige3YearsAgo(WrestlingLanguage.Prestige p) { prestige3YearsAgo = p; }

	public WrestlingLanguage.Prestige getPrestigeLastYear() { return prestigeLastYear; }
	public WrestlingLanguage.Prestige getPrestige2YearsAgo() { return prestige2YearsAgo; }
	public WrestlingLanguage.Prestige getPrestige3YearsAgo() { return prestige3YearsAgo; }

    public void printVerbose () {
		System.out.println( getName() + 
			" Grade<" + getGrade() + ">" + 
			" Seed<" + getSeed() + ">" +
			" Cert<" + getCert() + ">"); 
			//" Gender<" + getGender() + "> Wt<" + 
			//getTrackWtClass() + ">" + " (" + getWins() + "W-" + 
			//getLosses() + "L) Last Year=<" + rosteredLastYear + "> Last Year Record <" + trackLastYearRecord + ">" );
    }	   
	public String getRecordString() { 
		return String.valueOf(wins) + "-" + String.valueOf(losses); 
	}
	public String getRecordBreakdown() {
		String breakdownString = "";
		boolean addedWins=false;
		if ( getWins() > 0 ) {
			breakdownString += getWins() + "W[";
			if ( getWinByFall() > 0 ) {
				breakdownString += getWinByFall() + " Pin,";
				addedWins=true;
			}
			if ( getWinByTech() > 0 ) {
				breakdownString += getWinByTech() + " TF,";
				addedWins=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getWinByMD() + " MD,";
				addedWins=true;
			}
			if ( getWinByDec() > 0 ) {
				breakdownString += getWinByDec() + " Dec,";
				addedWins=true;
			}
			if ( getWinByFFT() > 0 ) {
				breakdownString += getWinByFFT() + " FFT,";
				addedWins=true;
			}
			if ( addedWins ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "0 W";
		}
		boolean addedLosses=false;
		if ( getLosses() > 0 ) {
			breakdownString += "-" + getLosses() + "L[";
			if ( getLossByFall() > 0 ) {
				breakdownString += getLossByFall() + " Pin,";
				addedLosses=true;
			}
			if ( getLossByTech() > 0 ) {
				breakdownString += getLossByTech() + " TF,";
				addedLosses=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getLossByMD() + " MD,";
				addedLosses=true;
			}
			if ( getLossByDec() > 0 ) {
				breakdownString += getLossByDec() + " Dec,";
				addedLosses=true;
			}
			
			if ( addedLosses ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "-0L";
		}
		if ( getWins() ==0 && getLosses() == 0 ) {
			return "";
		} else {
			return breakdownString +" - "+ getWeight();
		}
	}
	public String getName() { return name; }
	public String getSeed() { return seed; }
	public String getCert() { return cert; }
	public String getTeamName() { return teamName; }
	public WrestlingLanguage.Grade getGrade() { return grade; }
	public WrestlingLanguage.Gender getGender() { return gender; }
	public String getTrackRecord() { return trackRecord; }
	public String getTrackWtClass() { return trackWtClass; }
	
	public int getWins() { return wins; }
	public int getLosses() { return losses; }
	
	public int getWinByFFT() { return winByFFT; }
	public int getWinByFall() { return winByFall; }
	public int getWinByTech() { return winByTech; }
	public int getWinByMD() { return winByMD; }
	public int getWinByDec() { return winByDec; }
	
	public int getLossByFFT() { return lossByFFT; }
	public int getLossByFall() { return lossByFall; }
	public int getLossByTech() { return lossByTech; }
	public int getLossByMD() { return lossByMD; }
	public int getLossByDec() { return lossByDec; }
	
    public Wrestler(String n, String team){
		setName(n);
		setTeamName(team);
		return;
	}
	public boolean getRosteredLastYear() { return rosteredLastYear; }
	
	public void setRosteredLastYearOn() { rosteredLastYear = true; }
	public void setRosteredLastYearOff() { rosteredLastYear = false; }
	
	public String getTrackLastYearWtClass() { return trackLastYearWtClass; }
	public String getTrackLastYearRecord() { return trackLastYearRecord; }
	
	public void setTrackLastYearWtClass(String w) { 
		trackLastYearWtClass = w; 
	}
	public void setTrackLastYearRecord(String r) {
		trackLastYearRecord = r;
	}
	
	
	public void addBout(Bout b) {
		String cmd=b.getMatchDate();
		if (cmd == null ) {
			Event e = b.getEvent();
			if ( e != null ) {
				String sss = e.getEventTitle();
				if ( wiHistory != null ) {
					String s = wiHistory.findWeighInDate(sss);
					if ( s != null ) { 
						b.setMatchDate(s);
					}
				}
			}
		}	
		
		bouts.add(b);
		addToSummary(b);
		addToMatchesAtWeight(b);
	}
	private void addToMatchesAtWeight(Bout b) {
		String w=b.getWeight();
		Integer ct = matchesAtWeight.get(w);
		if ( ct != null ) {
			ct++;
			matchesAtWeight.replace(w,ct);
		} else {
			matchesAtWeight.put(w,1);
		}
		return;
	}
	public String getMatchesAtWeightString() {

		String byWt="";
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
	
			int ct = matchesAtWeight.get(key);
			if ( byWt.length() > 0 ) { byWt=byWt + ";" ; }
			byWt=byWt + ct + "@" + key;
		}
		return byWt;
	}
	
	public void setName( String n ) {
		name = n.strip();
	}
	public void setSeed( String n ) {
		seed = n.strip();
	}
	public void setCert( String n ) {
		cert = n.strip();
	}
	public void setTeamName( String team ) {
		teamName = team;
	}
	public void setGrade5() { grade = WrestlingLanguage.Grade.G5;	}
	public void setGrade6() { grade = WrestlingLanguage.Grade.G6;	}
	public void setGrade7() { grade = WrestlingLanguage.Grade.G7;	}
	public void setGrade8() { grade = WrestlingLanguage.Grade.G8;	}
	public void setGrade(WrestlingLanguage.Grade g ) { grade=g; }
	
	public void setGenderM() { gender = WrestlingLanguage.Gender.M;	}
	public void setGenderF() { gender = WrestlingLanguage.Gender.F;	}
	public void setGender(WrestlingLanguage.Gender g ) { gender = g; }
	
	public void setTrackRecord(String rec) {
		trackRecord = rec;
	}
	public void setTrackWtClass(String w ) {
		trackWtClass = w;
	}
	public String toString() {
		return "Wrestler:" + teamName + ":" + name  ;
	}
	private void addToSummary(Bout b) {
	   if ( b.isAWin() ) {
          addWin();	
          switch ( b.getMatchResultType() ) {
			  case FFT: 
			    addWinByFFT();
				break;
			  case FALL:
			    addWinByFall();
				break;
			  case TECH:
			    addWinByTech();
				break;
			  case MD:
			    addWinByMD();
			    break;
			  case DEC:
			    addWinByDec();
				break;
			  case INJ:
			    break;
			  case DQ:
			    break;
		  }
       } else {
          addLoss();
          switch ( b.getMatchResultType() ) {

          case FFT:
			  addLossByFFT();
			    break;
			  case FALL:
			    addLossByFall();
				break;
			  case TECH:
			    addLossByTech();
				break;
			  case MD:
			    addLossByMD();
			    break;
			  case DEC:
			    addLossByDec();
				break;
			  case INJ:
			    if ( lossByInjury) {
			    	lossByInjuryString += ";";
			    } else {
			    	lossByInjury=true;
			    	lossByInjuryString= "Loss by Injury on ";
			    }
			    if ( b.getMatchDate() != null ) {
			    	lossByInjuryString += b.getMatchDate();
			    	lossByInjuryString += " ";
			    }
			    lossByInjuryString += " vs ";
			    lossByInjuryString += b.getOpponentTeam();
			    
			    break;
			  case DQ:
			    break;
		  }		  
       }		  
	}
	public void addWin() { wins++; }
	public void addLoss() { losses++; }
	public void addWinByFFT() { winByFFT++; }
	public void addWinByFall() { winByFall++; }
	public void addWinByTech() { winByTech++; }
	public void addWinByMD() { winByMD++; }
	public void addWinByDec() { winByDec++; }
	
	public void addLossByFFT() { lossByFFT++; }
	public void addLossByFall() { lossByFall++; }
	public void addLossByTech() { lossByTech++; }
	public void addLossByMD() { lossByMD++; }
	public void addLossByDec() { lossByDec++; }

	public boolean equals(Object o) {
	  if ( o == null ) { return false; }
	  if ( this == o ) { return true; }
	  if ( this.getClass() == o.getClass() ){
         Wrestler ow = (Wrestler) o;		  
	     if ( this.getName().equals(ow.getName()) && this.getTeamName().equals(ow.getTeamName())) {
			 return true;
	     }
	  }
	  return false; 
	}
	public int hashCode() {
		return getName().hashCode() + getTeamName().hashCode();
	}


public String getFinWeight() {
	String finWeight = "";
	boolean a = playedMatch();
	
	if(cert != null) {
		finWeight = cert;
	}
	else (this.cert == null&&this.playedMatch()== true){
		finWeight = getLowestWeightWrestled();
	}
	
	return finWeight;
}

public boolean playedMatch() {
	if (matchWeight == null) {
		return false;
}	
	return true;
}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-13 22:33:04.008
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-13 22:33:04.008
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-13 22:33:06.158
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package JuniorHigh;

import java.util.*;
import java.util.Enumeration;

/*
 *
 *  This is a class to holds an wrestler and all data pertaining to him/her.
 */
class Wrestler {
	private String name;
	private String seed;
	private String cert;
	private String teamName;
	private WrestlingLanguage.Grade grade;
	private WrestlingLanguage.Gender gender;
	private String trackRecord;
	private String trackWtClass;
	private boolean rosteredLastYear;
	private String trackLastYearWtClass;
	private String trackLastYearRecord;
	private WrestlingLanguage.Prestige prestigeLastYear;
	private WrestlingLanguage.Prestige prestige2YearsAgo;
	private WrestlingLanguage.Prestige prestige3YearsAgo;
	
	private Hashtable<String,Integer> matchesAtWeight=new Hashtable<String,Integer>();
	
	private int wins;
	private int losses;
	private boolean lossByInjury=false;
	private String lossByInjuryString;
	private int winByFFT;
	private int lossByFFT;

	private int winByFall;
	private int winByDec;
	private int winByMD;
	private int winByTech;
	
	private int lossByFall;
	private int lossByDec;
	private int lossByMD;
	private int lossByTech;
	
	private int weight;
	
	private Hashtable<Integer,Integer> matchWeight=new Hashtable<Integer,Integer>();

		
	private WeighInHistory wiHistory;
	
	/* These 2 attributes are used to force where we put the wrestler in the reporting
	 * order.
	 */
	private String forceWeight=null;  /* for reporting force the use of this weight class. */
	private Integer forceRank=null;  /* for reporting this is the rank order withing the weight class. */

	public void setLossByInjuryString(String s) {
		lossByInjuryString = s;
	}
	public String getLossByInjuryString() { return lossByInjuryString; }
	
	public String getLowestWeightWrestled() {
		int lowInt=99999;
		
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
			int i =  Integer.parseInt(key);
		    if (i < lowInt ) {
		    	lowInt = i;
		    }
		}
		return Integer.toString(lowInt);
	}
	public String getPrintWeight() {
		if ( forceWeight != null ) {
			if ( forceWeight.length() > 0 ) {
				return forceWeight;
			}
		}
		return getLowestWeightWrestled();
	}
	public int getPrintRank() {
		if (forceRank == null ) {
			return getWins() + getLosses();
		} else {
			return 100000 - forceRank.intValue();
		}
	}
	public String getForceWeight() { return forceWeight; }
	public Integer getForceRank() { return forceRank; }
	
	public void setWeight( int w ) { 
		if (matchWeight.containsKey(w)) {
			int val =matchWeight.get(w);
			matchWeight.put(w, val+1);
			
		}
		else {
		matchWeight.put(w, 1);	
		}
		
	}
	public String getWeight() {
		Enumeration<Integer> e = matchWeight.keys();
		String WeightString="";
		while (e.hasMoreElements()) {
			 
	            // Getting the key of a particular entry
	            int keyWeight = e.nextElement();
	            int valueCount = matchWeight.get(keyWeight);
	            
	            WeightString += Integer.toString(valueCount) + "@" + Integer.toString(keyWeight) + " - ";
	             
	          
	        }
		return WeightString;
		
	}


	
	public void setForceWeight( String w ) { forceWeight = w; }
	public void setForceRank ( Integer i ) { forceRank = i; }
	
	List<Bout> bouts = new ArrayList<Bout> ();

	public List<Bout> getBouts() { return bouts; }
	
	public boolean getLossByInjury() { return lossByInjury; }
	
	public WeighInHistory getWeighInHistory() { return wiHistory; }
	
	public void setWeighInHistory(WeighInHistory wih ) { wiHistory = wih; }

	public void setPrestigeLastYear(WrestlingLanguage.Prestige p) { prestigeLastYear = p; }
	public void setPrestige2YearsAgo(WrestlingLanguage.Prestige p) { prestige2YearsAgo= p; }
	public void setPrestige3YearsAgo(WrestlingLanguage.Prestige p) { prestige3YearsAgo = p; }

	public WrestlingLanguage.Prestige getPrestigeLastYear() { return prestigeLastYear; }
	public WrestlingLanguage.Prestige getPrestige2YearsAgo() { return prestige2YearsAgo; }
	public WrestlingLanguage.Prestige getPrestige3YearsAgo() { return prestige3YearsAgo; }

    public void printVerbose () {
		System.out.println( getName() + 
			" Grade<" + getGrade() + ">" + 
			" Seed<" + getSeed() + ">" +
			" Cert<" + getCert() + ">"); 
			//" Gender<" + getGender() + "> Wt<" + 
			//getTrackWtClass() + ">" + " (" + getWins() + "W-" + 
			//getLosses() + "L) Last Year=<" + rosteredLastYear + "> Last Year Record <" + trackLastYearRecord + ">" );
    }	   
	public String getRecordString() { 
		return String.valueOf(wins) + "-" + String.valueOf(losses); 
	}
	public String getRecordBreakdown() {
		String breakdownString = "";
		boolean addedWins=false;
		if ( getWins() > 0 ) {
			breakdownString += getWins() + "W[";
			if ( getWinByFall() > 0 ) {
				breakdownString += getWinByFall() + " Pin,";
				addedWins=true;
			}
			if ( getWinByTech() > 0 ) {
				breakdownString += getWinByTech() + " TF,";
				addedWins=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getWinByMD() + " MD,";
				addedWins=true;
			}
			if ( getWinByDec() > 0 ) {
				breakdownString += getWinByDec() + " Dec,";
				addedWins=true;
			}
			if ( getWinByFFT() > 0 ) {
				breakdownString += getWinByFFT() + " FFT,";
				addedWins=true;
			}
			if ( addedWins ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "0 W";
		}
		boolean addedLosses=false;
		if ( getLosses() > 0 ) {
			breakdownString += "-" + getLosses() + "L[";
			if ( getLossByFall() > 0 ) {
				breakdownString += getLossByFall() + " Pin,";
				addedLosses=true;
			}
			if ( getLossByTech() > 0 ) {
				breakdownString += getLossByTech() + " TF,";
				addedLosses=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getLossByMD() + " MD,";
				addedLosses=true;
			}
			if ( getLossByDec() > 0 ) {
				breakdownString += getLossByDec() + " Dec,";
				addedLosses=true;
			}
			
			if ( addedLosses ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "-0L";
		}
		if ( getWins() ==0 && getLosses() == 0 ) {
			return "";
		} else {
			return breakdownString +" - "+ getWeight();
		}
	}
	public String getName() { return name; }
	public String getSeed() { return seed; }
	public String getCert() { return cert; }
	public String getTeamName() { return teamName; }
	public WrestlingLanguage.Grade getGrade() { return grade; }
	public WrestlingLanguage.Gender getGender() { return gender; }
	public String getTrackRecord() { return trackRecord; }
	public String getTrackWtClass() { return trackWtClass; }
	
	public int getWins() { return wins; }
	public int getLosses() { return losses; }
	
	public int getWinByFFT() { return winByFFT; }
	public int getWinByFall() { return winByFall; }
	public int getWinByTech() { return winByTech; }
	public int getWinByMD() { return winByMD; }
	public int getWinByDec() { return winByDec; }
	
	public int getLossByFFT() { return lossByFFT; }
	public int getLossByFall() { return lossByFall; }
	public int getLossByTech() { return lossByTech; }
	public int getLossByMD() { return lossByMD; }
	public int getLossByDec() { return lossByDec; }
	
    public Wrestler(String n, String team){
		setName(n);
		setTeamName(team);
		return;
	}
	public boolean getRosteredLastYear() { return rosteredLastYear; }
	
	public void setRosteredLastYearOn() { rosteredLastYear = true; }
	public void setRosteredLastYearOff() { rosteredLastYear = false; }
	
	public String getTrackLastYearWtClass() { return trackLastYearWtClass; }
	public String getTrackLastYearRecord() { return trackLastYearRecord; }
	
	public void setTrackLastYearWtClass(String w) { 
		trackLastYearWtClass = w; 
	}
	public void setTrackLastYearRecord(String r) {
		trackLastYearRecord = r;
	}
	
	
	public void addBout(Bout b) {
		String cmd=b.getMatchDate();
		if (cmd == null ) {
			Event e = b.getEvent();
			if ( e != null ) {
				String sss = e.getEventTitle();
				if ( wiHistory != null ) {
					String s = wiHistory.findWeighInDate(sss);
					if ( s != null ) { 
						b.setMatchDate(s);
					}
				}
			}
		}	
		
		bouts.add(b);
		addToSummary(b);
		addToMatchesAtWeight(b);
	}
	private void addToMatchesAtWeight(Bout b) {
		String w=b.getWeight();
		Integer ct = matchesAtWeight.get(w);
		if ( ct != null ) {
			ct++;
			matchesAtWeight.replace(w,ct);
		} else {
			matchesAtWeight.put(w,1);
		}
		return;
	}
	public String getMatchesAtWeightString() {

		String byWt="";
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
	
			int ct = matchesAtWeight.get(key);
			if ( byWt.length() > 0 ) { byWt=byWt + ";" ; }
			byWt=byWt + ct + "@" + key;
		}
		return byWt;
	}
	
	public void setName( String n ) {
		name = n.strip();
	}
	public void setSeed( String n ) {
		seed = n.strip();
	}
	public void setCert( String n ) {
		cert = n.strip();
	}
	public void setTeamName( String team ) {
		teamName = team;
	}
	public void setGrade5() { grade = WrestlingLanguage.Grade.G5;	}
	public void setGrade6() { grade = WrestlingLanguage.Grade.G6;	}
	public void setGrade7() { grade = WrestlingLanguage.Grade.G7;	}
	public void setGrade8() { grade = WrestlingLanguage.Grade.G8;	}
	public void setGrade(WrestlingLanguage.Grade g ) { grade=g; }
	
	public void setGenderM() { gender = WrestlingLanguage.Gender.M;	}
	public void setGenderF() { gender = WrestlingLanguage.Gender.F;	}
	public void setGender(WrestlingLanguage.Gender g ) { gender = g; }
	
	public void setTrackRecord(String rec) {
		trackRecord = rec;
	}
	public void setTrackWtClass(String w ) {
		trackWtClass = w;
	}
	public String toString() {
		return "Wrestler:" + teamName + ":" + name  ;
	}
	private void addToSummary(Bout b) {
	   if ( b.isAWin() ) {
          addWin();	
          switch ( b.getMatchResultType() ) {
			  case FFT: 
			    addWinByFFT();
				break;
			  case FALL:
			    addWinByFall();
				break;
			  case TECH:
			    addWinByTech();
				break;
			  case MD:
			    addWinByMD();
			    break;
			  case DEC:
			    addWinByDec();
				break;
			  case INJ:
			    break;
			  case DQ:
			    break;
		  }
       } else {
          addLoss();
          switch ( b.getMatchResultType() ) {

          case FFT:
			  addLossByFFT();
			    break;
			  case FALL:
			    addLossByFall();
				break;
			  case TECH:
			    addLossByTech();
				break;
			  case MD:
			    addLossByMD();
			    break;
			  case DEC:
			    addLossByDec();
				break;
			  case INJ:
			    if ( lossByInjury) {
			    	lossByInjuryString += ";";
			    } else {
			    	lossByInjury=true;
			    	lossByInjuryString= "Loss by Injury on ";
			    }
			    if ( b.getMatchDate() != null ) {
			    	lossByInjuryString += b.getMatchDate();
			    	lossByInjuryString += " ";
			    }
			    lossByInjuryString += " vs ";
			    lossByInjuryString += b.getOpponentTeam();
			    
			    break;
			  case DQ:
			    break;
		  }		  
       }		  
	}
	public void addWin() { wins++; }
	public void addLoss() { losses++; }
	public void addWinByFFT() { winByFFT++; }
	public void addWinByFall() { winByFall++; }
	public void addWinByTech() { winByTech++; }
	public void addWinByMD() { winByMD++; }
	public void addWinByDec() { winByDec++; }
	
	public void addLossByFFT() { lossByFFT++; }
	public void addLossByFall() { lossByFall++; }
	public void addLossByTech() { lossByTech++; }
	public void addLossByMD() { lossByMD++; }
	public void addLossByDec() { lossByDec++; }

	public boolean equals(Object o) {
	  if ( o == null ) { return false; }
	  if ( this == o ) { return true; }
	  if ( this.getClass() == o.getClass() ){
         Wrestler ow = (Wrestler) o;		  
	     if ( this.getName().equals(ow.getName()) && this.getTeamName().equals(ow.getTeamName())) {
			 return true;
	     }
	  }
	  return false; 
	}
	public int hashCode() {
		return getName().hashCode() + getTeamName().hashCode();
	}


public String getFinWeight() {
	String finWeight = "";
	boolean a = playedMatch();
	
	if(cert != null) {
		finWeight = cert;
	}
	else (this.cert == null&&this.playedMatch()== true){
		finWeight = getLowestWeightWrestled();
	}
	
	return finWeight;
}

public boolean playedMatch() {
	if (matchWeight == null) {
		return false;
}	
	return true;
}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-13 22:33:06.159
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-13 22:33:06.159
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-13 22:33:08.358
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package JuniorHigh;

import java.util.*;
import java.util.Enumeration;

/*
 *
 *  This is a class to holds an wrestler and all data pertaining to him/her.
 */
class Wrestler {
	private String name;
	private String seed;
	private String cert;
	private String teamName;
	private WrestlingLanguage.Grade grade;
	private WrestlingLanguage.Gender gender;
	private String trackRecord;
	private String trackWtClass;
	private boolean rosteredLastYear;
	private String trackLastYearWtClass;
	private String trackLastYearRecord;
	private WrestlingLanguage.Prestige prestigeLastYear;
	private WrestlingLanguage.Prestige prestige2YearsAgo;
	private WrestlingLanguage.Prestige prestige3YearsAgo;
	
	private Hashtable<String,Integer> matchesAtWeight=new Hashtable<String,Integer>();
	
	private int wins;
	private int losses;
	private boolean lossByInjury=false;
	private String lossByInjuryString;
	private int winByFFT;
	private int lossByFFT;

	private int winByFall;
	private int winByDec;
	private int winByMD;
	private int winByTech;
	
	private int lossByFall;
	private int lossByDec;
	private int lossByMD;
	private int lossByTech;
	
	private int weight;
	
	private Hashtable<Integer,Integer> matchWeight=new Hashtable<Integer,Integer>();

		
	private WeighInHistory wiHistory;
	
	/* These 2 attributes are used to force where we put the wrestler in the reporting
	 * order.
	 */
	private String forceWeight=null;  /* for reporting force the use of this weight class. */
	private Integer forceRank=null;  /* for reporting this is the rank order withing the weight class. */

	public void setLossByInjuryString(String s) {
		lossByInjuryString = s;
	}
	public String getLossByInjuryString() { return lossByInjuryString; }
	
	public String getLowestWeightWrestled() {
		int lowInt=99999;
		
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
			int i =  Integer.parseInt(key);
		    if (i < lowInt ) {
		    	lowInt = i;
		    }
		}
		return Integer.toString(lowInt);
	}
	public String getPrintWeight() {
		if ( forceWeight != null ) {
			if ( forceWeight.length() > 0 ) {
				return forceWeight;
			}
		}
		return getLowestWeightWrestled();
	}
	public int getPrintRank() {
		if (forceRank == null ) {
			return getWins() + getLosses();
		} else {
			return 100000 - forceRank.intValue();
		}
	}
	public String getForceWeight() { return forceWeight; }
	public Integer getForceRank() { return forceRank; }
	
	public void setWeight( int w ) { 
		if (matchWeight.containsKey(w)) {
			int val =matchWeight.get(w);
			matchWeight.put(w, val+1);
			
		}
		else {
		matchWeight.put(w, 1);	
		}
		
	}
	public String getWeight() {
		Enumeration<Integer> e = matchWeight.keys();
		String WeightString="";
		while (e.hasMoreElements()) {
			 
	            // Getting the key of a particular entry
	            int keyWeight = e.nextElement();
	            int valueCount = matchWeight.get(keyWeight);
	            
	            WeightString += Integer.toString(valueCount) + "@" + Integer.toString(keyWeight) + " - ";
	             
	          
	        }
		return WeightString;
		
	}


	
	public void setForceWeight( String w ) { forceWeight = w; }
	public void setForceRank ( Integer i ) { forceRank = i; }
	
	List<Bout> bouts = new ArrayList<Bout> ();

	public List<Bout> getBouts() { return bouts; }
	
	public boolean getLossByInjury() { return lossByInjury; }
	
	public WeighInHistory getWeighInHistory() { return wiHistory; }
	
	public void setWeighInHistory(WeighInHistory wih ) { wiHistory = wih; }

	public void setPrestigeLastYear(WrestlingLanguage.Prestige p) { prestigeLastYear = p; }
	public void setPrestige2YearsAgo(WrestlingLanguage.Prestige p) { prestige2YearsAgo= p; }
	public void setPrestige3YearsAgo(WrestlingLanguage.Prestige p) { prestige3YearsAgo = p; }

	public WrestlingLanguage.Prestige getPrestigeLastYear() { return prestigeLastYear; }
	public WrestlingLanguage.Prestige getPrestige2YearsAgo() { return prestige2YearsAgo; }
	public WrestlingLanguage.Prestige getPrestige3YearsAgo() { return prestige3YearsAgo; }

    public void printVerbose () {
		System.out.println( getName() + 
			" Grade<" + getGrade() + ">" + 
			" Seed<" + getSeed() + ">" +
			" Cert<" + getCert() + ">"); 
			//" Gender<" + getGender() + "> Wt<" + 
			//getTrackWtClass() + ">" + " (" + getWins() + "W-" + 
			//getLosses() + "L) Last Year=<" + rosteredLastYear + "> Last Year Record <" + trackLastYearRecord + ">" );
    }	   
	public String getRecordString() { 
		return String.valueOf(wins) + "-" + String.valueOf(losses); 
	}
	public String getRecordBreakdown() {
		String breakdownString = "";
		boolean addedWins=false;
		if ( getWins() > 0 ) {
			breakdownString += getWins() + "W[";
			if ( getWinByFall() > 0 ) {
				breakdownString += getWinByFall() + " Pin,";
				addedWins=true;
			}
			if ( getWinByTech() > 0 ) {
				breakdownString += getWinByTech() + " TF,";
				addedWins=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getWinByMD() + " MD,";
				addedWins=true;
			}
			if ( getWinByDec() > 0 ) {
				breakdownString += getWinByDec() + " Dec,";
				addedWins=true;
			}
			if ( getWinByFFT() > 0 ) {
				breakdownString += getWinByFFT() + " FFT,";
				addedWins=true;
			}
			if ( addedWins ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "0 W";
		}
		boolean addedLosses=false;
		if ( getLosses() > 0 ) {
			breakdownString += "-" + getLosses() + "L[";
			if ( getLossByFall() > 0 ) {
				breakdownString += getLossByFall() + " Pin,";
				addedLosses=true;
			}
			if ( getLossByTech() > 0 ) {
				breakdownString += getLossByTech() + " TF,";
				addedLosses=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getLossByMD() + " MD,";
				addedLosses=true;
			}
			if ( getLossByDec() > 0 ) {
				breakdownString += getLossByDec() + " Dec,";
				addedLosses=true;
			}
			
			if ( addedLosses ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "-0L";
		}
		if ( getWins() ==0 && getLosses() == 0 ) {
			return "";
		} else {
			return breakdownString +" - "+ getWeight();
		}
	}
	public String getName() { return name; }
	public String getSeed() { return seed; }
	public String getCert() { return cert; }
	public String getTeamName() { return teamName; }
	public WrestlingLanguage.Grade getGrade() { return grade; }
	public WrestlingLanguage.Gender getGender() { return gender; }
	public String getTrackRecord() { return trackRecord; }
	public String getTrackWtClass() { return trackWtClass; }
	
	public int getWins() { return wins; }
	public int getLosses() { return losses; }
	
	public int getWinByFFT() { return winByFFT; }
	public int getWinByFall() { return winByFall; }
	public int getWinByTech() { return winByTech; }
	public int getWinByMD() { return winByMD; }
	public int getWinByDec() { return winByDec; }
	
	public int getLossByFFT() { return lossByFFT; }
	public int getLossByFall() { return lossByFall; }
	public int getLossByTech() { return lossByTech; }
	public int getLossByMD() { return lossByMD; }
	public int getLossByDec() { return lossByDec; }
	
    public Wrestler(String n, String team){
		setName(n);
		setTeamName(team);
		return;
	}
	public boolean getRosteredLastYear() { return rosteredLastYear; }
	
	public void setRosteredLastYearOn() { rosteredLastYear = true; }
	public void setRosteredLastYearOff() { rosteredLastYear = false; }
	
	public String getTrackLastYearWtClass() { return trackLastYearWtClass; }
	public String getTrackLastYearRecord() { return trackLastYearRecord; }
	
	public void setTrackLastYearWtClass(String w) { 
		trackLastYearWtClass = w; 
	}
	public void setTrackLastYearRecord(String r) {
		trackLastYearRecord = r;
	}
	
	
	public void addBout(Bout b) {
		String cmd=b.getMatchDate();
		if (cmd == null ) {
			Event e = b.getEvent();
			if ( e != null ) {
				String sss = e.getEventTitle();
				if ( wiHistory != null ) {
					String s = wiHistory.findWeighInDate(sss);
					if ( s != null ) { 
						b.setMatchDate(s);
					}
				}
			}
		}	
		
		bouts.add(b);
		addToSummary(b);
		addToMatchesAtWeight(b);
	}
	private void addToMatchesAtWeight(Bout b) {
		String w=b.getWeight();
		Integer ct = matchesAtWeight.get(w);
		if ( ct != null ) {
			ct++;
			matchesAtWeight.replace(w,ct);
		} else {
			matchesAtWeight.put(w,1);
		}
		return;
	}
	public String getMatchesAtWeightString() {

		String byWt="";
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
	
			int ct = matchesAtWeight.get(key);
			if ( byWt.length() > 0 ) { byWt=byWt + ";" ; }
			byWt=byWt + ct + "@" + key;
		}
		return byWt;
	}
	
	public void setName( String n ) {
		name = n.strip();
	}
	public void setSeed( String n ) {
		seed = n.strip();
	}
	public void setCert( String n ) {
		cert = n.strip();
	}
	public void setTeamName( String team ) {
		teamName = team;
	}
	public void setGrade5() { grade = WrestlingLanguage.Grade.G5;	}
	public void setGrade6() { grade = WrestlingLanguage.Grade.G6;	}
	public void setGrade7() { grade = WrestlingLanguage.Grade.G7;	}
	public void setGrade8() { grade = WrestlingLanguage.Grade.G8;	}
	public void setGrade(WrestlingLanguage.Grade g ) { grade=g; }
	
	public void setGenderM() { gender = WrestlingLanguage.Gender.M;	}
	public void setGenderF() { gender = WrestlingLanguage.Gender.F;	}
	public void setGender(WrestlingLanguage.Gender g ) { gender = g; }
	
	public void setTrackRecord(String rec) {
		trackRecord = rec;
	}
	public void setTrackWtClass(String w ) {
		trackWtClass = w;
	}
	public String toString() {
		return "Wrestler:" + teamName + ":" + name  ;
	}
	private void addToSummary(Bout b) {
	   if ( b.isAWin() ) {
          addWin();	
          switch ( b.getMatchResultType() ) {
			  case FFT: 
			    addWinByFFT();
				break;
			  case FALL:
			    addWinByFall();
				break;
			  case TECH:
			    addWinByTech();
				break;
			  case MD:
			    addWinByMD();
			    break;
			  case DEC:
			    addWinByDec();
				break;
			  case INJ:
			    break;
			  case DQ:
			    break;
		  }
       } else {
          addLoss();
          switch ( b.getMatchResultType() ) {

          case FFT:
			  addLossByFFT();
			    break;
			  case FALL:
			    addLossByFall();
				break;
			  case TECH:
			    addLossByTech();
				break;
			  case MD:
			    addLossByMD();
			    break;
			  case DEC:
			    addLossByDec();
				break;
			  case INJ:
			    if ( lossByInjury) {
			    	lossByInjuryString += ";";
			    } else {
			    	lossByInjury=true;
			    	lossByInjuryString= "Loss by Injury on ";
			    }
			    if ( b.getMatchDate() != null ) {
			    	lossByInjuryString += b.getMatchDate();
			    	lossByInjuryString += " ";
			    }
			    lossByInjuryString += " vs ";
			    lossByInjuryString += b.getOpponentTeam();
			    
			    break;
			  case DQ:
			    break;
		  }		  
       }		  
	}
	public void addWin() { wins++; }
	public void addLoss() { losses++; }
	public void addWinByFFT() { winByFFT++; }
	public void addWinByFall() { winByFall++; }
	public void addWinByTech() { winByTech++; }
	public void addWinByMD() { winByMD++; }
	public void addWinByDec() { winByDec++; }
	
	public void addLossByFFT() { lossByFFT++; }
	public void addLossByFall() { lossByFall++; }
	public void addLossByTech() { lossByTech++; }
	public void addLossByMD() { lossByMD++; }
	public void addLossByDec() { lossByDec++; }

	public boolean equals(Object o) {
	  if ( o == null ) { return false; }
	  if ( this == o ) { return true; }
	  if ( this.getClass() == o.getClass() ){
         Wrestler ow = (Wrestler) o;		  
	     if ( this.getName().equals(ow.getName()) && this.getTeamName().equals(ow.getTeamName())) {
			 return true;
	     }
	  }
	  return false; 
	}
	public int hashCode() {
		return getName().hashCode() + getTeamName().hashCode();
	}


public String getFinWeight() {
	String finWeight = "";
	boolean a = playedMatch();
	
	if(cert != null) {
		finWeight = cert;
	}
	else (this.cert == null&&this.playedMatch()== true){
		finWeight = thgetLowestWeightWrestled();
	}
	
	return finWeight;
}

public boolean playedMatch() {
	if (matchWeight == null) {
		return false;
}	
	return true;
}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-10-13 22:33:08.359
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-10-13 22:33:08.359
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-13 22:33:08.375
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package JuniorHigh;

import java.util.*;
import java.util.Enumeration;

/*
 *
 *  This is a class to holds an wrestler and all data pertaining to him/her.
 */
class Wrestler {
	private String name;
	private String seed;
	private String cert;
	private String teamName;
	private WrestlingLanguage.Grade grade;
	private WrestlingLanguage.Gender gender;
	private String trackRecord;
	private String trackWtClass;
	private boolean rosteredLastYear;
	private String trackLastYearWtClass;
	private String trackLastYearRecord;
	private WrestlingLanguage.Prestige prestigeLastYear;
	private WrestlingLanguage.Prestige prestige2YearsAgo;
	private WrestlingLanguage.Prestige prestige3YearsAgo;
	
	private Hashtable<String,Integer> matchesAtWeight=new Hashtable<String,Integer>();
	
	private int wins;
	private int losses;
	private boolean lossByInjury=false;
	private String lossByInjuryString;
	private int winByFFT;
	private int lossByFFT;

	private int winByFall;
	private int winByDec;
	private int winByMD;
	private int winByTech;
	
	private int lossByFall;
	private int lossByDec;
	private int lossByMD;
	private int lossByTech;
	
	private int weight;
	
	private Hashtable<Integer,Integer> matchWeight=new Hashtable<Integer,Integer>();

		
	private WeighInHistory wiHistory;
	
	/* These 2 attributes are used to force where we put the wrestler in the reporting
	 * order.
	 */
	private String forceWeight=null;  /* for reporting force the use of this weight class. */
	private Integer forceRank=null;  /* for reporting this is the rank order withing the weight class. */

	public void setLossByInjuryString(String s) {
		lossByInjuryString = s;
	}
	public String getLossByInjuryString() { return lossByInjuryString; }
	
	public String getLowestWeightWrestled() {
		int lowInt=99999;
		
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
			int i =  Integer.parseInt(key);
		    if (i < lowInt ) {
		    	lowInt = i;
		    }
		}
		return Integer.toString(lowInt);
	}
	public String getPrintWeight() {
		if ( forceWeight != null ) {
			if ( forceWeight.length() > 0 ) {
				return forceWeight;
			}
		}
		return getLowestWeightWrestled();
	}
	public int getPrintRank() {
		if (forceRank == null ) {
			return getWins() + getLosses();
		} else {
			return 100000 - forceRank.intValue();
		}
	}
	public String getForceWeight() { return forceWeight; }
	public Integer getForceRank() { return forceRank; }
	
	public void setWeight( int w ) { 
		if (matchWeight.containsKey(w)) {
			int val =matchWeight.get(w);
			matchWeight.put(w, val+1);
			
		}
		else {
		matchWeight.put(w, 1);	
		}
		
	}
	public String getWeight() {
		Enumeration<Integer> e = matchWeight.keys();
		String WeightString="";
		while (e.hasMoreElements()) {
			 
	            // Getting the key of a particular entry
	            int keyWeight = e.nextElement();
	            int valueCount = matchWeight.get(keyWeight);
	            
	            WeightString += Integer.toString(valueCount) + "@" + Integer.toString(keyWeight) + " - ";
	             
	          
	        }
		return WeightString;
		
	}


	
	public void setForceWeight( String w ) { forceWeight = w; }
	public void setForceRank ( Integer i ) { forceRank = i; }
	
	List<Bout> bouts = new ArrayList<Bout> ();

	public List<Bout> getBouts() { return bouts; }
	
	public boolean getLossByInjury() { return lossByInjury; }
	
	public WeighInHistory getWeighInHistory() { return wiHistory; }
	
	public void setWeighInHistory(WeighInHistory wih ) { wiHistory = wih; }

	public void setPrestigeLastYear(WrestlingLanguage.Prestige p) { prestigeLastYear = p; }
	public void setPrestige2YearsAgo(WrestlingLanguage.Prestige p) { prestige2YearsAgo= p; }
	public void setPrestige3YearsAgo(WrestlingLanguage.Prestige p) { prestige3YearsAgo = p; }

	public WrestlingLanguage.Prestige getPrestigeLastYear() { return prestigeLastYear; }
	public WrestlingLanguage.Prestige getPrestige2YearsAgo() { return prestige2YearsAgo; }
	public WrestlingLanguage.Prestige getPrestige3YearsAgo() { return prestige3YearsAgo; }

    public void printVerbose () {
		System.out.println( getName() + 
			" Grade<" + getGrade() + ">" + 
			" Seed<" + getSeed() + ">" +
			" Cert<" + getCert() + ">"); 
			//" Gender<" + getGender() + "> Wt<" + 
			//getTrackWtClass() + ">" + " (" + getWins() + "W-" + 
			//getLosses() + "L) Last Year=<" + rosteredLastYear + "> Last Year Record <" + trackLastYearRecord + ">" );
    }	   
	public String getRecordString() { 
		return String.valueOf(wins) + "-" + String.valueOf(losses); 
	}
	public String getRecordBreakdown() {
		String breakdownString = "";
		boolean addedWins=false;
		if ( getWins() > 0 ) {
			breakdownString += getWins() + "W[";
			if ( getWinByFall() > 0 ) {
				breakdownString += getWinByFall() + " Pin,";
				addedWins=true;
			}
			if ( getWinByTech() > 0 ) {
				breakdownString += getWinByTech() + " TF,";
				addedWins=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getWinByMD() + " MD,";
				addedWins=true;
			}
			if ( getWinByDec() > 0 ) {
				breakdownString += getWinByDec() + " Dec,";
				addedWins=true;
			}
			if ( getWinByFFT() > 0 ) {
				breakdownString += getWinByFFT() + " FFT,";
				addedWins=true;
			}
			if ( addedWins ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "0 W";
		}
		boolean addedLosses=false;
		if ( getLosses() > 0 ) {
			breakdownString += "-" + getLosses() + "L[";
			if ( getLossByFall() > 0 ) {
				breakdownString += getLossByFall() + " Pin,";
				addedLosses=true;
			}
			if ( getLossByTech() > 0 ) {
				breakdownString += getLossByTech() + " TF,";
				addedLosses=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getLossByMD() + " MD,";
				addedLosses=true;
			}
			if ( getLossByDec() > 0 ) {
				breakdownString += getLossByDec() + " Dec,";
				addedLosses=true;
			}
			
			if ( addedLosses ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "-0L";
		}
		if ( getWins() ==0 && getLosses() == 0 ) {
			return "";
		} else {
			return breakdownString +" - "+ getWeight();
		}
	}
	public String getName() { return name; }
	public String getSeed() { return seed; }
	public String getCert() { return cert; }
	public String getTeamName() { return teamName; }
	public WrestlingLanguage.Grade getGrade() { return grade; }
	public WrestlingLanguage.Gender getGender() { return gender; }
	public String getTrackRecord() { return trackRecord; }
	public String getTrackWtClass() { return trackWtClass; }
	
	public int getWins() { return wins; }
	public int getLosses() { return losses; }
	
	public int getWinByFFT() { return winByFFT; }
	public int getWinByFall() { return winByFall; }
	public int getWinByTech() { return winByTech; }
	public int getWinByMD() { return winByMD; }
	public int getWinByDec() { return winByDec; }
	
	public int getLossByFFT() { return lossByFFT; }
	public int getLossByFall() { return lossByFall; }
	public int getLossByTech() { return lossByTech; }
	public int getLossByMD() { return lossByMD; }
	public int getLossByDec() { return lossByDec; }
	
    public Wrestler(String n, String team){
		setName(n);
		setTeamName(team);
		return;
	}
	public boolean getRosteredLastYear() { return rosteredLastYear; }
	
	public void setRosteredLastYearOn() { rosteredLastYear = true; }
	public void setRosteredLastYearOff() { rosteredLastYear = false; }
	
	public String getTrackLastYearWtClass() { return trackLastYearWtClass; }
	public String getTrackLastYearRecord() { return trackLastYearRecord; }
	
	public void setTrackLastYearWtClass(String w) { 
		trackLastYearWtClass = w; 
	}
	public void setTrackLastYearRecord(String r) {
		trackLastYearRecord = r;
	}
	
	
	public void addBout(Bout b) {
		String cmd=b.getMatchDate();
		if (cmd == null ) {
			Event e = b.getEvent();
			if ( e != null ) {
				String sss = e.getEventTitle();
				if ( wiHistory != null ) {
					String s = wiHistory.findWeighInDate(sss);
					if ( s != null ) { 
						b.setMatchDate(s);
					}
				}
			}
		}	
		
		bouts.add(b);
		addToSummary(b);
		addToMatchesAtWeight(b);
	}
	private void addToMatchesAtWeight(Bout b) {
		String w=b.getWeight();
		Integer ct = matchesAtWeight.get(w);
		if ( ct != null ) {
			ct++;
			matchesAtWeight.replace(w,ct);
		} else {
			matchesAtWeight.put(w,1);
		}
		return;
	}
	public String getMatchesAtWeightString() {

		String byWt="";
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
	
			int ct = matchesAtWeight.get(key);
			if ( byWt.length() > 0 ) { byWt=byWt + ";" ; }
			byWt=byWt + ct + "@" + key;
		}
		return byWt;
	}
	
	public void setName( String n ) {
		name = n.strip();
	}
	public void setSeed( String n ) {
		seed = n.strip();
	}
	public void setCert( String n ) {
		cert = n.strip();
	}
	public void setTeamName( String team ) {
		teamName = team;
	}
	public void setGrade5() { grade = WrestlingLanguage.Grade.G5;	}
	public void setGrade6() { grade = WrestlingLanguage.Grade.G6;	}
	public void setGrade7() { grade = WrestlingLanguage.Grade.G7;	}
	public void setGrade8() { grade = WrestlingLanguage.Grade.G8;	}
	public void setGrade(WrestlingLanguage.Grade g ) { grade=g; }
	
	public void setGenderM() { gender = WrestlingLanguage.Gender.M;	}
	public void setGenderF() { gender = WrestlingLanguage.Gender.F;	}
	public void setGender(WrestlingLanguage.Gender g ) { gender = g; }
	
	public void setTrackRecord(String rec) {
		trackRecord = rec;
	}
	public void setTrackWtClass(String w ) {
		trackWtClass = w;
	}
	public String toString() {
		return "Wrestler:" + teamName + ":" + name  ;
	}
	private void addToSummary(Bout b) {
	   if ( b.isAWin() ) {
          addWin();	
          switch ( b.getMatchResultType() ) {
			  case FFT: 
			    addWinByFFT();
				break;
			  case FALL:
			    addWinByFall();
				break;
			  case TECH:
			    addWinByTech();
				break;
			  case MD:
			    addWinByMD();
			    break;
			  case DEC:
			    addWinByDec();
				break;
			  case INJ:
			    break;
			  case DQ:
			    break;
		  }
       } else {
          addLoss();
          switch ( b.getMatchResultType() ) {

          case FFT:
			  addLossByFFT();
			    break;
			  case FALL:
			    addLossByFall();
				break;
			  case TECH:
			    addLossByTech();
				break;
			  case MD:
			    addLossByMD();
			    break;
			  case DEC:
			    addLossByDec();
				break;
			  case INJ:
			    if ( lossByInjury) {
			    	lossByInjuryString += ";";
			    } else {
			    	lossByInjury=true;
			    	lossByInjuryString= "Loss by Injury on ";
			    }
			    if ( b.getMatchDate() != null ) {
			    	lossByInjuryString += b.getMatchDate();
			    	lossByInjuryString += " ";
			    }
			    lossByInjuryString += " vs ";
			    lossByInjuryString += b.getOpponentTeam();
			    
			    break;
			  case DQ:
			    break;
		  }		  
       }		  
	}
	public void addWin() { wins++; }
	public void addLoss() { losses++; }
	public void addWinByFFT() { winByFFT++; }
	public void addWinByFall() { winByFall++; }
	public void addWinByTech() { winByTech++; }
	public void addWinByMD() { winByMD++; }
	public void addWinByDec() { winByDec++; }
	
	public void addLossByFFT() { lossByFFT++; }
	public void addLossByFall() { lossByFall++; }
	public void addLossByTech() { lossByTech++; }
	public void addLossByMD() { lossByMD++; }
	public void addLossByDec() { lossByDec++; }

	public boolean equals(Object o) {
	  if ( o == null ) { return false; }
	  if ( this == o ) { return true; }
	  if ( this.getClass() == o.getClass() ){
         Wrestler ow = (Wrestler) o;		  
	     if ( this.getName().equals(ow.getName()) && this.getTeamName().equals(ow.getTeamName())) {
			 return true;
	     }
	  }
	  return false; 
	}
	public int hashCode() {
		return getName().hashCode() + getTeamName().hashCode();
	}


public String getFinWeight() {
	String finWeight = "";
	boolean a = playedMatch();
	
	if(cert != null) {
		finWeight = cert;
	}
	else (this.cert == null&&this.playedMatch()== true){
		finWeight = thgetLowestWeightWrestled();
	}
	
	return finWeight;
}

public boolean playedMatch() {
	if (matchWeight == null) {
		return false;
}	
	return true;
}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-13 22:33:08.376
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-13 22:33:08.376
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-13 22:33:09.196
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package JuniorHigh;

import java.util.*;
import java.util.Enumeration;

/*
 *
 *  This is a class to holds an wrestler and all data pertaining to him/her.
 */
class Wrestler {
	private String name;
	private String seed;
	private String cert;
	private String teamName;
	private WrestlingLanguage.Grade grade;
	private WrestlingLanguage.Gender gender;
	private String trackRecord;
	private String trackWtClass;
	private boolean rosteredLastYear;
	private String trackLastYearWtClass;
	private String trackLastYearRecord;
	private WrestlingLanguage.Prestige prestigeLastYear;
	private WrestlingLanguage.Prestige prestige2YearsAgo;
	private WrestlingLanguage.Prestige prestige3YearsAgo;
	
	private Hashtable<String,Integer> matchesAtWeight=new Hashtable<String,Integer>();
	
	private int wins;
	private int losses;
	private boolean lossByInjury=false;
	private String lossByInjuryString;
	private int winByFFT;
	private int lossByFFT;

	private int winByFall;
	private int winByDec;
	private int winByMD;
	private int winByTech;
	
	private int lossByFall;
	private int lossByDec;
	private int lossByMD;
	private int lossByTech;
	
	private int weight;
	
	private Hashtable<Integer,Integer> matchWeight=new Hashtable<Integer,Integer>();

		
	private WeighInHistory wiHistory;
	
	/* These 2 attributes are used to force where we put the wrestler in the reporting
	 * order.
	 */
	private String forceWeight=null;  /* for reporting force the use of this weight class. */
	private Integer forceRank=null;  /* for reporting this is the rank order withing the weight class. */

	public void setLossByInjuryString(String s) {
		lossByInjuryString = s;
	}
	public String getLossByInjuryString() { return lossByInjuryString; }
	
	public String getLowestWeightWrestled() {
		int lowInt=99999;
		
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
			int i =  Integer.parseInt(key);
		    if (i < lowInt ) {
		    	lowInt = i;
		    }
		}
		return Integer.toString(lowInt);
	}
	public String getPrintWeight() {
		if ( forceWeight != null ) {
			if ( forceWeight.length() > 0 ) {
				return forceWeight;
			}
		}
		return getLowestWeightWrestled();
	}
	public int getPrintRank() {
		if (forceRank == null ) {
			return getWins() + getLosses();
		} else {
			return 100000 - forceRank.intValue();
		}
	}
	public String getForceWeight() { return forceWeight; }
	public Integer getForceRank() { return forceRank; }
	
	public void setWeight( int w ) { 
		if (matchWeight.containsKey(w)) {
			int val =matchWeight.get(w);
			matchWeight.put(w, val+1);
			
		}
		else {
		matchWeight.put(w, 1);	
		}
		
	}
	public String getWeight() {
		Enumeration<Integer> e = matchWeight.keys();
		String WeightString="";
		while (e.hasMoreElements()) {
			 
	            // Getting the key of a particular entry
	            int keyWeight = e.nextElement();
	            int valueCount = matchWeight.get(keyWeight);
	            
	            WeightString += Integer.toString(valueCount) + "@" + Integer.toString(keyWeight) + " - ";
	             
	          
	        }
		return WeightString;
		
	}


	
	public void setForceWeight( String w ) { forceWeight = w; }
	public void setForceRank ( Integer i ) { forceRank = i; }
	
	List<Bout> bouts = new ArrayList<Bout> ();

	public List<Bout> getBouts() { return bouts; }
	
	public boolean getLossByInjury() { return lossByInjury; }
	
	public WeighInHistory getWeighInHistory() { return wiHistory; }
	
	public void setWeighInHistory(WeighInHistory wih ) { wiHistory = wih; }

	public void setPrestigeLastYear(WrestlingLanguage.Prestige p) { prestigeLastYear = p; }
	public void setPrestige2YearsAgo(WrestlingLanguage.Prestige p) { prestige2YearsAgo= p; }
	public void setPrestige3YearsAgo(WrestlingLanguage.Prestige p) { prestige3YearsAgo = p; }

	public WrestlingLanguage.Prestige getPrestigeLastYear() { return prestigeLastYear; }
	public WrestlingLanguage.Prestige getPrestige2YearsAgo() { return prestige2YearsAgo; }
	public WrestlingLanguage.Prestige getPrestige3YearsAgo() { return prestige3YearsAgo; }

    public void printVerbose () {
		System.out.println( getName() + 
			" Grade<" + getGrade() + ">" + 
			" Seed<" + getSeed() + ">" +
			" Cert<" + getCert() + ">"); 
			//" Gender<" + getGender() + "> Wt<" + 
			//getTrackWtClass() + ">" + " (" + getWins() + "W-" + 
			//getLosses() + "L) Last Year=<" + rosteredLastYear + "> Last Year Record <" + trackLastYearRecord + ">" );
    }	   
	public String getRecordString() { 
		return String.valueOf(wins) + "-" + String.valueOf(losses); 
	}
	public String getRecordBreakdown() {
		String breakdownString = "";
		boolean addedWins=false;
		if ( getWins() > 0 ) {
			breakdownString += getWins() + "W[";
			if ( getWinByFall() > 0 ) {
				breakdownString += getWinByFall() + " Pin,";
				addedWins=true;
			}
			if ( getWinByTech() > 0 ) {
				breakdownString += getWinByTech() + " TF,";
				addedWins=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getWinByMD() + " MD,";
				addedWins=true;
			}
			if ( getWinByDec() > 0 ) {
				breakdownString += getWinByDec() + " Dec,";
				addedWins=true;
			}
			if ( getWinByFFT() > 0 ) {
				breakdownString += getWinByFFT() + " FFT,";
				addedWins=true;
			}
			if ( addedWins ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "0 W";
		}
		boolean addedLosses=false;
		if ( getLosses() > 0 ) {
			breakdownString += "-" + getLosses() + "L[";
			if ( getLossByFall() > 0 ) {
				breakdownString += getLossByFall() + " Pin,";
				addedLosses=true;
			}
			if ( getLossByTech() > 0 ) {
				breakdownString += getLossByTech() + " TF,";
				addedLosses=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getLossByMD() + " MD,";
				addedLosses=true;
			}
			if ( getLossByDec() > 0 ) {
				breakdownString += getLossByDec() + " Dec,";
				addedLosses=true;
			}
			
			if ( addedLosses ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "-0L";
		}
		if ( getWins() ==0 && getLosses() == 0 ) {
			return "";
		} else {
			return breakdownString +" - "+ getWeight();
		}
	}
	public String getName() { return name; }
	public String getSeed() { return seed; }
	public String getCert() { return cert; }
	public String getTeamName() { return teamName; }
	public WrestlingLanguage.Grade getGrade() { return grade; }
	public WrestlingLanguage.Gender getGender() { return gender; }
	public String getTrackRecord() { return trackRecord; }
	public String getTrackWtClass() { return trackWtClass; }
	
	public int getWins() { return wins; }
	public int getLosses() { return losses; }
	
	public int getWinByFFT() { return winByFFT; }
	public int getWinByFall() { return winByFall; }
	public int getWinByTech() { return winByTech; }
	public int getWinByMD() { return winByMD; }
	public int getWinByDec() { return winByDec; }
	
	public int getLossByFFT() { return lossByFFT; }
	public int getLossByFall() { return lossByFall; }
	public int getLossByTech() { return lossByTech; }
	public int getLossByMD() { return lossByMD; }
	public int getLossByDec() { return lossByDec; }
	
    public Wrestler(String n, String team){
		setName(n);
		setTeamName(team);
		return;
	}
	public boolean getRosteredLastYear() { return rosteredLastYear; }
	
	public void setRosteredLastYearOn() { rosteredLastYear = true; }
	public void setRosteredLastYearOff() { rosteredLastYear = false; }
	
	public String getTrackLastYearWtClass() { return trackLastYearWtClass; }
	public String getTrackLastYearRecord() { return trackLastYearRecord; }
	
	public void setTrackLastYearWtClass(String w) { 
		trackLastYearWtClass = w; 
	}
	public void setTrackLastYearRecord(String r) {
		trackLastYearRecord = r;
	}
	
	
	public void addBout(Bout b) {
		String cmd=b.getMatchDate();
		if (cmd == null ) {
			Event e = b.getEvent();
			if ( e != null ) {
				String sss = e.getEventTitle();
				if ( wiHistory != null ) {
					String s = wiHistory.findWeighInDate(sss);
					if ( s != null ) { 
						b.setMatchDate(s);
					}
				}
			}
		}	
		
		bouts.add(b);
		addToSummary(b);
		addToMatchesAtWeight(b);
	}
	private void addToMatchesAtWeight(Bout b) {
		String w=b.getWeight();
		Integer ct = matchesAtWeight.get(w);
		if ( ct != null ) {
			ct++;
			matchesAtWeight.replace(w,ct);
		} else {
			matchesAtWeight.put(w,1);
		}
		return;
	}
	public String getMatchesAtWeightString() {

		String byWt="";
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
	
			int ct = matchesAtWeight.get(key);
			if ( byWt.length() > 0 ) { byWt=byWt + ";" ; }
			byWt=byWt + ct + "@" + key;
		}
		return byWt;
	}
	
	public void setName( String n ) {
		name = n.strip();
	}
	public void setSeed( String n ) {
		seed = n.strip();
	}
	public void setCert( String n ) {
		cert = n.strip();
	}
	public void setTeamName( String team ) {
		teamName = team;
	}
	public void setGrade5() { grade = WrestlingLanguage.Grade.G5;	}
	public void setGrade6() { grade = WrestlingLanguage.Grade.G6;	}
	public void setGrade7() { grade = WrestlingLanguage.Grade.G7;	}
	public void setGrade8() { grade = WrestlingLanguage.Grade.G8;	}
	public void setGrade(WrestlingLanguage.Grade g ) { grade=g; }
	
	public void setGenderM() { gender = WrestlingLanguage.Gender.M;	}
	public void setGenderF() { gender = WrestlingLanguage.Gender.F;	}
	public void setGender(WrestlingLanguage.Gender g ) { gender = g; }
	
	public void setTrackRecord(String rec) {
		trackRecord = rec;
	}
	public void setTrackWtClass(String w ) {
		trackWtClass = w;
	}
	public String toString() {
		return "Wrestler:" + teamName + ":" + name  ;
	}
	private void addToSummary(Bout b) {
	   if ( b.isAWin() ) {
          addWin();	
          switch ( b.getMatchResultType() ) {
			  case FFT: 
			    addWinByFFT();
				break;
			  case FALL:
			    addWinByFall();
				break;
			  case TECH:
			    addWinByTech();
				break;
			  case MD:
			    addWinByMD();
			    break;
			  case DEC:
			    addWinByDec();
				break;
			  case INJ:
			    break;
			  case DQ:
			    break;
		  }
       } else {
          addLoss();
          switch ( b.getMatchResultType() ) {

          case FFT:
			  addLossByFFT();
			    break;
			  case FALL:
			    addLossByFall();
				break;
			  case TECH:
			    addLossByTech();
				break;
			  case MD:
			    addLossByMD();
			    break;
			  case DEC:
			    addLossByDec();
				break;
			  case INJ:
			    if ( lossByInjury) {
			    	lossByInjuryString += ";";
			    } else {
			    	lossByInjury=true;
			    	lossByInjuryString= "Loss by Injury on ";
			    }
			    if ( b.getMatchDate() != null ) {
			    	lossByInjuryString += b.getMatchDate();
			    	lossByInjuryString += " ";
			    }
			    lossByInjuryString += " vs ";
			    lossByInjuryString += b.getOpponentTeam();
			    
			    break;
			  case DQ:
			    break;
		  }		  
       }		  
	}
	public void addWin() { wins++; }
	public void addLoss() { losses++; }
	public void addWinByFFT() { winByFFT++; }
	public void addWinByFall() { winByFall++; }
	public void addWinByTech() { winByTech++; }
	public void addWinByMD() { winByMD++; }
	public void addWinByDec() { winByDec++; }
	
	public void addLossByFFT() { lossByFFT++; }
	public void addLossByFall() { lossByFall++; }
	public void addLossByTech() { lossByTech++; }
	public void addLossByMD() { lossByMD++; }
	public void addLossByDec() { lossByDec++; }

	public boolean equals(Object o) {
	  if ( o == null ) { return false; }
	  if ( this == o ) { return true; }
	  if ( this.getClass() == o.getClass() ){
         Wrestler ow = (Wrestler) o;		  
	     if ( this.getName().equals(ow.getName()) && this.getTeamName().equals(ow.getTeamName())) {
			 return true;
	     }
	  }
	  return false; 
	}
	public int hashCode() {
		return getName().hashCode() + getTeamName().hashCode();
	}


public String getFinWeight() {
	String finWeight = "";
	boolean a = playedMatch();
	
	if(cert != null) {
		finWeight = cert;
	}
	else (this.cert == null&&this.playedMatch()== true){
		finWeight = thisgetLowestWeightWrestled();
	}
	
	return finWeight;
}

public boolean playedMatch() {
	if (matchWeight == null) {
		return false;
}	
	return true;
}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-10-13 22:33:09.196
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-10-13 22:33:09.197
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-13 22:33:09.287
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package JuniorHigh;

import java.util.*;
import java.util.Enumeration;

/*
 *
 *  This is a class to holds an wrestler and all data pertaining to him/her.
 */
class Wrestler {
	private String name;
	private String seed;
	private String cert;
	private String teamName;
	private WrestlingLanguage.Grade grade;
	private WrestlingLanguage.Gender gender;
	private String trackRecord;
	private String trackWtClass;
	private boolean rosteredLastYear;
	private String trackLastYearWtClass;
	private String trackLastYearRecord;
	private WrestlingLanguage.Prestige prestigeLastYear;
	private WrestlingLanguage.Prestige prestige2YearsAgo;
	private WrestlingLanguage.Prestige prestige3YearsAgo;
	
	private Hashtable<String,Integer> matchesAtWeight=new Hashtable<String,Integer>();
	
	private int wins;
	private int losses;
	private boolean lossByInjury=false;
	private String lossByInjuryString;
	private int winByFFT;
	private int lossByFFT;

	private int winByFall;
	private int winByDec;
	private int winByMD;
	private int winByTech;
	
	private int lossByFall;
	private int lossByDec;
	private int lossByMD;
	private int lossByTech;
	
	private int weight;
	
	private Hashtable<Integer,Integer> matchWeight=new Hashtable<Integer,Integer>();

		
	private WeighInHistory wiHistory;
	
	/* These 2 attributes are used to force where we put the wrestler in the reporting
	 * order.
	 */
	private String forceWeight=null;  /* for reporting force the use of this weight class. */
	private Integer forceRank=null;  /* for reporting this is the rank order withing the weight class. */

	public void setLossByInjuryString(String s) {
		lossByInjuryString = s;
	}
	public String getLossByInjuryString() { return lossByInjuryString; }
	
	public String getLowestWeightWrestled() {
		int lowInt=99999;
		
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
			int i =  Integer.parseInt(key);
		    if (i < lowInt ) {
		    	lowInt = i;
		    }
		}
		return Integer.toString(lowInt);
	}
	public String getPrintWeight() {
		if ( forceWeight != null ) {
			if ( forceWeight.length() > 0 ) {
				return forceWeight;
			}
		}
		return getLowestWeightWrestled();
	}
	public int getPrintRank() {
		if (forceRank == null ) {
			return getWins() + getLosses();
		} else {
			return 100000 - forceRank.intValue();
		}
	}
	public String getForceWeight() { return forceWeight; }
	public Integer getForceRank() { return forceRank; }
	
	public void setWeight( int w ) { 
		if (matchWeight.containsKey(w)) {
			int val =matchWeight.get(w);
			matchWeight.put(w, val+1);
			
		}
		else {
		matchWeight.put(w, 1);	
		}
		
	}
	public String getWeight() {
		Enumeration<Integer> e = matchWeight.keys();
		String WeightString="";
		while (e.hasMoreElements()) {
			 
	            // Getting the key of a particular entry
	            int keyWeight = e.nextElement();
	            int valueCount = matchWeight.get(keyWeight);
	            
	            WeightString += Integer.toString(valueCount) + "@" + Integer.toString(keyWeight) + " - ";
	             
	          
	        }
		return WeightString;
		
	}


	
	public void setForceWeight( String w ) { forceWeight = w; }
	public void setForceRank ( Integer i ) { forceRank = i; }
	
	List<Bout> bouts = new ArrayList<Bout> ();

	public List<Bout> getBouts() { return bouts; }
	
	public boolean getLossByInjury() { return lossByInjury; }
	
	public WeighInHistory getWeighInHistory() { return wiHistory; }
	
	public void setWeighInHistory(WeighInHistory wih ) { wiHistory = wih; }

	public void setPrestigeLastYear(WrestlingLanguage.Prestige p) { prestigeLastYear = p; }
	public void setPrestige2YearsAgo(WrestlingLanguage.Prestige p) { prestige2YearsAgo= p; }
	public void setPrestige3YearsAgo(WrestlingLanguage.Prestige p) { prestige3YearsAgo = p; }

	public WrestlingLanguage.Prestige getPrestigeLastYear() { return prestigeLastYear; }
	public WrestlingLanguage.Prestige getPrestige2YearsAgo() { return prestige2YearsAgo; }
	public WrestlingLanguage.Prestige getPrestige3YearsAgo() { return prestige3YearsAgo; }

    public void printVerbose () {
		System.out.println( getName() + 
			" Grade<" + getGrade() + ">" + 
			" Seed<" + getSeed() + ">" +
			" Cert<" + getCert() + ">"); 
			//" Gender<" + getGender() + "> Wt<" + 
			//getTrackWtClass() + ">" + " (" + getWins() + "W-" + 
			//getLosses() + "L) Last Year=<" + rosteredLastYear + "> Last Year Record <" + trackLastYearRecord + ">" );
    }	   
	public String getRecordString() { 
		return String.valueOf(wins) + "-" + String.valueOf(losses); 
	}
	public String getRecordBreakdown() {
		String breakdownString = "";
		boolean addedWins=false;
		if ( getWins() > 0 ) {
			breakdownString += getWins() + "W[";
			if ( getWinByFall() > 0 ) {
				breakdownString += getWinByFall() + " Pin,";
				addedWins=true;
			}
			if ( getWinByTech() > 0 ) {
				breakdownString += getWinByTech() + " TF,";
				addedWins=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getWinByMD() + " MD,";
				addedWins=true;
			}
			if ( getWinByDec() > 0 ) {
				breakdownString += getWinByDec() + " Dec,";
				addedWins=true;
			}
			if ( getWinByFFT() > 0 ) {
				breakdownString += getWinByFFT() + " FFT,";
				addedWins=true;
			}
			if ( addedWins ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "0 W";
		}
		boolean addedLosses=false;
		if ( getLosses() > 0 ) {
			breakdownString += "-" + getLosses() + "L[";
			if ( getLossByFall() > 0 ) {
				breakdownString += getLossByFall() + " Pin,";
				addedLosses=true;
			}
			if ( getLossByTech() > 0 ) {
				breakdownString += getLossByTech() + " TF,";
				addedLosses=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getLossByMD() + " MD,";
				addedLosses=true;
			}
			if ( getLossByDec() > 0 ) {
				breakdownString += getLossByDec() + " Dec,";
				addedLosses=true;
			}
			
			if ( addedLosses ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "-0L";
		}
		if ( getWins() ==0 && getLosses() == 0 ) {
			return "";
		} else {
			return breakdownString +" - "+ getWeight();
		}
	}
	public String getName() { return name; }
	public String getSeed() { return seed; }
	public String getCert() { return cert; }
	public String getTeamName() { return teamName; }
	public WrestlingLanguage.Grade getGrade() { return grade; }
	public WrestlingLanguage.Gender getGender() { return gender; }
	public String getTrackRecord() { return trackRecord; }
	public String getTrackWtClass() { return trackWtClass; }
	
	public int getWins() { return wins; }
	public int getLosses() { return losses; }
	
	public int getWinByFFT() { return winByFFT; }
	public int getWinByFall() { return winByFall; }
	public int getWinByTech() { return winByTech; }
	public int getWinByMD() { return winByMD; }
	public int getWinByDec() { return winByDec; }
	
	public int getLossByFFT() { return lossByFFT; }
	public int getLossByFall() { return lossByFall; }
	public int getLossByTech() { return lossByTech; }
	public int getLossByMD() { return lossByMD; }
	public int getLossByDec() { return lossByDec; }
	
    public Wrestler(String n, String team){
		setName(n);
		setTeamName(team);
		return;
	}
	public boolean getRosteredLastYear() { return rosteredLastYear; }
	
	public void setRosteredLastYearOn() { rosteredLastYear = true; }
	public void setRosteredLastYearOff() { rosteredLastYear = false; }
	
	public String getTrackLastYearWtClass() { return trackLastYearWtClass; }
	public String getTrackLastYearRecord() { return trackLastYearRecord; }
	
	public void setTrackLastYearWtClass(String w) { 
		trackLastYearWtClass = w; 
	}
	public void setTrackLastYearRecord(String r) {
		trackLastYearRecord = r;
	}
	
	
	public void addBout(Bout b) {
		String cmd=b.getMatchDate();
		if (cmd == null ) {
			Event e = b.getEvent();
			if ( e != null ) {
				String sss = e.getEventTitle();
				if ( wiHistory != null ) {
					String s = wiHistory.findWeighInDate(sss);
					if ( s != null ) { 
						b.setMatchDate(s);
					}
				}
			}
		}	
		
		bouts.add(b);
		addToSummary(b);
		addToMatchesAtWeight(b);
	}
	private void addToMatchesAtWeight(Bout b) {
		String w=b.getWeight();
		Integer ct = matchesAtWeight.get(w);
		if ( ct != null ) {
			ct++;
			matchesAtWeight.replace(w,ct);
		} else {
			matchesAtWeight.put(w,1);
		}
		return;
	}
	public String getMatchesAtWeightString() {

		String byWt="";
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
	
			int ct = matchesAtWeight.get(key);
			if ( byWt.length() > 0 ) { byWt=byWt + ";" ; }
			byWt=byWt + ct + "@" + key;
		}
		return byWt;
	}
	
	public void setName( String n ) {
		name = n.strip();
	}
	public void setSeed( String n ) {
		seed = n.strip();
	}
	public void setCert( String n ) {
		cert = n.strip();
	}
	public void setTeamName( String team ) {
		teamName = team;
	}
	public void setGrade5() { grade = WrestlingLanguage.Grade.G5;	}
	public void setGrade6() { grade = WrestlingLanguage.Grade.G6;	}
	public void setGrade7() { grade = WrestlingLanguage.Grade.G7;	}
	public void setGrade8() { grade = WrestlingLanguage.Grade.G8;	}
	public void setGrade(WrestlingLanguage.Grade g ) { grade=g; }
	
	public void setGenderM() { gender = WrestlingLanguage.Gender.M;	}
	public void setGenderF() { gender = WrestlingLanguage.Gender.F;	}
	public void setGender(WrestlingLanguage.Gender g ) { gender = g; }
	
	public void setTrackRecord(String rec) {
		trackRecord = rec;
	}
	public void setTrackWtClass(String w ) {
		trackWtClass = w;
	}
	public String toString() {
		return "Wrestler:" + teamName + ":" + name  ;
	}
	private void addToSummary(Bout b) {
	   if ( b.isAWin() ) {
          addWin();	
          switch ( b.getMatchResultType() ) {
			  case FFT: 
			    addWinByFFT();
				break;
			  case FALL:
			    addWinByFall();
				break;
			  case TECH:
			    addWinByTech();
				break;
			  case MD:
			    addWinByMD();
			    break;
			  case DEC:
			    addWinByDec();
				break;
			  case INJ:
			    break;
			  case DQ:
			    break;
		  }
       } else {
          addLoss();
          switch ( b.getMatchResultType() ) {

          case FFT:
			  addLossByFFT();
			    break;
			  case FALL:
			    addLossByFall();
				break;
			  case TECH:
			    addLossByTech();
				break;
			  case MD:
			    addLossByMD();
			    break;
			  case DEC:
			    addLossByDec();
				break;
			  case INJ:
			    if ( lossByInjury) {
			    	lossByInjuryString += ";";
			    } else {
			    	lossByInjury=true;
			    	lossByInjuryString= "Loss by Injury on ";
			    }
			    if ( b.getMatchDate() != null ) {
			    	lossByInjuryString += b.getMatchDate();
			    	lossByInjuryString += " ";
			    }
			    lossByInjuryString += " vs ";
			    lossByInjuryString += b.getOpponentTeam();
			    
			    break;
			  case DQ:
			    break;
		  }		  
       }		  
	}
	public void addWin() { wins++; }
	public void addLoss() { losses++; }
	public void addWinByFFT() { winByFFT++; }
	public void addWinByFall() { winByFall++; }
	public void addWinByTech() { winByTech++; }
	public void addWinByMD() { winByMD++; }
	public void addWinByDec() { winByDec++; }
	
	public void addLossByFFT() { lossByFFT++; }
	public void addLossByFall() { lossByFall++; }
	public void addLossByTech() { lossByTech++; }
	public void addLossByMD() { lossByMD++; }
	public void addLossByDec() { lossByDec++; }

	public boolean equals(Object o) {
	  if ( o == null ) { return false; }
	  if ( this == o ) { return true; }
	  if ( this.getClass() == o.getClass() ){
         Wrestler ow = (Wrestler) o;		  
	     if ( this.getName().equals(ow.getName()) && this.getTeamName().equals(ow.getTeamName())) {
			 return true;
	     }
	  }
	  return false; 
	}
	public int hashCode() {
		return getName().hashCode() + getTeamName().hashCode();
	}


public String getFinWeight() {
	String finWeight = "";
	boolean a = playedMatch();
	
	if(cert != null) {
		finWeight = cert;
	}
	else (this.cert == null&&this.playedMatch()== true){
		finWeight = thisgetLowestWeightWrestled();
	}
	
	return finWeight;
}

public boolean playedMatch() {
	if (matchWeight == null) {
		return false;
}	
	return true;
}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-10-13 22:33:09.288
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-10-13 22:33:09.288
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-13 22:33:09.303
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package JuniorHigh;

import java.util.*;
import java.util.Enumeration;

/*
 *
 *  This is a class to holds an wrestler and all data pertaining to him/her.
 */
class Wrestler {
	private String name;
	private String seed;
	private String cert;
	private String teamName;
	private WrestlingLanguage.Grade grade;
	private WrestlingLanguage.Gender gender;
	private String trackRecord;
	private String trackWtClass;
	private boolean rosteredLastYear;
	private String trackLastYearWtClass;
	private String trackLastYearRecord;
	private WrestlingLanguage.Prestige prestigeLastYear;
	private WrestlingLanguage.Prestige prestige2YearsAgo;
	private WrestlingLanguage.Prestige prestige3YearsAgo;
	
	private Hashtable<String,Integer> matchesAtWeight=new Hashtable<String,Integer>();
	
	private int wins;
	private int losses;
	private boolean lossByInjury=false;
	private String lossByInjuryString;
	private int winByFFT;
	private int lossByFFT;

	private int winByFall;
	private int winByDec;
	private int winByMD;
	private int winByTech;
	
	private int lossByFall;
	private int lossByDec;
	private int lossByMD;
	private int lossByTech;
	
	private int weight;
	
	private Hashtable<Integer,Integer> matchWeight=new Hashtable<Integer,Integer>();

		
	private WeighInHistory wiHistory;
	
	/* These 2 attributes are used to force where we put the wrestler in the reporting
	 * order.
	 */
	private String forceWeight=null;  /* for reporting force the use of this weight class. */
	private Integer forceRank=null;  /* for reporting this is the rank order withing the weight class. */

	public void setLossByInjuryString(String s) {
		lossByInjuryString = s;
	}
	public String getLossByInjuryString() { return lossByInjuryString; }
	
	public String getLowestWeightWrestled() {
		int lowInt=99999;
		
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
			int i =  Integer.parseInt(key);
		    if (i < lowInt ) {
		    	lowInt = i;
		    }
		}
		return Integer.toString(lowInt);
	}
	public String getPrintWeight() {
		if ( forceWeight != null ) {
			if ( forceWeight.length() > 0 ) {
				return forceWeight;
			}
		}
		return getLowestWeightWrestled();
	}
	public int getPrintRank() {
		if (forceRank == null ) {
			return getWins() + getLosses();
		} else {
			return 100000 - forceRank.intValue();
		}
	}
	public String getForceWeight() { return forceWeight; }
	public Integer getForceRank() { return forceRank; }
	
	public void setWeight( int w ) { 
		if (matchWeight.containsKey(w)) {
			int val =matchWeight.get(w);
			matchWeight.put(w, val+1);
			
		}
		else {
		matchWeight.put(w, 1);	
		}
		
	}
	public String getWeight() {
		Enumeration<Integer> e = matchWeight.keys();
		String WeightString="";
		while (e.hasMoreElements()) {
			 
	            // Getting the key of a particular entry
	            int keyWeight = e.nextElement();
	            int valueCount = matchWeight.get(keyWeight);
	            
	            WeightString += Integer.toString(valueCount) + "@" + Integer.toString(keyWeight) + " - ";
	             
	          
	        }
		return WeightString;
		
	}


	
	public void setForceWeight( String w ) { forceWeight = w; }
	public void setForceRank ( Integer i ) { forceRank = i; }
	
	List<Bout> bouts = new ArrayList<Bout> ();

	public List<Bout> getBouts() { return bouts; }
	
	public boolean getLossByInjury() { return lossByInjury; }
	
	public WeighInHistory getWeighInHistory() { return wiHistory; }
	
	public void setWeighInHistory(WeighInHistory wih ) { wiHistory = wih; }

	public void setPrestigeLastYear(WrestlingLanguage.Prestige p) { prestigeLastYear = p; }
	public void setPrestige2YearsAgo(WrestlingLanguage.Prestige p) { prestige2YearsAgo= p; }
	public void setPrestige3YearsAgo(WrestlingLanguage.Prestige p) { prestige3YearsAgo = p; }

	public WrestlingLanguage.Prestige getPrestigeLastYear() { return prestigeLastYear; }
	public WrestlingLanguage.Prestige getPrestige2YearsAgo() { return prestige2YearsAgo; }
	public WrestlingLanguage.Prestige getPrestige3YearsAgo() { return prestige3YearsAgo; }

    public void printVerbose () {
		System.out.println( getName() + 
			" Grade<" + getGrade() + ">" + 
			" Seed<" + getSeed() + ">" +
			" Cert<" + getCert() + ">"); 
			//" Gender<" + getGender() + "> Wt<" + 
			//getTrackWtClass() + ">" + " (" + getWins() + "W-" + 
			//getLosses() + "L) Last Year=<" + rosteredLastYear + "> Last Year Record <" + trackLastYearRecord + ">" );
    }	   
	public String getRecordString() { 
		return String.valueOf(wins) + "-" + String.valueOf(losses); 
	}
	public String getRecordBreakdown() {
		String breakdownString = "";
		boolean addedWins=false;
		if ( getWins() > 0 ) {
			breakdownString += getWins() + "W[";
			if ( getWinByFall() > 0 ) {
				breakdownString += getWinByFall() + " Pin,";
				addedWins=true;
			}
			if ( getWinByTech() > 0 ) {
				breakdownString += getWinByTech() + " TF,";
				addedWins=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getWinByMD() + " MD,";
				addedWins=true;
			}
			if ( getWinByDec() > 0 ) {
				breakdownString += getWinByDec() + " Dec,";
				addedWins=true;
			}
			if ( getWinByFFT() > 0 ) {
				breakdownString += getWinByFFT() + " FFT,";
				addedWins=true;
			}
			if ( addedWins ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "0 W";
		}
		boolean addedLosses=false;
		if ( getLosses() > 0 ) {
			breakdownString += "-" + getLosses() + "L[";
			if ( getLossByFall() > 0 ) {
				breakdownString += getLossByFall() + " Pin,";
				addedLosses=true;
			}
			if ( getLossByTech() > 0 ) {
				breakdownString += getLossByTech() + " TF,";
				addedLosses=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getLossByMD() + " MD,";
				addedLosses=true;
			}
			if ( getLossByDec() > 0 ) {
				breakdownString += getLossByDec() + " Dec,";
				addedLosses=true;
			}
			
			if ( addedLosses ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "-0L";
		}
		if ( getWins() ==0 && getLosses() == 0 ) {
			return "";
		} else {
			return breakdownString +" - "+ getWeight();
		}
	}
	public String getName() { return name; }
	public String getSeed() { return seed; }
	public String getCert() { return cert; }
	public String getTeamName() { return teamName; }
	public WrestlingLanguage.Grade getGrade() { return grade; }
	public WrestlingLanguage.Gender getGender() { return gender; }
	public String getTrackRecord() { return trackRecord; }
	public String getTrackWtClass() { return trackWtClass; }
	
	public int getWins() { return wins; }
	public int getLosses() { return losses; }
	
	public int getWinByFFT() { return winByFFT; }
	public int getWinByFall() { return winByFall; }
	public int getWinByTech() { return winByTech; }
	public int getWinByMD() { return winByMD; }
	public int getWinByDec() { return winByDec; }
	
	public int getLossByFFT() { return lossByFFT; }
	public int getLossByFall() { return lossByFall; }
	public int getLossByTech() { return lossByTech; }
	public int getLossByMD() { return lossByMD; }
	public int getLossByDec() { return lossByDec; }
	
    public Wrestler(String n, String team){
		setName(n);
		setTeamName(team);
		return;
	}
	public boolean getRosteredLastYear() { return rosteredLastYear; }
	
	public void setRosteredLastYearOn() { rosteredLastYear = true; }
	public void setRosteredLastYearOff() { rosteredLastYear = false; }
	
	public String getTrackLastYearWtClass() { return trackLastYearWtClass; }
	public String getTrackLastYearRecord() { return trackLastYearRecord; }
	
	public void setTrackLastYearWtClass(String w) { 
		trackLastYearWtClass = w; 
	}
	public void setTrackLastYearRecord(String r) {
		trackLastYearRecord = r;
	}
	
	
	public void addBout(Bout b) {
		String cmd=b.getMatchDate();
		if (cmd == null ) {
			Event e = b.getEvent();
			if ( e != null ) {
				String sss = e.getEventTitle();
				if ( wiHistory != null ) {
					String s = wiHistory.findWeighInDate(sss);
					if ( s != null ) { 
						b.setMatchDate(s);
					}
				}
			}
		}	
		
		bouts.add(b);
		addToSummary(b);
		addToMatchesAtWeight(b);
	}
	private void addToMatchesAtWeight(Bout b) {
		String w=b.getWeight();
		Integer ct = matchesAtWeight.get(w);
		if ( ct != null ) {
			ct++;
			matchesAtWeight.replace(w,ct);
		} else {
			matchesAtWeight.put(w,1);
		}
		return;
	}
	public String getMatchesAtWeightString() {

		String byWt="";
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
	
			int ct = matchesAtWeight.get(key);
			if ( byWt.length() > 0 ) { byWt=byWt + ";" ; }
			byWt=byWt + ct + "@" + key;
		}
		return byWt;
	}
	
	public void setName( String n ) {
		name = n.strip();
	}
	public void setSeed( String n ) {
		seed = n.strip();
	}
	public void setCert( String n ) {
		cert = n.strip();
	}
	public void setTeamName( String team ) {
		teamName = team;
	}
	public void setGrade5() { grade = WrestlingLanguage.Grade.G5;	}
	public void setGrade6() { grade = WrestlingLanguage.Grade.G6;	}
	public void setGrade7() { grade = WrestlingLanguage.Grade.G7;	}
	public void setGrade8() { grade = WrestlingLanguage.Grade.G8;	}
	public void setGrade(WrestlingLanguage.Grade g ) { grade=g; }
	
	public void setGenderM() { gender = WrestlingLanguage.Gender.M;	}
	public void setGenderF() { gender = WrestlingLanguage.Gender.F;	}
	public void setGender(WrestlingLanguage.Gender g ) { gender = g; }
	
	public void setTrackRecord(String rec) {
		trackRecord = rec;
	}
	public void setTrackWtClass(String w ) {
		trackWtClass = w;
	}
	public String toString() {
		return "Wrestler:" + teamName + ":" + name  ;
	}
	private void addToSummary(Bout b) {
	   if ( b.isAWin() ) {
          addWin();	
          switch ( b.getMatchResultType() ) {
			  case FFT: 
			    addWinByFFT();
				break;
			  case FALL:
			    addWinByFall();
				break;
			  case TECH:
			    addWinByTech();
				break;
			  case MD:
			    addWinByMD();
			    break;
			  case DEC:
			    addWinByDec();
				break;
			  case INJ:
			    break;
			  case DQ:
			    break;
		  }
       } else {
          addLoss();
          switch ( b.getMatchResultType() ) {

          case FFT:
			  addLossByFFT();
			    break;
			  case FALL:
			    addLossByFall();
				break;
			  case TECH:
			    addLossByTech();
				break;
			  case MD:
			    addLossByMD();
			    break;
			  case DEC:
			    addLossByDec();
				break;
			  case INJ:
			    if ( lossByInjury) {
			    	lossByInjuryString += ";";
			    } else {
			    	lossByInjury=true;
			    	lossByInjuryString= "Loss by Injury on ";
			    }
			    if ( b.getMatchDate() != null ) {
			    	lossByInjuryString += b.getMatchDate();
			    	lossByInjuryString += " ";
			    }
			    lossByInjuryString += " vs ";
			    lossByInjuryString += b.getOpponentTeam();
			    
			    break;
			  case DQ:
			    break;
		  }		  
       }		  
	}
	public void addWin() { wins++; }
	public void addLoss() { losses++; }
	public void addWinByFFT() { winByFFT++; }
	public void addWinByFall() { winByFall++; }
	public void addWinByTech() { winByTech++; }
	public void addWinByMD() { winByMD++; }
	public void addWinByDec() { winByDec++; }
	
	public void addLossByFFT() { lossByFFT++; }
	public void addLossByFall() { lossByFall++; }
	public void addLossByTech() { lossByTech++; }
	public void addLossByMD() { lossByMD++; }
	public void addLossByDec() { lossByDec++; }

	public boolean equals(Object o) {
	  if ( o == null ) { return false; }
	  if ( this == o ) { return true; }
	  if ( this.getClass() == o.getClass() ){
         Wrestler ow = (Wrestler) o;		  
	     if ( this.getName().equals(ow.getName()) && this.getTeamName().equals(ow.getTeamName())) {
			 return true;
	     }
	  }
	  return false; 
	}
	public int hashCode() {
		return getName().hashCode() + getTeamName().hashCode();
	}


public String getFinWeight() {
	String finWeight = "";
	boolean a = playedMatch();
	
	if(cert != null) {
		finWeight = cert;
	}
	else (this.cert == null&&this.playedMatch()== true){
		finWeight = thisgetLowestWeightWrestled();
	}
	
	return finWeight;
}

public boolean playedMatch() {
	if (matchWeight == null) {
		return false;
}	
	return true;
}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-13 22:33:09.303
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-13 22:33:09.303
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-13 22:33:09.944
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package JuniorHigh;

import java.util.*;
import java.util.Enumeration;

/*
 *
 *  This is a class to holds an wrestler and all data pertaining to him/her.
 */
class Wrestler {
	private String name;
	private String seed;
	private String cert;
	private String teamName;
	private WrestlingLanguage.Grade grade;
	private WrestlingLanguage.Gender gender;
	private String trackRecord;
	private String trackWtClass;
	private boolean rosteredLastYear;
	private String trackLastYearWtClass;
	private String trackLastYearRecord;
	private WrestlingLanguage.Prestige prestigeLastYear;
	private WrestlingLanguage.Prestige prestige2YearsAgo;
	private WrestlingLanguage.Prestige prestige3YearsAgo;
	
	private Hashtable<String,Integer> matchesAtWeight=new Hashtable<String,Integer>();
	
	private int wins;
	private int losses;
	private boolean lossByInjury=false;
	private String lossByInjuryString;
	private int winByFFT;
	private int lossByFFT;

	private int winByFall;
	private int winByDec;
	private int winByMD;
	private int winByTech;
	
	private int lossByFall;
	private int lossByDec;
	private int lossByMD;
	private int lossByTech;
	
	private int weight;
	
	private Hashtable<Integer,Integer> matchWeight=new Hashtable<Integer,Integer>();

		
	private WeighInHistory wiHistory;
	
	/* These 2 attributes are used to force where we put the wrestler in the reporting
	 * order.
	 */
	private String forceWeight=null;  /* for reporting force the use of this weight class. */
	private Integer forceRank=null;  /* for reporting this is the rank order withing the weight class. */

	public void setLossByInjuryString(String s) {
		lossByInjuryString = s;
	}
	public String getLossByInjuryString() { return lossByInjuryString; }
	
	public String getLowestWeightWrestled() {
		int lowInt=99999;
		
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
			int i =  Integer.parseInt(key);
		    if (i < lowInt ) {
		    	lowInt = i;
		    }
		}
		return Integer.toString(lowInt);
	}
	public String getPrintWeight() {
		if ( forceWeight != null ) {
			if ( forceWeight.length() > 0 ) {
				return forceWeight;
			}
		}
		return getLowestWeightWrestled();
	}
	public int getPrintRank() {
		if (forceRank == null ) {
			return getWins() + getLosses();
		} else {
			return 100000 - forceRank.intValue();
		}
	}
	public String getForceWeight() { return forceWeight; }
	public Integer getForceRank() { return forceRank; }
	
	public void setWeight( int w ) { 
		if (matchWeight.containsKey(w)) {
			int val =matchWeight.get(w);
			matchWeight.put(w, val+1);
			
		}
		else {
		matchWeight.put(w, 1);	
		}
		
	}
	public String getWeight() {
		Enumeration<Integer> e = matchWeight.keys();
		String WeightString="";
		while (e.hasMoreElements()) {
			 
	            // Getting the key of a particular entry
	            int keyWeight = e.nextElement();
	            int valueCount = matchWeight.get(keyWeight);
	            
	            WeightString += Integer.toString(valueCount) + "@" + Integer.toString(keyWeight) + " - ";
	             
	          
	        }
		return WeightString;
		
	}


	
	public void setForceWeight( String w ) { forceWeight = w; }
	public void setForceRank ( Integer i ) { forceRank = i; }
	
	List<Bout> bouts = new ArrayList<Bout> ();

	public List<Bout> getBouts() { return bouts; }
	
	public boolean getLossByInjury() { return lossByInjury; }
	
	public WeighInHistory getWeighInHistory() { return wiHistory; }
	
	public void setWeighInHistory(WeighInHistory wih ) { wiHistory = wih; }

	public void setPrestigeLastYear(WrestlingLanguage.Prestige p) { prestigeLastYear = p; }
	public void setPrestige2YearsAgo(WrestlingLanguage.Prestige p) { prestige2YearsAgo= p; }
	public void setPrestige3YearsAgo(WrestlingLanguage.Prestige p) { prestige3YearsAgo = p; }

	public WrestlingLanguage.Prestige getPrestigeLastYear() { return prestigeLastYear; }
	public WrestlingLanguage.Prestige getPrestige2YearsAgo() { return prestige2YearsAgo; }
	public WrestlingLanguage.Prestige getPrestige3YearsAgo() { return prestige3YearsAgo; }

    public void printVerbose () {
		System.out.println( getName() + 
			" Grade<" + getGrade() + ">" + 
			" Seed<" + getSeed() + ">" +
			" Cert<" + getCert() + ">"); 
			//" Gender<" + getGender() + "> Wt<" + 
			//getTrackWtClass() + ">" + " (" + getWins() + "W-" + 
			//getLosses() + "L) Last Year=<" + rosteredLastYear + "> Last Year Record <" + trackLastYearRecord + ">" );
    }	   
	public String getRecordString() { 
		return String.valueOf(wins) + "-" + String.valueOf(losses); 
	}
	public String getRecordBreakdown() {
		String breakdownString = "";
		boolean addedWins=false;
		if ( getWins() > 0 ) {
			breakdownString += getWins() + "W[";
			if ( getWinByFall() > 0 ) {
				breakdownString += getWinByFall() + " Pin,";
				addedWins=true;
			}
			if ( getWinByTech() > 0 ) {
				breakdownString += getWinByTech() + " TF,";
				addedWins=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getWinByMD() + " MD,";
				addedWins=true;
			}
			if ( getWinByDec() > 0 ) {
				breakdownString += getWinByDec() + " Dec,";
				addedWins=true;
			}
			if ( getWinByFFT() > 0 ) {
				breakdownString += getWinByFFT() + " FFT,";
				addedWins=true;
			}
			if ( addedWins ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "0 W";
		}
		boolean addedLosses=false;
		if ( getLosses() > 0 ) {
			breakdownString += "-" + getLosses() + "L[";
			if ( getLossByFall() > 0 ) {
				breakdownString += getLossByFall() + " Pin,";
				addedLosses=true;
			}
			if ( getLossByTech() > 0 ) {
				breakdownString += getLossByTech() + " TF,";
				addedLosses=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getLossByMD() + " MD,";
				addedLosses=true;
			}
			if ( getLossByDec() > 0 ) {
				breakdownString += getLossByDec() + " Dec,";
				addedLosses=true;
			}
			
			if ( addedLosses ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "-0L";
		}
		if ( getWins() ==0 && getLosses() == 0 ) {
			return "";
		} else {
			return breakdownString +" - "+ getWeight();
		}
	}
	public String getName() { return name; }
	public String getSeed() { return seed; }
	public String getCert() { return cert; }
	public String getTeamName() { return teamName; }
	public WrestlingLanguage.Grade getGrade() { return grade; }
	public WrestlingLanguage.Gender getGender() { return gender; }
	public String getTrackRecord() { return trackRecord; }
	public String getTrackWtClass() { return trackWtClass; }
	
	public int getWins() { return wins; }
	public int getLosses() { return losses; }
	
	public int getWinByFFT() { return winByFFT; }
	public int getWinByFall() { return winByFall; }
	public int getWinByTech() { return winByTech; }
	public int getWinByMD() { return winByMD; }
	public int getWinByDec() { return winByDec; }
	
	public int getLossByFFT() { return lossByFFT; }
	public int getLossByFall() { return lossByFall; }
	public int getLossByTech() { return lossByTech; }
	public int getLossByMD() { return lossByMD; }
	public int getLossByDec() { return lossByDec; }
	
    public Wrestler(String n, String team){
		setName(n);
		setTeamName(team);
		return;
	}
	public boolean getRosteredLastYear() { return rosteredLastYear; }
	
	public void setRosteredLastYearOn() { rosteredLastYear = true; }
	public void setRosteredLastYearOff() { rosteredLastYear = false; }
	
	public String getTrackLastYearWtClass() { return trackLastYearWtClass; }
	public String getTrackLastYearRecord() { return trackLastYearRecord; }
	
	public void setTrackLastYearWtClass(String w) { 
		trackLastYearWtClass = w; 
	}
	public void setTrackLastYearRecord(String r) {
		trackLastYearRecord = r;
	}
	
	
	public void addBout(Bout b) {
		String cmd=b.getMatchDate();
		if (cmd == null ) {
			Event e = b.getEvent();
			if ( e != null ) {
				String sss = e.getEventTitle();
				if ( wiHistory != null ) {
					String s = wiHistory.findWeighInDate(sss);
					if ( s != null ) { 
						b.setMatchDate(s);
					}
				}
			}
		}	
		
		bouts.add(b);
		addToSummary(b);
		addToMatchesAtWeight(b);
	}
	private void addToMatchesAtWeight(Bout b) {
		String w=b.getWeight();
		Integer ct = matchesAtWeight.get(w);
		if ( ct != null ) {
			ct++;
			matchesAtWeight.replace(w,ct);
		} else {
			matchesAtWeight.put(w,1);
		}
		return;
	}
	public String getMatchesAtWeightString() {

		String byWt="";
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
	
			int ct = matchesAtWeight.get(key);
			if ( byWt.length() > 0 ) { byWt=byWt + ";" ; }
			byWt=byWt + ct + "@" + key;
		}
		return byWt;
	}
	
	public void setName( String n ) {
		name = n.strip();
	}
	public void setSeed( String n ) {
		seed = n.strip();
	}
	public void setCert( String n ) {
		cert = n.strip();
	}
	public void setTeamName( String team ) {
		teamName = team;
	}
	public void setGrade5() { grade = WrestlingLanguage.Grade.G5;	}
	public void setGrade6() { grade = WrestlingLanguage.Grade.G6;	}
	public void setGrade7() { grade = WrestlingLanguage.Grade.G7;	}
	public void setGrade8() { grade = WrestlingLanguage.Grade.G8;	}
	public void setGrade(WrestlingLanguage.Grade g ) { grade=g; }
	
	public void setGenderM() { gender = WrestlingLanguage.Gender.M;	}
	public void setGenderF() { gender = WrestlingLanguage.Gender.F;	}
	public void setGender(WrestlingLanguage.Gender g ) { gender = g; }
	
	public void setTrackRecord(String rec) {
		trackRecord = rec;
	}
	public void setTrackWtClass(String w ) {
		trackWtClass = w;
	}
	public String toString() {
		return "Wrestler:" + teamName + ":" + name  ;
	}
	private void addToSummary(Bout b) {
	   if ( b.isAWin() ) {
          addWin();	
          switch ( b.getMatchResultType() ) {
			  case FFT: 
			    addWinByFFT();
				break;
			  case FALL:
			    addWinByFall();
				break;
			  case TECH:
			    addWinByTech();
				break;
			  case MD:
			    addWinByMD();
			    break;
			  case DEC:
			    addWinByDec();
				break;
			  case INJ:
			    break;
			  case DQ:
			    break;
		  }
       } else {
          addLoss();
          switch ( b.getMatchResultType() ) {

          case FFT:
			  addLossByFFT();
			    break;
			  case FALL:
			    addLossByFall();
				break;
			  case TECH:
			    addLossByTech();
				break;
			  case MD:
			    addLossByMD();
			    break;
			  case DEC:
			    addLossByDec();
				break;
			  case INJ:
			    if ( lossByInjury) {
			    	lossByInjuryString += ";";
			    } else {
			    	lossByInjury=true;
			    	lossByInjuryString= "Loss by Injury on ";
			    }
			    if ( b.getMatchDate() != null ) {
			    	lossByInjuryString += b.getMatchDate();
			    	lossByInjuryString += " ";
			    }
			    lossByInjuryString += " vs ";
			    lossByInjuryString += b.getOpponentTeam();
			    
			    break;
			  case DQ:
			    break;
		  }		  
       }		  
	}
	public void addWin() { wins++; }
	public void addLoss() { losses++; }
	public void addWinByFFT() { winByFFT++; }
	public void addWinByFall() { winByFall++; }
	public void addWinByTech() { winByTech++; }
	public void addWinByMD() { winByMD++; }
	public void addWinByDec() { winByDec++; }
	
	public void addLossByFFT() { lossByFFT++; }
	public void addLossByFall() { lossByFall++; }
	public void addLossByTech() { lossByTech++; }
	public void addLossByMD() { lossByMD++; }
	public void addLossByDec() { lossByDec++; }

	public boolean equals(Object o) {
	  if ( o == null ) { return false; }
	  if ( this == o ) { return true; }
	  if ( this.getClass() == o.getClass() ){
         Wrestler ow = (Wrestler) o;		  
	     if ( this.getName().equals(ow.getName()) && this.getTeamName().equals(ow.getTeamName())) {
			 return true;
	     }
	  }
	  return false; 
	}
	public int hashCode() {
		return getName().hashCode() + getTeamName().hashCode();
	}


public String getFinWeight() {
	String finWeight = "";
	boolean a = playedMatch();
	
	if(cert != null) {
		finWeight = cert;
	}
	else (this.cert == null&&this.playedMatch()== true){
		finWeight = this.getLowestWeightWrestled();
	}
	
	return finWeight;
}

public boolean playedMatch() {
	if (matchWeight == null) {
		return false;
}	
	return true;
}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-10-13 22:33:09.946
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-10-13 22:33:09.946
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-13 22:33:10.033
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package JuniorHigh;

import java.util.*;
import java.util.Enumeration;

/*
 *
 *  This is a class to holds an wrestler and all data pertaining to him/her.
 */
class Wrestler {
	private String name;
	private String seed;
	private String cert;
	private String teamName;
	private WrestlingLanguage.Grade grade;
	private WrestlingLanguage.Gender gender;
	private String trackRecord;
	private String trackWtClass;
	private boolean rosteredLastYear;
	private String trackLastYearWtClass;
	private String trackLastYearRecord;
	private WrestlingLanguage.Prestige prestigeLastYear;
	private WrestlingLanguage.Prestige prestige2YearsAgo;
	private WrestlingLanguage.Prestige prestige3YearsAgo;
	
	private Hashtable<String,Integer> matchesAtWeight=new Hashtable<String,Integer>();
	
	private int wins;
	private int losses;
	private boolean lossByInjury=false;
	private String lossByInjuryString;
	private int winByFFT;
	private int lossByFFT;

	private int winByFall;
	private int winByDec;
	private int winByMD;
	private int winByTech;
	
	private int lossByFall;
	private int lossByDec;
	private int lossByMD;
	private int lossByTech;
	
	private int weight;
	
	private Hashtable<Integer,Integer> matchWeight=new Hashtable<Integer,Integer>();

		
	private WeighInHistory wiHistory;
	
	/* These 2 attributes are used to force where we put the wrestler in the reporting
	 * order.
	 */
	private String forceWeight=null;  /* for reporting force the use of this weight class. */
	private Integer forceRank=null;  /* for reporting this is the rank order withing the weight class. */

	public void setLossByInjuryString(String s) {
		lossByInjuryString = s;
	}
	public String getLossByInjuryString() { return lossByInjuryString; }
	
	public String getLowestWeightWrestled() {
		int lowInt=99999;
		
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
			int i =  Integer.parseInt(key);
		    if (i < lowInt ) {
		    	lowInt = i;
		    }
		}
		return Integer.toString(lowInt);
	}
	public String getPrintWeight() {
		if ( forceWeight != null ) {
			if ( forceWeight.length() > 0 ) {
				return forceWeight;
			}
		}
		return getLowestWeightWrestled();
	}
	public int getPrintRank() {
		if (forceRank == null ) {
			return getWins() + getLosses();
		} else {
			return 100000 - forceRank.intValue();
		}
	}
	public String getForceWeight() { return forceWeight; }
	public Integer getForceRank() { return forceRank; }
	
	public void setWeight( int w ) { 
		if (matchWeight.containsKey(w)) {
			int val =matchWeight.get(w);
			matchWeight.put(w, val+1);
			
		}
		else {
		matchWeight.put(w, 1);	
		}
		
	}
	public String getWeight() {
		Enumeration<Integer> e = matchWeight.keys();
		String WeightString="";
		while (e.hasMoreElements()) {
			 
	            // Getting the key of a particular entry
	            int keyWeight = e.nextElement();
	            int valueCount = matchWeight.get(keyWeight);
	            
	            WeightString += Integer.toString(valueCount) + "@" + Integer.toString(keyWeight) + " - ";
	             
	          
	        }
		return WeightString;
		
	}


	
	public void setForceWeight( String w ) { forceWeight = w; }
	public void setForceRank ( Integer i ) { forceRank = i; }
	
	List<Bout> bouts = new ArrayList<Bout> ();

	public List<Bout> getBouts() { return bouts; }
	
	public boolean getLossByInjury() { return lossByInjury; }
	
	public WeighInHistory getWeighInHistory() { return wiHistory; }
	
	public void setWeighInHistory(WeighInHistory wih ) { wiHistory = wih; }

	public void setPrestigeLastYear(WrestlingLanguage.Prestige p) { prestigeLastYear = p; }
	public void setPrestige2YearsAgo(WrestlingLanguage.Prestige p) { prestige2YearsAgo= p; }
	public void setPrestige3YearsAgo(WrestlingLanguage.Prestige p) { prestige3YearsAgo = p; }

	public WrestlingLanguage.Prestige getPrestigeLastYear() { return prestigeLastYear; }
	public WrestlingLanguage.Prestige getPrestige2YearsAgo() { return prestige2YearsAgo; }
	public WrestlingLanguage.Prestige getPrestige3YearsAgo() { return prestige3YearsAgo; }

    public void printVerbose () {
		System.out.println( getName() + 
			" Grade<" + getGrade() + ">" + 
			" Seed<" + getSeed() + ">" +
			" Cert<" + getCert() + ">"); 
			//" Gender<" + getGender() + "> Wt<" + 
			//getTrackWtClass() + ">" + " (" + getWins() + "W-" + 
			//getLosses() + "L) Last Year=<" + rosteredLastYear + "> Last Year Record <" + trackLastYearRecord + ">" );
    }	   
	public String getRecordString() { 
		return String.valueOf(wins) + "-" + String.valueOf(losses); 
	}
	public String getRecordBreakdown() {
		String breakdownString = "";
		boolean addedWins=false;
		if ( getWins() > 0 ) {
			breakdownString += getWins() + "W[";
			if ( getWinByFall() > 0 ) {
				breakdownString += getWinByFall() + " Pin,";
				addedWins=true;
			}
			if ( getWinByTech() > 0 ) {
				breakdownString += getWinByTech() + " TF,";
				addedWins=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getWinByMD() + " MD,";
				addedWins=true;
			}
			if ( getWinByDec() > 0 ) {
				breakdownString += getWinByDec() + " Dec,";
				addedWins=true;
			}
			if ( getWinByFFT() > 0 ) {
				breakdownString += getWinByFFT() + " FFT,";
				addedWins=true;
			}
			if ( addedWins ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "0 W";
		}
		boolean addedLosses=false;
		if ( getLosses() > 0 ) {
			breakdownString += "-" + getLosses() + "L[";
			if ( getLossByFall() > 0 ) {
				breakdownString += getLossByFall() + " Pin,";
				addedLosses=true;
			}
			if ( getLossByTech() > 0 ) {
				breakdownString += getLossByTech() + " TF,";
				addedLosses=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getLossByMD() + " MD,";
				addedLosses=true;
			}
			if ( getLossByDec() > 0 ) {
				breakdownString += getLossByDec() + " Dec,";
				addedLosses=true;
			}
			
			if ( addedLosses ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "-0L";
		}
		if ( getWins() ==0 && getLosses() == 0 ) {
			return "";
		} else {
			return breakdownString +" - "+ getWeight();
		}
	}
	public String getName() { return name; }
	public String getSeed() { return seed; }
	public String getCert() { return cert; }
	public String getTeamName() { return teamName; }
	public WrestlingLanguage.Grade getGrade() { return grade; }
	public WrestlingLanguage.Gender getGender() { return gender; }
	public String getTrackRecord() { return trackRecord; }
	public String getTrackWtClass() { return trackWtClass; }
	
	public int getWins() { return wins; }
	public int getLosses() { return losses; }
	
	public int getWinByFFT() { return winByFFT; }
	public int getWinByFall() { return winByFall; }
	public int getWinByTech() { return winByTech; }
	public int getWinByMD() { return winByMD; }
	public int getWinByDec() { return winByDec; }
	
	public int getLossByFFT() { return lossByFFT; }
	public int getLossByFall() { return lossByFall; }
	public int getLossByTech() { return lossByTech; }
	public int getLossByMD() { return lossByMD; }
	public int getLossByDec() { return lossByDec; }
	
    public Wrestler(String n, String team){
		setName(n);
		setTeamName(team);
		return;
	}
	public boolean getRosteredLastYear() { return rosteredLastYear; }
	
	public void setRosteredLastYearOn() { rosteredLastYear = true; }
	public void setRosteredLastYearOff() { rosteredLastYear = false; }
	
	public String getTrackLastYearWtClass() { return trackLastYearWtClass; }
	public String getTrackLastYearRecord() { return trackLastYearRecord; }
	
	public void setTrackLastYearWtClass(String w) { 
		trackLastYearWtClass = w; 
	}
	public void setTrackLastYearRecord(String r) {
		trackLastYearRecord = r;
	}
	
	
	public void addBout(Bout b) {
		String cmd=b.getMatchDate();
		if (cmd == null ) {
			Event e = b.getEvent();
			if ( e != null ) {
				String sss = e.getEventTitle();
				if ( wiHistory != null ) {
					String s = wiHistory.findWeighInDate(sss);
					if ( s != null ) { 
						b.setMatchDate(s);
					}
				}
			}
		}	
		
		bouts.add(b);
		addToSummary(b);
		addToMatchesAtWeight(b);
	}
	private void addToMatchesAtWeight(Bout b) {
		String w=b.getWeight();
		Integer ct = matchesAtWeight.get(w);
		if ( ct != null ) {
			ct++;
			matchesAtWeight.replace(w,ct);
		} else {
			matchesAtWeight.put(w,1);
		}
		return;
	}
	public String getMatchesAtWeightString() {

		String byWt="";
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
	
			int ct = matchesAtWeight.get(key);
			if ( byWt.length() > 0 ) { byWt=byWt + ";" ; }
			byWt=byWt + ct + "@" + key;
		}
		return byWt;
	}
	
	public void setName( String n ) {
		name = n.strip();
	}
	public void setSeed( String n ) {
		seed = n.strip();
	}
	public void setCert( String n ) {
		cert = n.strip();
	}
	public void setTeamName( String team ) {
		teamName = team;
	}
	public void setGrade5() { grade = WrestlingLanguage.Grade.G5;	}
	public void setGrade6() { grade = WrestlingLanguage.Grade.G6;	}
	public void setGrade7() { grade = WrestlingLanguage.Grade.G7;	}
	public void setGrade8() { grade = WrestlingLanguage.Grade.G8;	}
	public void setGrade(WrestlingLanguage.Grade g ) { grade=g; }
	
	public void setGenderM() { gender = WrestlingLanguage.Gender.M;	}
	public void setGenderF() { gender = WrestlingLanguage.Gender.F;	}
	public void setGender(WrestlingLanguage.Gender g ) { gender = g; }
	
	public void setTrackRecord(String rec) {
		trackRecord = rec;
	}
	public void setTrackWtClass(String w ) {
		trackWtClass = w;
	}
	public String toString() {
		return "Wrestler:" + teamName + ":" + name  ;
	}
	private void addToSummary(Bout b) {
	   if ( b.isAWin() ) {
          addWin();	
          switch ( b.getMatchResultType() ) {
			  case FFT: 
			    addWinByFFT();
				break;
			  case FALL:
			    addWinByFall();
				break;
			  case TECH:
			    addWinByTech();
				break;
			  case MD:
			    addWinByMD();
			    break;
			  case DEC:
			    addWinByDec();
				break;
			  case INJ:
			    break;
			  case DQ:
			    break;
		  }
       } else {
          addLoss();
          switch ( b.getMatchResultType() ) {

          case FFT:
			  addLossByFFT();
			    break;
			  case FALL:
			    addLossByFall();
				break;
			  case TECH:
			    addLossByTech();
				break;
			  case MD:
			    addLossByMD();
			    break;
			  case DEC:
			    addLossByDec();
				break;
			  case INJ:
			    if ( lossByInjury) {
			    	lossByInjuryString += ";";
			    } else {
			    	lossByInjury=true;
			    	lossByInjuryString= "Loss by Injury on ";
			    }
			    if ( b.getMatchDate() != null ) {
			    	lossByInjuryString += b.getMatchDate();
			    	lossByInjuryString += " ";
			    }
			    lossByInjuryString += " vs ";
			    lossByInjuryString += b.getOpponentTeam();
			    
			    break;
			  case DQ:
			    break;
		  }		  
       }		  
	}
	public void addWin() { wins++; }
	public void addLoss() { losses++; }
	public void addWinByFFT() { winByFFT++; }
	public void addWinByFall() { winByFall++; }
	public void addWinByTech() { winByTech++; }
	public void addWinByMD() { winByMD++; }
	public void addWinByDec() { winByDec++; }
	
	public void addLossByFFT() { lossByFFT++; }
	public void addLossByFall() { lossByFall++; }
	public void addLossByTech() { lossByTech++; }
	public void addLossByMD() { lossByMD++; }
	public void addLossByDec() { lossByDec++; }

	public boolean equals(Object o) {
	  if ( o == null ) { return false; }
	  if ( this == o ) { return true; }
	  if ( this.getClass() == o.getClass() ){
         Wrestler ow = (Wrestler) o;		  
	     if ( this.getName().equals(ow.getName()) && this.getTeamName().equals(ow.getTeamName())) {
			 return true;
	     }
	  }
	  return false; 
	}
	public int hashCode() {
		return getName().hashCode() + getTeamName().hashCode();
	}


public String getFinWeight() {
	String finWeight = "";
	boolean a = playedMatch();
	
	if(cert != null) {
		finWeight = cert;
	}
	else (this.cert == null&&this.playedMatch()== true){
		finWeight = this.getLowestWeightWrestled();
	}
	
	return finWeight;
}

public boolean playedMatch() {
	if (matchWeight == null) {
		return false;
}	
	return true;
}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-10-13 22:33:10.033
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-10-13 22:33:10.033
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-13 22:33:10.044
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package JuniorHigh;

import java.util.*;
import java.util.Enumeration;

/*
 *
 *  This is a class to holds an wrestler and all data pertaining to him/her.
 */
class Wrestler {
	private String name;
	private String seed;
	private String cert;
	private String teamName;
	private WrestlingLanguage.Grade grade;
	private WrestlingLanguage.Gender gender;
	private String trackRecord;
	private String trackWtClass;
	private boolean rosteredLastYear;
	private String trackLastYearWtClass;
	private String trackLastYearRecord;
	private WrestlingLanguage.Prestige prestigeLastYear;
	private WrestlingLanguage.Prestige prestige2YearsAgo;
	private WrestlingLanguage.Prestige prestige3YearsAgo;
	
	private Hashtable<String,Integer> matchesAtWeight=new Hashtable<String,Integer>();
	
	private int wins;
	private int losses;
	private boolean lossByInjury=false;
	private String lossByInjuryString;
	private int winByFFT;
	private int lossByFFT;

	private int winByFall;
	private int winByDec;
	private int winByMD;
	private int winByTech;
	
	private int lossByFall;
	private int lossByDec;
	private int lossByMD;
	private int lossByTech;
	
	private int weight;
	
	private Hashtable<Integer,Integer> matchWeight=new Hashtable<Integer,Integer>();

		
	private WeighInHistory wiHistory;
	
	/* These 2 attributes are used to force where we put the wrestler in the reporting
	 * order.
	 */
	private String forceWeight=null;  /* for reporting force the use of this weight class. */
	private Integer forceRank=null;  /* for reporting this is the rank order withing the weight class. */

	public void setLossByInjuryString(String s) {
		lossByInjuryString = s;
	}
	public String getLossByInjuryString() { return lossByInjuryString; }
	
	public String getLowestWeightWrestled() {
		int lowInt=99999;
		
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
			int i =  Integer.parseInt(key);
		    if (i < lowInt ) {
		    	lowInt = i;
		    }
		}
		return Integer.toString(lowInt);
	}
	public String getPrintWeight() {
		if ( forceWeight != null ) {
			if ( forceWeight.length() > 0 ) {
				return forceWeight;
			}
		}
		return getLowestWeightWrestled();
	}
	public int getPrintRank() {
		if (forceRank == null ) {
			return getWins() + getLosses();
		} else {
			return 100000 - forceRank.intValue();
		}
	}
	public String getForceWeight() { return forceWeight; }
	public Integer getForceRank() { return forceRank; }
	
	public void setWeight( int w ) { 
		if (matchWeight.containsKey(w)) {
			int val =matchWeight.get(w);
			matchWeight.put(w, val+1);
			
		}
		else {
		matchWeight.put(w, 1);	
		}
		
	}
	public String getWeight() {
		Enumeration<Integer> e = matchWeight.keys();
		String WeightString="";
		while (e.hasMoreElements()) {
			 
	            // Getting the key of a particular entry
	            int keyWeight = e.nextElement();
	            int valueCount = matchWeight.get(keyWeight);
	            
	            WeightString += Integer.toString(valueCount) + "@" + Integer.toString(keyWeight) + " - ";
	             
	          
	        }
		return WeightString;
		
	}


	
	public void setForceWeight( String w ) { forceWeight = w; }
	public void setForceRank ( Integer i ) { forceRank = i; }
	
	List<Bout> bouts = new ArrayList<Bout> ();

	public List<Bout> getBouts() { return bouts; }
	
	public boolean getLossByInjury() { return lossByInjury; }
	
	public WeighInHistory getWeighInHistory() { return wiHistory; }
	
	public void setWeighInHistory(WeighInHistory wih ) { wiHistory = wih; }

	public void setPrestigeLastYear(WrestlingLanguage.Prestige p) { prestigeLastYear = p; }
	public void setPrestige2YearsAgo(WrestlingLanguage.Prestige p) { prestige2YearsAgo= p; }
	public void setPrestige3YearsAgo(WrestlingLanguage.Prestige p) { prestige3YearsAgo = p; }

	public WrestlingLanguage.Prestige getPrestigeLastYear() { return prestigeLastYear; }
	public WrestlingLanguage.Prestige getPrestige2YearsAgo() { return prestige2YearsAgo; }
	public WrestlingLanguage.Prestige getPrestige3YearsAgo() { return prestige3YearsAgo; }

    public void printVerbose () {
		System.out.println( getName() + 
			" Grade<" + getGrade() + ">" + 
			" Seed<" + getSeed() + ">" +
			" Cert<" + getCert() + ">"); 
			//" Gender<" + getGender() + "> Wt<" + 
			//getTrackWtClass() + ">" + " (" + getWins() + "W-" + 
			//getLosses() + "L) Last Year=<" + rosteredLastYear + "> Last Year Record <" + trackLastYearRecord + ">" );
    }	   
	public String getRecordString() { 
		return String.valueOf(wins) + "-" + String.valueOf(losses); 
	}
	public String getRecordBreakdown() {
		String breakdownString = "";
		boolean addedWins=false;
		if ( getWins() > 0 ) {
			breakdownString += getWins() + "W[";
			if ( getWinByFall() > 0 ) {
				breakdownString += getWinByFall() + " Pin,";
				addedWins=true;
			}
			if ( getWinByTech() > 0 ) {
				breakdownString += getWinByTech() + " TF,";
				addedWins=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getWinByMD() + " MD,";
				addedWins=true;
			}
			if ( getWinByDec() > 0 ) {
				breakdownString += getWinByDec() + " Dec,";
				addedWins=true;
			}
			if ( getWinByFFT() > 0 ) {
				breakdownString += getWinByFFT() + " FFT,";
				addedWins=true;
			}
			if ( addedWins ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "0 W";
		}
		boolean addedLosses=false;
		if ( getLosses() > 0 ) {
			breakdownString += "-" + getLosses() + "L[";
			if ( getLossByFall() > 0 ) {
				breakdownString += getLossByFall() + " Pin,";
				addedLosses=true;
			}
			if ( getLossByTech() > 0 ) {
				breakdownString += getLossByTech() + " TF,";
				addedLosses=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getLossByMD() + " MD,";
				addedLosses=true;
			}
			if ( getLossByDec() > 0 ) {
				breakdownString += getLossByDec() + " Dec,";
				addedLosses=true;
			}
			
			if ( addedLosses ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "-0L";
		}
		if ( getWins() ==0 && getLosses() == 0 ) {
			return "";
		} else {
			return breakdownString +" - "+ getWeight();
		}
	}
	public String getName() { return name; }
	public String getSeed() { return seed; }
	public String getCert() { return cert; }
	public String getTeamName() { return teamName; }
	public WrestlingLanguage.Grade getGrade() { return grade; }
	public WrestlingLanguage.Gender getGender() { return gender; }
	public String getTrackRecord() { return trackRecord; }
	public String getTrackWtClass() { return trackWtClass; }
	
	public int getWins() { return wins; }
	public int getLosses() { return losses; }
	
	public int getWinByFFT() { return winByFFT; }
	public int getWinByFall() { return winByFall; }
	public int getWinByTech() { return winByTech; }
	public int getWinByMD() { return winByMD; }
	public int getWinByDec() { return winByDec; }
	
	public int getLossByFFT() { return lossByFFT; }
	public int getLossByFall() { return lossByFall; }
	public int getLossByTech() { return lossByTech; }
	public int getLossByMD() { return lossByMD; }
	public int getLossByDec() { return lossByDec; }
	
    public Wrestler(String n, String team){
		setName(n);
		setTeamName(team);
		return;
	}
	public boolean getRosteredLastYear() { return rosteredLastYear; }
	
	public void setRosteredLastYearOn() { rosteredLastYear = true; }
	public void setRosteredLastYearOff() { rosteredLastYear = false; }
	
	public String getTrackLastYearWtClass() { return trackLastYearWtClass; }
	public String getTrackLastYearRecord() { return trackLastYearRecord; }
	
	public void setTrackLastYearWtClass(String w) { 
		trackLastYearWtClass = w; 
	}
	public void setTrackLastYearRecord(String r) {
		trackLastYearRecord = r;
	}
	
	
	public void addBout(Bout b) {
		String cmd=b.getMatchDate();
		if (cmd == null ) {
			Event e = b.getEvent();
			if ( e != null ) {
				String sss = e.getEventTitle();
				if ( wiHistory != null ) {
					String s = wiHistory.findWeighInDate(sss);
					if ( s != null ) { 
						b.setMatchDate(s);
					}
				}
			}
		}	
		
		bouts.add(b);
		addToSummary(b);
		addToMatchesAtWeight(b);
	}
	private void addToMatchesAtWeight(Bout b) {
		String w=b.getWeight();
		Integer ct = matchesAtWeight.get(w);
		if ( ct != null ) {
			ct++;
			matchesAtWeight.replace(w,ct);
		} else {
			matchesAtWeight.put(w,1);
		}
		return;
	}
	public String getMatchesAtWeightString() {

		String byWt="";
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
	
			int ct = matchesAtWeight.get(key);
			if ( byWt.length() > 0 ) { byWt=byWt + ";" ; }
			byWt=byWt + ct + "@" + key;
		}
		return byWt;
	}
	
	public void setName( String n ) {
		name = n.strip();
	}
	public void setSeed( String n ) {
		seed = n.strip();
	}
	public void setCert( String n ) {
		cert = n.strip();
	}
	public void setTeamName( String team ) {
		teamName = team;
	}
	public void setGrade5() { grade = WrestlingLanguage.Grade.G5;	}
	public void setGrade6() { grade = WrestlingLanguage.Grade.G6;	}
	public void setGrade7() { grade = WrestlingLanguage.Grade.G7;	}
	public void setGrade8() { grade = WrestlingLanguage.Grade.G8;	}
	public void setGrade(WrestlingLanguage.Grade g ) { grade=g; }
	
	public void setGenderM() { gender = WrestlingLanguage.Gender.M;	}
	public void setGenderF() { gender = WrestlingLanguage.Gender.F;	}
	public void setGender(WrestlingLanguage.Gender g ) { gender = g; }
	
	public void setTrackRecord(String rec) {
		trackRecord = rec;
	}
	public void setTrackWtClass(String w ) {
		trackWtClass = w;
	}
	public String toString() {
		return "Wrestler:" + teamName + ":" + name  ;
	}
	private void addToSummary(Bout b) {
	   if ( b.isAWin() ) {
          addWin();	
          switch ( b.getMatchResultType() ) {
			  case FFT: 
			    addWinByFFT();
				break;
			  case FALL:
			    addWinByFall();
				break;
			  case TECH:
			    addWinByTech();
				break;
			  case MD:
			    addWinByMD();
			    break;
			  case DEC:
			    addWinByDec();
				break;
			  case INJ:
			    break;
			  case DQ:
			    break;
		  }
       } else {
          addLoss();
          switch ( b.getMatchResultType() ) {

          case FFT:
			  addLossByFFT();
			    break;
			  case FALL:
			    addLossByFall();
				break;
			  case TECH:
			    addLossByTech();
				break;
			  case MD:
			    addLossByMD();
			    break;
			  case DEC:
			    addLossByDec();
				break;
			  case INJ:
			    if ( lossByInjury) {
			    	lossByInjuryString += ";";
			    } else {
			    	lossByInjury=true;
			    	lossByInjuryString= "Loss by Injury on ";
			    }
			    if ( b.getMatchDate() != null ) {
			    	lossByInjuryString += b.getMatchDate();
			    	lossByInjuryString += " ";
			    }
			    lossByInjuryString += " vs ";
			    lossByInjuryString += b.getOpponentTeam();
			    
			    break;
			  case DQ:
			    break;
		  }		  
       }		  
	}
	public void addWin() { wins++; }
	public void addLoss() { losses++; }
	public void addWinByFFT() { winByFFT++; }
	public void addWinByFall() { winByFall++; }
	public void addWinByTech() { winByTech++; }
	public void addWinByMD() { winByMD++; }
	public void addWinByDec() { winByDec++; }
	
	public void addLossByFFT() { lossByFFT++; }
	public void addLossByFall() { lossByFall++; }
	public void addLossByTech() { lossByTech++; }
	public void addLossByMD() { lossByMD++; }
	public void addLossByDec() { lossByDec++; }

	public boolean equals(Object o) {
	  if ( o == null ) { return false; }
	  if ( this == o ) { return true; }
	  if ( this.getClass() == o.getClass() ){
         Wrestler ow = (Wrestler) o;		  
	     if ( this.getName().equals(ow.getName()) && this.getTeamName().equals(ow.getTeamName())) {
			 return true;
	     }
	  }
	  return false; 
	}
	public int hashCode() {
		return getName().hashCode() + getTeamName().hashCode();
	}


public String getFinWeight() {
	String finWeight = "";
	boolean a = playedMatch();
	
	if(cert != null) {
		finWeight = cert;
	}
	else (this.cert == null&&this.playedMatch()== true){
		finWeight = this.getLowestWeightWrestled();
	}
	
	return finWeight;
}

public boolean playedMatch() {
	if (matchWeight == null) {
		return false;
}	
	return true;
}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-13 22:33:10.045
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-13 22:33:10.046
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-13 22:33:12.368
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package JuniorHigh;

import java.util.*;
import java.util.Enumeration;

/*
 *
 *  This is a class to holds an wrestler and all data pertaining to him/her.
 */
class Wrestler {
	private String name;
	private String seed;
	private String cert;
	private String teamName;
	private WrestlingLanguage.Grade grade;
	private WrestlingLanguage.Gender gender;
	private String trackRecord;
	private String trackWtClass;
	private boolean rosteredLastYear;
	private String trackLastYearWtClass;
	private String trackLastYearRecord;
	private WrestlingLanguage.Prestige prestigeLastYear;
	private WrestlingLanguage.Prestige prestige2YearsAgo;
	private WrestlingLanguage.Prestige prestige3YearsAgo;
	
	private Hashtable<String,Integer> matchesAtWeight=new Hashtable<String,Integer>();
	
	private int wins;
	private int losses;
	private boolean lossByInjury=false;
	private String lossByInjuryString;
	private int winByFFT;
	private int lossByFFT;

	private int winByFall;
	private int winByDec;
	private int winByMD;
	private int winByTech;
	
	private int lossByFall;
	private int lossByDec;
	private int lossByMD;
	private int lossByTech;
	
	private int weight;
	
	private Hashtable<Integer,Integer> matchWeight=new Hashtable<Integer,Integer>();

		
	private WeighInHistory wiHistory;
	
	/* These 2 attributes are used to force where we put the wrestler in the reporting
	 * order.
	 */
	private String forceWeight=null;  /* for reporting force the use of this weight class. */
	private Integer forceRank=null;  /* for reporting this is the rank order withing the weight class. */

	public void setLossByInjuryString(String s) {
		lossByInjuryString = s;
	}
	public String getLossByInjuryString() { return lossByInjuryString; }
	
	public String getLowestWeightWrestled() {
		int lowInt=99999;
		
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
			int i =  Integer.parseInt(key);
		    if (i < lowInt ) {
		    	lowInt = i;
		    }
		}
		return Integer.toString(lowInt);
	}
	public String getPrintWeight() {
		if ( forceWeight != null ) {
			if ( forceWeight.length() > 0 ) {
				return forceWeight;
			}
		}
		return getLowestWeightWrestled();
	}
	public int getPrintRank() {
		if (forceRank == null ) {
			return getWins() + getLosses();
		} else {
			return 100000 - forceRank.intValue();
		}
	}
	public String getForceWeight() { return forceWeight; }
	public Integer getForceRank() { return forceRank; }
	
	public void setWeight( int w ) { 
		if (matchWeight.containsKey(w)) {
			int val =matchWeight.get(w);
			matchWeight.put(w, val+1);
			
		}
		else {
		matchWeight.put(w, 1);	
		}
		
	}
	public String getWeight() {
		Enumeration<Integer> e = matchWeight.keys();
		String WeightString="";
		while (e.hasMoreElements()) {
			 
	            // Getting the key of a particular entry
	            int keyWeight = e.nextElement();
	            int valueCount = matchWeight.get(keyWeight);
	            
	            WeightString += Integer.toString(valueCount) + "@" + Integer.toString(keyWeight) + " - ";
	             
	          
	        }
		return WeightString;
		
	}


	
	public void setForceWeight( String w ) { forceWeight = w; }
	public void setForceRank ( Integer i ) { forceRank = i; }
	
	List<Bout> bouts = new ArrayList<Bout> ();

	public List<Bout> getBouts() { return bouts; }
	
	public boolean getLossByInjury() { return lossByInjury; }
	
	public WeighInHistory getWeighInHistory() { return wiHistory; }
	
	public void setWeighInHistory(WeighInHistory wih ) { wiHistory = wih; }

	public void setPrestigeLastYear(WrestlingLanguage.Prestige p) { prestigeLastYear = p; }
	public void setPrestige2YearsAgo(WrestlingLanguage.Prestige p) { prestige2YearsAgo= p; }
	public void setPrestige3YearsAgo(WrestlingLanguage.Prestige p) { prestige3YearsAgo = p; }

	public WrestlingLanguage.Prestige getPrestigeLastYear() { return prestigeLastYear; }
	public WrestlingLanguage.Prestige getPrestige2YearsAgo() { return prestige2YearsAgo; }
	public WrestlingLanguage.Prestige getPrestige3YearsAgo() { return prestige3YearsAgo; }

    public void printVerbose () {
		System.out.println( getName() + 
			" Grade<" + getGrade() + ">" + 
			" Seed<" + getSeed() + ">" +
			" Cert<" + getCert() + ">"); 
			//" Gender<" + getGender() + "> Wt<" + 
			//getTrackWtClass() + ">" + " (" + getWins() + "W-" + 
			//getLosses() + "L) Last Year=<" + rosteredLastYear + "> Last Year Record <" + trackLastYearRecord + ">" );
    }	   
	public String getRecordString() { 
		return String.valueOf(wins) + "-" + String.valueOf(losses); 
	}
	public String getRecordBreakdown() {
		String breakdownString = "";
		boolean addedWins=false;
		if ( getWins() > 0 ) {
			breakdownString += getWins() + "W[";
			if ( getWinByFall() > 0 ) {
				breakdownString += getWinByFall() + " Pin,";
				addedWins=true;
			}
			if ( getWinByTech() > 0 ) {
				breakdownString += getWinByTech() + " TF,";
				addedWins=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getWinByMD() + " MD,";
				addedWins=true;
			}
			if ( getWinByDec() > 0 ) {
				breakdownString += getWinByDec() + " Dec,";
				addedWins=true;
			}
			if ( getWinByFFT() > 0 ) {
				breakdownString += getWinByFFT() + " FFT,";
				addedWins=true;
			}
			if ( addedWins ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "0 W";
		}
		boolean addedLosses=false;
		if ( getLosses() > 0 ) {
			breakdownString += "-" + getLosses() + "L[";
			if ( getLossByFall() > 0 ) {
				breakdownString += getLossByFall() + " Pin,";
				addedLosses=true;
			}
			if ( getLossByTech() > 0 ) {
				breakdownString += getLossByTech() + " TF,";
				addedLosses=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getLossByMD() + " MD,";
				addedLosses=true;
			}
			if ( getLossByDec() > 0 ) {
				breakdownString += getLossByDec() + " Dec,";
				addedLosses=true;
			}
			
			if ( addedLosses ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "-0L";
		}
		if ( getWins() ==0 && getLosses() == 0 ) {
			return "";
		} else {
			return breakdownString +" - "+ getWeight();
		}
	}
	public String getName() { return name; }
	public String getSeed() { return seed; }
	public String getCert() { return cert; }
	public String getTeamName() { return teamName; }
	public WrestlingLanguage.Grade getGrade() { return grade; }
	public WrestlingLanguage.Gender getGender() { return gender; }
	public String getTrackRecord() { return trackRecord; }
	public String getTrackWtClass() { return trackWtClass; }
	
	public int getWins() { return wins; }
	public int getLosses() { return losses; }
	
	public int getWinByFFT() { return winByFFT; }
	public int getWinByFall() { return winByFall; }
	public int getWinByTech() { return winByTech; }
	public int getWinByMD() { return winByMD; }
	public int getWinByDec() { return winByDec; }
	
	public int getLossByFFT() { return lossByFFT; }
	public int getLossByFall() { return lossByFall; }
	public int getLossByTech() { return lossByTech; }
	public int getLossByMD() { return lossByMD; }
	public int getLossByDec() { return lossByDec; }
	
    public Wrestler(String n, String team){
		setName(n);
		setTeamName(team);
		return;
	}
	public boolean getRosteredLastYear() { return rosteredLastYear; }
	
	public void setRosteredLastYearOn() { rosteredLastYear = true; }
	public void setRosteredLastYearOff() { rosteredLastYear = false; }
	
	public String getTrackLastYearWtClass() { return trackLastYearWtClass; }
	public String getTrackLastYearRecord() { return trackLastYearRecord; }
	
	public void setTrackLastYearWtClass(String w) { 
		trackLastYearWtClass = w; 
	}
	public void setTrackLastYearRecord(String r) {
		trackLastYearRecord = r;
	}
	
	
	public void addBout(Bout b) {
		String cmd=b.getMatchDate();
		if (cmd == null ) {
			Event e = b.getEvent();
			if ( e != null ) {
				String sss = e.getEventTitle();
				if ( wiHistory != null ) {
					String s = wiHistory.findWeighInDate(sss);
					if ( s != null ) { 
						b.setMatchDate(s);
					}
				}
			}
		}	
		
		bouts.add(b);
		addToSummary(b);
		addToMatchesAtWeight(b);
	}
	private void addToMatchesAtWeight(Bout b) {
		String w=b.getWeight();
		Integer ct = matchesAtWeight.get(w);
		if ( ct != null ) {
			ct++;
			matchesAtWeight.replace(w,ct);
		} else {
			matchesAtWeight.put(w,1);
		}
		return;
	}
	public String getMatchesAtWeightString() {

		String byWt="";
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
	
			int ct = matchesAtWeight.get(key);
			if ( byWt.length() > 0 ) { byWt=byWt + ";" ; }
			byWt=byWt + ct + "@" + key;
		}
		return byWt;
	}
	
	public void setName( String n ) {
		name = n.strip();
	}
	public void setSeed( String n ) {
		seed = n.strip();
	}
	public void setCert( String n ) {
		cert = n.strip();
	}
	public void setTeamName( String team ) {
		teamName = team;
	}
	public void setGrade5() { grade = WrestlingLanguage.Grade.G5;	}
	public void setGrade6() { grade = WrestlingLanguage.Grade.G6;	}
	public void setGrade7() { grade = WrestlingLanguage.Grade.G7;	}
	public void setGrade8() { grade = WrestlingLanguage.Grade.G8;	}
	public void setGrade(WrestlingLanguage.Grade g ) { grade=g; }
	
	public void setGenderM() { gender = WrestlingLanguage.Gender.M;	}
	public void setGenderF() { gender = WrestlingLanguage.Gender.F;	}
	public void setGender(WrestlingLanguage.Gender g ) { gender = g; }
	
	public void setTrackRecord(String rec) {
		trackRecord = rec;
	}
	public void setTrackWtClass(String w ) {
		trackWtClass = w;
	}
	public String toString() {
		return "Wrestler:" + teamName + ":" + name  ;
	}
	private void addToSummary(Bout b) {
	   if ( b.isAWin() ) {
          addWin();	
          switch ( b.getMatchResultType() ) {
			  case FFT: 
			    addWinByFFT();
				break;
			  case FALL:
			    addWinByFall();
				break;
			  case TECH:
			    addWinByTech();
				break;
			  case MD:
			    addWinByMD();
			    break;
			  case DEC:
			    addWinByDec();
				break;
			  case INJ:
			    break;
			  case DQ:
			    break;
		  }
       } else {
          addLoss();
          switch ( b.getMatchResultType() ) {

          case FFT:
			  addLossByFFT();
			    break;
			  case FALL:
			    addLossByFall();
				break;
			  case TECH:
			    addLossByTech();
				break;
			  case MD:
			    addLossByMD();
			    break;
			  case DEC:
			    addLossByDec();
				break;
			  case INJ:
			    if ( lossByInjury) {
			    	lossByInjuryString += ";";
			    } else {
			    	lossByInjury=true;
			    	lossByInjuryString= "Loss by Injury on ";
			    }
			    if ( b.getMatchDate() != null ) {
			    	lossByInjuryString += b.getMatchDate();
			    	lossByInjuryString += " ";
			    }
			    lossByInjuryString += " vs ";
			    lossByInjuryString += b.getOpponentTeam();
			    
			    break;
			  case DQ:
			    break;
		  }		  
       }		  
	}
	public void addWin() { wins++; }
	public void addLoss() { losses++; }
	public void addWinByFFT() { winByFFT++; }
	public void addWinByFall() { winByFall++; }
	public void addWinByTech() { winByTech++; }
	public void addWinByMD() { winByMD++; }
	public void addWinByDec() { winByDec++; }
	
	public void addLossByFFT() { lossByFFT++; }
	public void addLossByFall() { lossByFall++; }
	public void addLossByTech() { lossByTech++; }
	public void addLossByMD() { lossByMD++; }
	public void addLossByDec() { lossByDec++; }

	public boolean equals(Object o) {
	  if ( o == null ) { return false; }
	  if ( this == o ) { return true; }
	  if ( this.getClass() == o.getClass() ){
         Wrestler ow = (Wrestler) o;		  
	     if ( this.getName().equals(ow.getName()) && this.getTeamName().equals(ow.getTeamName())) {
			 return true;
	     }
	  }
	  return false; 
	}
	public int hashCode() {
		return getName().hashCode() + getTeamName().hashCode();
	}


public String getFinWeight() {
	String finWeight = "";
	boolean a = playedMatch();
	
	if(cert != null) {
		finWeight = cert;
	}
	else (this.cert == null&&this.playedMatch()== true){
		finWeight = this.getLowestWeightWrestled();
	}
	
	return finWeight;
}

public boolean playedMatch() {
	if (matchWeight == null) {
		return false;
}	
	return true;
}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-13 22:33:12.369
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-13 22:33:12.369
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-13 22:33:14.136
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package JuniorHigh;

import java.util.*;
import java.util.Enumeration;

/*
 *
 *  This is a class to holds an wrestler and all data pertaining to him/her.
 */
class Wrestler {
	private String name;
	private String seed;
	private String cert;
	private String teamName;
	private WrestlingLanguage.Grade grade;
	private WrestlingLanguage.Gender gender;
	private String trackRecord;
	private String trackWtClass;
	private boolean rosteredLastYear;
	private String trackLastYearWtClass;
	private String trackLastYearRecord;
	private WrestlingLanguage.Prestige prestigeLastYear;
	private WrestlingLanguage.Prestige prestige2YearsAgo;
	private WrestlingLanguage.Prestige prestige3YearsAgo;
	
	private Hashtable<String,Integer> matchesAtWeight=new Hashtable<String,Integer>();
	
	private int wins;
	private int losses;
	private boolean lossByInjury=false;
	private String lossByInjuryString;
	private int winByFFT;
	private int lossByFFT;

	private int winByFall;
	private int winByDec;
	private int winByMD;
	private int winByTech;
	
	private int lossByFall;
	private int lossByDec;
	private int lossByMD;
	private int lossByTech;
	
	private int weight;
	
	private Hashtable<Integer,Integer> matchWeight=new Hashtable<Integer,Integer>();

		
	private WeighInHistory wiHistory;
	
	/* These 2 attributes are used to force where we put the wrestler in the reporting
	 * order.
	 */
	private String forceWeight=null;  /* for reporting force the use of this weight class. */
	private Integer forceRank=null;  /* for reporting this is the rank order withing the weight class. */

	public void setLossByInjuryString(String s) {
		lossByInjuryString = s;
	}
	public String getLossByInjuryString() { return lossByInjuryString; }
	
	public String getLowestWeightWrestled() {
		int lowInt=99999;
		
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
			int i =  Integer.parseInt(key);
		    if (i < lowInt ) {
		    	lowInt = i;
		    }
		}
		return Integer.toString(lowInt);
	}
	public String getPrintWeight() {
		if ( forceWeight != null ) {
			if ( forceWeight.length() > 0 ) {
				return forceWeight;
			}
		}
		return getLowestWeightWrestled();
	}
	public int getPrintRank() {
		if (forceRank == null ) {
			return getWins() + getLosses();
		} else {
			return 100000 - forceRank.intValue();
		}
	}
	public String getForceWeight() { return forceWeight; }
	public Integer getForceRank() { return forceRank; }
	
	public void setWeight( int w ) { 
		if (matchWeight.containsKey(w)) {
			int val =matchWeight.get(w);
			matchWeight.put(w, val+1);
			
		}
		else {
		matchWeight.put(w, 1);	
		}
		
	}
	public String getWeight() {
		Enumeration<Integer> e = matchWeight.keys();
		String WeightString="";
		while (e.hasMoreElements()) {
			 
	            // Getting the key of a particular entry
	            int keyWeight = e.nextElement();
	            int valueCount = matchWeight.get(keyWeight);
	            
	            WeightString += Integer.toString(valueCount) + "@" + Integer.toString(keyWeight) + " - ";
	             
	          
	        }
		return WeightString;
		
	}


	
	public void setForceWeight( String w ) { forceWeight = w; }
	public void setForceRank ( Integer i ) { forceRank = i; }
	
	List<Bout> bouts = new ArrayList<Bout> ();

	public List<Bout> getBouts() { return bouts; }
	
	public boolean getLossByInjury() { return lossByInjury; }
	
	public WeighInHistory getWeighInHistory() { return wiHistory; }
	
	public void setWeighInHistory(WeighInHistory wih ) { wiHistory = wih; }

	public void setPrestigeLastYear(WrestlingLanguage.Prestige p) { prestigeLastYear = p; }
	public void setPrestige2YearsAgo(WrestlingLanguage.Prestige p) { prestige2YearsAgo= p; }
	public void setPrestige3YearsAgo(WrestlingLanguage.Prestige p) { prestige3YearsAgo = p; }

	public WrestlingLanguage.Prestige getPrestigeLastYear() { return prestigeLastYear; }
	public WrestlingLanguage.Prestige getPrestige2YearsAgo() { return prestige2YearsAgo; }
	public WrestlingLanguage.Prestige getPrestige3YearsAgo() { return prestige3YearsAgo; }

    public void printVerbose () {
		System.out.println( getName() + 
			" Grade<" + getGrade() + ">" + 
			" Seed<" + getSeed() + ">" +
			" Cert<" + getCert() + ">"); 
			//" Gender<" + getGender() + "> Wt<" + 
			//getTrackWtClass() + ">" + " (" + getWins() + "W-" + 
			//getLosses() + "L) Last Year=<" + rosteredLastYear + "> Last Year Record <" + trackLastYearRecord + ">" );
    }	   
	public String getRecordString() { 
		return String.valueOf(wins) + "-" + String.valueOf(losses); 
	}
	public String getRecordBreakdown() {
		String breakdownString = "";
		boolean addedWins=false;
		if ( getWins() > 0 ) {
			breakdownString += getWins() + "W[";
			if ( getWinByFall() > 0 ) {
				breakdownString += getWinByFall() + " Pin,";
				addedWins=true;
			}
			if ( getWinByTech() > 0 ) {
				breakdownString += getWinByTech() + " TF,";
				addedWins=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getWinByMD() + " MD,";
				addedWins=true;
			}
			if ( getWinByDec() > 0 ) {
				breakdownString += getWinByDec() + " Dec,";
				addedWins=true;
			}
			if ( getWinByFFT() > 0 ) {
				breakdownString += getWinByFFT() + " FFT,";
				addedWins=true;
			}
			if ( addedWins ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "0 W";
		}
		boolean addedLosses=false;
		if ( getLosses() > 0 ) {
			breakdownString += "-" + getLosses() + "L[";
			if ( getLossByFall() > 0 ) {
				breakdownString += getLossByFall() + " Pin,";
				addedLosses=true;
			}
			if ( getLossByTech() > 0 ) {
				breakdownString += getLossByTech() + " TF,";
				addedLosses=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getLossByMD() + " MD,";
				addedLosses=true;
			}
			if ( getLossByDec() > 0 ) {
				breakdownString += getLossByDec() + " Dec,";
				addedLosses=true;
			}
			
			if ( addedLosses ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "-0L";
		}
		if ( getWins() ==0 && getLosses() == 0 ) {
			return "";
		} else {
			return breakdownString +" - "+ getWeight();
		}
	}
	public String getName() { return name; }
	public String getSeed() { return seed; }
	public String getCert() { return cert; }
	public String getTeamName() { return teamName; }
	public WrestlingLanguage.Grade getGrade() { return grade; }
	public WrestlingLanguage.Gender getGender() { return gender; }
	public String getTrackRecord() { return trackRecord; }
	public String getTrackWtClass() { return trackWtClass; }
	
	public int getWins() { return wins; }
	public int getLosses() { return losses; }
	
	public int getWinByFFT() { return winByFFT; }
	public int getWinByFall() { return winByFall; }
	public int getWinByTech() { return winByTech; }
	public int getWinByMD() { return winByMD; }
	public int getWinByDec() { return winByDec; }
	
	public int getLossByFFT() { return lossByFFT; }
	public int getLossByFall() { return lossByFall; }
	public int getLossByTech() { return lossByTech; }
	public int getLossByMD() { return lossByMD; }
	public int getLossByDec() { return lossByDec; }
	
    public Wrestler(String n, String team){
		setName(n);
		setTeamName(team);
		return;
	}
	public boolean getRosteredLastYear() { return rosteredLastYear; }
	
	public void setRosteredLastYearOn() { rosteredLastYear = true; }
	public void setRosteredLastYearOff() { rosteredLastYear = false; }
	
	public String getTrackLastYearWtClass() { return trackLastYearWtClass; }
	public String getTrackLastYearRecord() { return trackLastYearRecord; }
	
	public void setTrackLastYearWtClass(String w) { 
		trackLastYearWtClass = w; 
	}
	public void setTrackLastYearRecord(String r) {
		trackLastYearRecord = r;
	}
	
	
	public void addBout(Bout b) {
		String cmd=b.getMatchDate();
		if (cmd == null ) {
			Event e = b.getEvent();
			if ( e != null ) {
				String sss = e.getEventTitle();
				if ( wiHistory != null ) {
					String s = wiHistory.findWeighInDate(sss);
					if ( s != null ) { 
						b.setMatchDate(s);
					}
				}
			}
		}	
		
		bouts.add(b);
		addToSummary(b);
		addToMatchesAtWeight(b);
	}
	private void addToMatchesAtWeight(Bout b) {
		String w=b.getWeight();
		Integer ct = matchesAtWeight.get(w);
		if ( ct != null ) {
			ct++;
			matchesAtWeight.replace(w,ct);
		} else {
			matchesAtWeight.put(w,1);
		}
		return;
	}
	public String getMatchesAtWeightString() {

		String byWt="";
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
	
			int ct = matchesAtWeight.get(key);
			if ( byWt.length() > 0 ) { byWt=byWt + ";" ; }
			byWt=byWt + ct + "@" + key;
		}
		return byWt;
	}
	
	public void setName( String n ) {
		name = n.strip();
	}
	public void setSeed( String n ) {
		seed = n.strip();
	}
	public void setCert( String n ) {
		cert = n.strip();
	}
	public void setTeamName( String team ) {
		teamName = team;
	}
	public void setGrade5() { grade = WrestlingLanguage.Grade.G5;	}
	public void setGrade6() { grade = WrestlingLanguage.Grade.G6;	}
	public void setGrade7() { grade = WrestlingLanguage.Grade.G7;	}
	public void setGrade8() { grade = WrestlingLanguage.Grade.G8;	}
	public void setGrade(WrestlingLanguage.Grade g ) { grade=g; }
	
	public void setGenderM() { gender = WrestlingLanguage.Gender.M;	}
	public void setGenderF() { gender = WrestlingLanguage.Gender.F;	}
	public void setGender(WrestlingLanguage.Gender g ) { gender = g; }
	
	public void setTrackRecord(String rec) {
		trackRecord = rec;
	}
	public void setTrackWtClass(String w ) {
		trackWtClass = w;
	}
	public String toString() {
		return "Wrestler:" + teamName + ":" + name  ;
	}
	private void addToSummary(Bout b) {
	   if ( b.isAWin() ) {
          addWin();	
          switch ( b.getMatchResultType() ) {
			  case FFT: 
			    addWinByFFT();
				break;
			  case FALL:
			    addWinByFall();
				break;
			  case TECH:
			    addWinByTech();
				break;
			  case MD:
			    addWinByMD();
			    break;
			  case DEC:
			    addWinByDec();
				break;
			  case INJ:
			    break;
			  case DQ:
			    break;
		  }
       } else {
          addLoss();
          switch ( b.getMatchResultType() ) {

          case FFT:
			  addLossByFFT();
			    break;
			  case FALL:
			    addLossByFall();
				break;
			  case TECH:
			    addLossByTech();
				break;
			  case MD:
			    addLossByMD();
			    break;
			  case DEC:
			    addLossByDec();
				break;
			  case INJ:
			    if ( lossByInjury) {
			    	lossByInjuryString += ";";
			    } else {
			    	lossByInjury=true;
			    	lossByInjuryString= "Loss by Injury on ";
			    }
			    if ( b.getMatchDate() != null ) {
			    	lossByInjuryString += b.getMatchDate();
			    	lossByInjuryString += " ";
			    }
			    lossByInjuryString += " vs ";
			    lossByInjuryString += b.getOpponentTeam();
			    
			    break;
			  case DQ:
			    break;
		  }		  
       }		  
	}
	public void addWin() { wins++; }
	public void addLoss() { losses++; }
	public void addWinByFFT() { winByFFT++; }
	public void addWinByFall() { winByFall++; }
	public void addWinByTech() { winByTech++; }
	public void addWinByMD() { winByMD++; }
	public void addWinByDec() { winByDec++; }
	
	public void addLossByFFT() { lossByFFT++; }
	public void addLossByFall() { lossByFall++; }
	public void addLossByTech() { lossByTech++; }
	public void addLossByMD() { lossByMD++; }
	public void addLossByDec() { lossByDec++; }

	public boolean equals(Object o) {
	  if ( o == null ) { return false; }
	  if ( this == o ) { return true; }
	  if ( this.getClass() == o.getClass() ){
         Wrestler ow = (Wrestler) o;		  
	     if ( this.getName().equals(ow.getName()) && this.getTeamName().equals(ow.getTeamName())) {
			 return true;
	     }
	  }
	  return false; 
	}
	public int hashCode() {
		return getName().hashCode() + getTeamName().hashCode();
	}


public String getFinWeight() {
	String finWeight = "";
	boolean a = playedMatch();
	
	if(cert != null) {
		finWeight = cert;
	}
	else (this.cert == null&&this.playedMatch()== true){
		finWeight = this.getLowestWeightWrestled();
	}
	
	return finWeight;
}

public boolean playedMatch() {
	if (matchWeight == null) {
		return false;
}	
	return true;
}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2022-10-13 22:33:14.137
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2022-10-13 22:33:14.138
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-13 22:33:14.166
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package JuniorHigh;

import java.util.*;
import java.util.Enumeration;

/*
 *
 *  This is a class to holds an wrestler and all data pertaining to him/her.
 */
class Wrestler {
	private String name;
	private String seed;
	private String cert;
	private String teamName;
	private WrestlingLanguage.Grade grade;
	private WrestlingLanguage.Gender gender;
	private String trackRecord;
	private String trackWtClass;
	private boolean rosteredLastYear;
	private String trackLastYearWtClass;
	private String trackLastYearRecord;
	private WrestlingLanguage.Prestige prestigeLastYear;
	private WrestlingLanguage.Prestige prestige2YearsAgo;
	private WrestlingLanguage.Prestige prestige3YearsAgo;
	
	private Hashtable<String,Integer> matchesAtWeight=new Hashtable<String,Integer>();
	
	private int wins;
	private int losses;
	private boolean lossByInjury=false;
	private String lossByInjuryString;
	private int winByFFT;
	private int lossByFFT;

	private int winByFall;
	private int winByDec;
	private int winByMD;
	private int winByTech;
	
	private int lossByFall;
	private int lossByDec;
	private int lossByMD;
	private int lossByTech;
	
	private int weight;
	
	private Hashtable<Integer,Integer> matchWeight=new Hashtable<Integer,Integer>();

		
	private WeighInHistory wiHistory;
	
	/* These 2 attributes are used to force where we put the wrestler in the reporting
	 * order.
	 */
	private String forceWeight=null;  /* for reporting force the use of this weight class. */
	private Integer forceRank=null;  /* for reporting this is the rank order withing the weight class. */

	public void setLossByInjuryString(String s) {
		lossByInjuryString = s;
	}
	public String getLossByInjuryString() { return lossByInjuryString; }
	
	public String getLowestWeightWrestled() {
		int lowInt=99999;
		
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
			int i =  Integer.parseInt(key);
		    if (i < lowInt ) {
		    	lowInt = i;
		    }
		}
		return Integer.toString(lowInt);
	}
	public String getPrintWeight() {
		if ( forceWeight != null ) {
			if ( forceWeight.length() > 0 ) {
				return forceWeight;
			}
		}
		return getLowestWeightWrestled();
	}
	public int getPrintRank() {
		if (forceRank == null ) {
			return getWins() + getLosses();
		} else {
			return 100000 - forceRank.intValue();
		}
	}
	public String getForceWeight() { return forceWeight; }
	public Integer getForceRank() { return forceRank; }
	
	public void setWeight( int w ) { 
		if (matchWeight.containsKey(w)) {
			int val =matchWeight.get(w);
			matchWeight.put(w, val+1);
			
		}
		else {
		matchWeight.put(w, 1);	
		}
		
	}
	public String getWeight() {
		Enumeration<Integer> e = matchWeight.keys();
		String WeightString="";
		while (e.hasMoreElements()) {
			 
	            // Getting the key of a particular entry
	            int keyWeight = e.nextElement();
	            int valueCount = matchWeight.get(keyWeight);
	            
	            WeightString += Integer.toString(valueCount) + "@" + Integer.toString(keyWeight) + " - ";
	             
	          
	        }
		return WeightString;
		
	}


	
	public void setForceWeight( String w ) { forceWeight = w; }
	public void setForceRank ( Integer i ) { forceRank = i; }
	
	List<Bout> bouts = new ArrayList<Bout> ();

	public List<Bout> getBouts() { return bouts; }
	
	public boolean getLossByInjury() { return lossByInjury; }
	
	public WeighInHistory getWeighInHistory() { return wiHistory; }
	
	public void setWeighInHistory(WeighInHistory wih ) { wiHistory = wih; }

	public void setPrestigeLastYear(WrestlingLanguage.Prestige p) { prestigeLastYear = p; }
	public void setPrestige2YearsAgo(WrestlingLanguage.Prestige p) { prestige2YearsAgo= p; }
	public void setPrestige3YearsAgo(WrestlingLanguage.Prestige p) { prestige3YearsAgo = p; }

	public WrestlingLanguage.Prestige getPrestigeLastYear() { return prestigeLastYear; }
	public WrestlingLanguage.Prestige getPrestige2YearsAgo() { return prestige2YearsAgo; }
	public WrestlingLanguage.Prestige getPrestige3YearsAgo() { return prestige3YearsAgo; }

    public void printVerbose () {
		System.out.println( getName() + 
			" Grade<" + getGrade() + ">" + 
			" Seed<" + getSeed() + ">" +
			" Cert<" + getCert() + ">"); 
			//" Gender<" + getGender() + "> Wt<" + 
			//getTrackWtClass() + ">" + " (" + getWins() + "W-" + 
			//getLosses() + "L) Last Year=<" + rosteredLastYear + "> Last Year Record <" + trackLastYearRecord + ">" );
    }	   
	public String getRecordString() { 
		return String.valueOf(wins) + "-" + String.valueOf(losses); 
	}
	public String getRecordBreakdown() {
		String breakdownString = "";
		boolean addedWins=false;
		if ( getWins() > 0 ) {
			breakdownString += getWins() + "W[";
			if ( getWinByFall() > 0 ) {
				breakdownString += getWinByFall() + " Pin,";
				addedWins=true;
			}
			if ( getWinByTech() > 0 ) {
				breakdownString += getWinByTech() + " TF,";
				addedWins=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getWinByMD() + " MD,";
				addedWins=true;
			}
			if ( getWinByDec() > 0 ) {
				breakdownString += getWinByDec() + " Dec,";
				addedWins=true;
			}
			if ( getWinByFFT() > 0 ) {
				breakdownString += getWinByFFT() + " FFT,";
				addedWins=true;
			}
			if ( addedWins ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "0 W";
		}
		boolean addedLosses=false;
		if ( getLosses() > 0 ) {
			breakdownString += "-" + getLosses() + "L[";
			if ( getLossByFall() > 0 ) {
				breakdownString += getLossByFall() + " Pin,";
				addedLosses=true;
			}
			if ( getLossByTech() > 0 ) {
				breakdownString += getLossByTech() + " TF,";
				addedLosses=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getLossByMD() + " MD,";
				addedLosses=true;
			}
			if ( getLossByDec() > 0 ) {
				breakdownString += getLossByDec() + " Dec,";
				addedLosses=true;
			}
			
			if ( addedLosses ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "-0L";
		}
		if ( getWins() ==0 && getLosses() == 0 ) {
			return "";
		} else {
			return breakdownString +" - "+ getWeight();
		}
	}
	public String getName() { return name; }
	public String getSeed() { return seed; }
	public String getCert() { return cert; }
	public String getTeamName() { return teamName; }
	public WrestlingLanguage.Grade getGrade() { return grade; }
	public WrestlingLanguage.Gender getGender() { return gender; }
	public String getTrackRecord() { return trackRecord; }
	public String getTrackWtClass() { return trackWtClass; }
	
	public int getWins() { return wins; }
	public int getLosses() { return losses; }
	
	public int getWinByFFT() { return winByFFT; }
	public int getWinByFall() { return winByFall; }
	public int getWinByTech() { return winByTech; }
	public int getWinByMD() { return winByMD; }
	public int getWinByDec() { return winByDec; }
	
	public int getLossByFFT() { return lossByFFT; }
	public int getLossByFall() { return lossByFall; }
	public int getLossByTech() { return lossByTech; }
	public int getLossByMD() { return lossByMD; }
	public int getLossByDec() { return lossByDec; }
	
    public Wrestler(String n, String team){
		setName(n);
		setTeamName(team);
		return;
	}
	public boolean getRosteredLastYear() { return rosteredLastYear; }
	
	public void setRosteredLastYearOn() { rosteredLastYear = true; }
	public void setRosteredLastYearOff() { rosteredLastYear = false; }
	
	public String getTrackLastYearWtClass() { return trackLastYearWtClass; }
	public String getTrackLastYearRecord() { return trackLastYearRecord; }
	
	public void setTrackLastYearWtClass(String w) { 
		trackLastYearWtClass = w; 
	}
	public void setTrackLastYearRecord(String r) {
		trackLastYearRecord = r;
	}
	
	
	public void addBout(Bout b) {
		String cmd=b.getMatchDate();
		if (cmd == null ) {
			Event e = b.getEvent();
			if ( e != null ) {
				String sss = e.getEventTitle();
				if ( wiHistory != null ) {
					String s = wiHistory.findWeighInDate(sss);
					if ( s != null ) { 
						b.setMatchDate(s);
					}
				}
			}
		}	
		
		bouts.add(b);
		addToSummary(b);
		addToMatchesAtWeight(b);
	}
	private void addToMatchesAtWeight(Bout b) {
		String w=b.getWeight();
		Integer ct = matchesAtWeight.get(w);
		if ( ct != null ) {
			ct++;
			matchesAtWeight.replace(w,ct);
		} else {
			matchesAtWeight.put(w,1);
		}
		return;
	}
	public String getMatchesAtWeightString() {

		String byWt="";
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
	
			int ct = matchesAtWeight.get(key);
			if ( byWt.length() > 0 ) { byWt=byWt + ";" ; }
			byWt=byWt + ct + "@" + key;
		}
		return byWt;
	}
	
	public void setName( String n ) {
		name = n.strip();
	}
	public void setSeed( String n ) {
		seed = n.strip();
	}
	public void setCert( String n ) {
		cert = n.strip();
	}
	public void setTeamName( String team ) {
		teamName = team;
	}
	public void setGrade5() { grade = WrestlingLanguage.Grade.G5;	}
	public void setGrade6() { grade = WrestlingLanguage.Grade.G6;	}
	public void setGrade7() { grade = WrestlingLanguage.Grade.G7;	}
	public void setGrade8() { grade = WrestlingLanguage.Grade.G8;	}
	public void setGrade(WrestlingLanguage.Grade g ) { grade=g; }
	
	public void setGenderM() { gender = WrestlingLanguage.Gender.M;	}
	public void setGenderF() { gender = WrestlingLanguage.Gender.F;	}
	public void setGender(WrestlingLanguage.Gender g ) { gender = g; }
	
	public void setTrackRecord(String rec) {
		trackRecord = rec;
	}
	public void setTrackWtClass(String w ) {
		trackWtClass = w;
	}
	public String toString() {
		return "Wrestler:" + teamName + ":" + name  ;
	}
	private void addToSummary(Bout b) {
	   if ( b.isAWin() ) {
          addWin();	
          switch ( b.getMatchResultType() ) {
			  case FFT: 
			    addWinByFFT();
				break;
			  case FALL:
			    addWinByFall();
				break;
			  case TECH:
			    addWinByTech();
				break;
			  case MD:
			    addWinByMD();
			    break;
			  case DEC:
			    addWinByDec();
				break;
			  case INJ:
			    break;
			  case DQ:
			    break;
		  }
       } else {
          addLoss();
          switch ( b.getMatchResultType() ) {

          case FFT:
			  addLossByFFT();
			    break;
			  case FALL:
			    addLossByFall();
				break;
			  case TECH:
			    addLossByTech();
				break;
			  case MD:
			    addLossByMD();
			    break;
			  case DEC:
			    addLossByDec();
				break;
			  case INJ:
			    if ( lossByInjury) {
			    	lossByInjuryString += ";";
			    } else {
			    	lossByInjury=true;
			    	lossByInjuryString= "Loss by Injury on ";
			    }
			    if ( b.getMatchDate() != null ) {
			    	lossByInjuryString += b.getMatchDate();
			    	lossByInjuryString += " ";
			    }
			    lossByInjuryString += " vs ";
			    lossByInjuryString += b.getOpponentTeam();
			    
			    break;
			  case DQ:
			    break;
		  }		  
       }		  
	}
	public void addWin() { wins++; }
	public void addLoss() { losses++; }
	public void addWinByFFT() { winByFFT++; }
	public void addWinByFall() { winByFall++; }
	public void addWinByTech() { winByTech++; }
	public void addWinByMD() { winByMD++; }
	public void addWinByDec() { winByDec++; }
	
	public void addLossByFFT() { lossByFFT++; }
	public void addLossByFall() { lossByFall++; }
	public void addLossByTech() { lossByTech++; }
	public void addLossByMD() { lossByMD++; }
	public void addLossByDec() { lossByDec++; }

	public boolean equals(Object o) {
	  if ( o == null ) { return false; }
	  if ( this == o ) { return true; }
	  if ( this.getClass() == o.getClass() ){
         Wrestler ow = (Wrestler) o;		  
	     if ( this.getName().equals(ow.getName()) && this.getTeamName().equals(ow.getTeamName())) {
			 return true;
	     }
	  }
	  return false; 
	}
	public int hashCode() {
		return getName().hashCode() + getTeamName().hashCode();
	}


public String getFinWeight() {
	String finWeight = "";
	boolean a = playedMatch();
	
	if(cert != null) {
		finWeight = cert;
	}
	else (this.cert == null&&this.playedMatch()== true){
		finWeight = this.getLowestWeightWrestled();
	}
	
	return finWeight;
}

public boolean playedMatch() {
	if (matchWeight == null) {
		return false;
}	
	return true;
}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:254)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-13 22:33:14.166
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:254)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-13 22:33:14.167
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:254)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-13 22:33:14.294
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package JuniorHigh;

import java.util.*;
import java.util.Enumeration;

/*
 *
 *  This is a class to holds an wrestler and all data pertaining to him/her.
 */
class Wrestler {
	private String name;
	private String seed;
	private String cert;
	private String teamName;
	private WrestlingLanguage.Grade grade;
	private WrestlingLanguage.Gender gender;
	private String trackRecord;
	private String trackWtClass;
	private boolean rosteredLastYear;
	private String trackLastYearWtClass;
	private String trackLastYearRecord;
	private WrestlingLanguage.Prestige prestigeLastYear;
	private WrestlingLanguage.Prestige prestige2YearsAgo;
	private WrestlingLanguage.Prestige prestige3YearsAgo;
	
	private Hashtable<String,Integer> matchesAtWeight=new Hashtable<String,Integer>();
	
	private int wins;
	private int losses;
	private boolean lossByInjury=false;
	private String lossByInjuryString;
	private int winByFFT;
	private int lossByFFT;

	private int winByFall;
	private int winByDec;
	private int winByMD;
	private int winByTech;
	
	private int lossByFall;
	private int lossByDec;
	private int lossByMD;
	private int lossByTech;
	
	private int weight;
	
	private Hashtable<Integer,Integer> matchWeight=new Hashtable<Integer,Integer>();

		
	private WeighInHistory wiHistory;
	
	/* These 2 attributes are used to force where we put the wrestler in the reporting
	 * order.
	 */
	private String forceWeight=null;  /* for reporting force the use of this weight class. */
	private Integer forceRank=null;  /* for reporting this is the rank order withing the weight class. */

	public void setLossByInjuryString(String s) {
		lossByInjuryString = s;
	}
	public String getLossByInjuryString() { return lossByInjuryString; }
	
	public String getLowestWeightWrestled() {
		int lowInt=99999;
		
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
			int i =  Integer.parseInt(key);
		    if (i < lowInt ) {
		    	lowInt = i;
		    }
		}
		return Integer.toString(lowInt);
	}
	public String getPrintWeight() {
		if ( forceWeight != null ) {
			if ( forceWeight.length() > 0 ) {
				return forceWeight;
			}
		}
		return getLowestWeightWrestled();
	}
	public int getPrintRank() {
		if (forceRank == null ) {
			return getWins() + getLosses();
		} else {
			return 100000 - forceRank.intValue();
		}
	}
	public String getForceWeight() { return forceWeight; }
	public Integer getForceRank() { return forceRank; }
	
	public void setWeight( int w ) { 
		if (matchWeight.containsKey(w)) {
			int val =matchWeight.get(w);
			matchWeight.put(w, val+1);
			
		}
		else {
		matchWeight.put(w, 1);	
		}
		
	}
	public String getWeight() {
		Enumeration<Integer> e = matchWeight.keys();
		String WeightString="";
		while (e.hasMoreElements()) {
			 
	            // Getting the key of a particular entry
	            int keyWeight = e.nextElement();
	            int valueCount = matchWeight.get(keyWeight);
	            
	            WeightString += Integer.toString(valueCount) + "@" + Integer.toString(keyWeight) + " - ";
	             
	          
	        }
		return WeightString;
		
	}


	
	public void setForceWeight( String w ) { forceWeight = w; }
	public void setForceRank ( Integer i ) { forceRank = i; }
	
	List<Bout> bouts = new ArrayList<Bout> ();

	public List<Bout> getBouts() { return bouts; }
	
	public boolean getLossByInjury() { return lossByInjury; }
	
	public WeighInHistory getWeighInHistory() { return wiHistory; }
	
	public void setWeighInHistory(WeighInHistory wih ) { wiHistory = wih; }

	public void setPrestigeLastYear(WrestlingLanguage.Prestige p) { prestigeLastYear = p; }
	public void setPrestige2YearsAgo(WrestlingLanguage.Prestige p) { prestige2YearsAgo= p; }
	public void setPrestige3YearsAgo(WrestlingLanguage.Prestige p) { prestige3YearsAgo = p; }

	public WrestlingLanguage.Prestige getPrestigeLastYear() { return prestigeLastYear; }
	public WrestlingLanguage.Prestige getPrestige2YearsAgo() { return prestige2YearsAgo; }
	public WrestlingLanguage.Prestige getPrestige3YearsAgo() { return prestige3YearsAgo; }

    public void printVerbose () {
		System.out.println( getName() + 
			" Grade<" + getGrade() + ">" + 
			" Seed<" + getSeed() + ">" +
			" Cert<" + getCert() + ">"); 
			//" Gender<" + getGender() + "> Wt<" + 
			//getTrackWtClass() + ">" + " (" + getWins() + "W-" + 
			//getLosses() + "L) Last Year=<" + rosteredLastYear + "> Last Year Record <" + trackLastYearRecord + ">" );
    }	   
	public String getRecordString() { 
		return String.valueOf(wins) + "-" + String.valueOf(losses); 
	}
	public String getRecordBreakdown() {
		String breakdownString = "";
		boolean addedWins=false;
		if ( getWins() > 0 ) {
			breakdownString += getWins() + "W[";
			if ( getWinByFall() > 0 ) {
				breakdownString += getWinByFall() + " Pin,";
				addedWins=true;
			}
			if ( getWinByTech() > 0 ) {
				breakdownString += getWinByTech() + " TF,";
				addedWins=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getWinByMD() + " MD,";
				addedWins=true;
			}
			if ( getWinByDec() > 0 ) {
				breakdownString += getWinByDec() + " Dec,";
				addedWins=true;
			}
			if ( getWinByFFT() > 0 ) {
				breakdownString += getWinByFFT() + " FFT,";
				addedWins=true;
			}
			if ( addedWins ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "0 W";
		}
		boolean addedLosses=false;
		if ( getLosses() > 0 ) {
			breakdownString += "-" + getLosses() + "L[";
			if ( getLossByFall() > 0 ) {
				breakdownString += getLossByFall() + " Pin,";
				addedLosses=true;
			}
			if ( getLossByTech() > 0 ) {
				breakdownString += getLossByTech() + " TF,";
				addedLosses=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getLossByMD() + " MD,";
				addedLosses=true;
			}
			if ( getLossByDec() > 0 ) {
				breakdownString += getLossByDec() + " Dec,";
				addedLosses=true;
			}
			
			if ( addedLosses ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "-0L";
		}
		if ( getWins() ==0 && getLosses() == 0 ) {
			return "";
		} else {
			return breakdownString +" - "+ getWeight();
		}
	}
	public String getName() { return name; }
	public String getSeed() { return seed; }
	public String getCert() { return cert; }
	public String getTeamName() { return teamName; }
	public WrestlingLanguage.Grade getGrade() { return grade; }
	public WrestlingLanguage.Gender getGender() { return gender; }
	public String getTrackRecord() { return trackRecord; }
	public String getTrackWtClass() { return trackWtClass; }
	
	public int getWins() { return wins; }
	public int getLosses() { return losses; }
	
	public int getWinByFFT() { return winByFFT; }
	public int getWinByFall() { return winByFall; }
	public int getWinByTech() { return winByTech; }
	public int getWinByMD() { return winByMD; }
	public int getWinByDec() { return winByDec; }
	
	public int getLossByFFT() { return lossByFFT; }
	public int getLossByFall() { return lossByFall; }
	public int getLossByTech() { return lossByTech; }
	public int getLossByMD() { return lossByMD; }
	public int getLossByDec() { return lossByDec; }
	
    public Wrestler(String n, String team){
		setName(n);
		setTeamName(team);
		return;
	}
	public boolean getRosteredLastYear() { return rosteredLastYear; }
	
	public void setRosteredLastYearOn() { rosteredLastYear = true; }
	public void setRosteredLastYearOff() { rosteredLastYear = false; }
	
	public String getTrackLastYearWtClass() { return trackLastYearWtClass; }
	public String getTrackLastYearRecord() { return trackLastYearRecord; }
	
	public void setTrackLastYearWtClass(String w) { 
		trackLastYearWtClass = w; 
	}
	public void setTrackLastYearRecord(String r) {
		trackLastYearRecord = r;
	}
	
	
	public void addBout(Bout b) {
		String cmd=b.getMatchDate();
		if (cmd == null ) {
			Event e = b.getEvent();
			if ( e != null ) {
				String sss = e.getEventTitle();
				if ( wiHistory != null ) {
					String s = wiHistory.findWeighInDate(sss);
					if ( s != null ) { 
						b.setMatchDate(s);
					}
				}
			}
		}	
		
		bouts.add(b);
		addToSummary(b);
		addToMatchesAtWeight(b);
	}
	private void addToMatchesAtWeight(Bout b) {
		String w=b.getWeight();
		Integer ct = matchesAtWeight.get(w);
		if ( ct != null ) {
			ct++;
			matchesAtWeight.replace(w,ct);
		} else {
			matchesAtWeight.put(w,1);
		}
		return;
	}
	public String getMatchesAtWeightString() {

		String byWt="";
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
	
			int ct = matchesAtWeight.get(key);
			if ( byWt.length() > 0 ) { byWt=byWt + ";" ; }
			byWt=byWt + ct + "@" + key;
		}
		return byWt;
	}
	
	public void setName( String n ) {
		name = n.strip();
	}
	public void setSeed( String n ) {
		seed = n.strip();
	}
	public void setCert( String n ) {
		cert = n.strip();
	}
	public void setTeamName( String team ) {
		teamName = team;
	}
	public void setGrade5() { grade = WrestlingLanguage.Grade.G5;	}
	public void setGrade6() { grade = WrestlingLanguage.Grade.G6;	}
	public void setGrade7() { grade = WrestlingLanguage.Grade.G7;	}
	public void setGrade8() { grade = WrestlingLanguage.Grade.G8;	}
	public void setGrade(WrestlingLanguage.Grade g ) { grade=g; }
	
	public void setGenderM() { gender = WrestlingLanguage.Gender.M;	}
	public void setGenderF() { gender = WrestlingLanguage.Gender.F;	}
	public void setGender(WrestlingLanguage.Gender g ) { gender = g; }
	
	public void setTrackRecord(String rec) {
		trackRecord = rec;
	}
	public void setTrackWtClass(String w ) {
		trackWtClass = w;
	}
	public String toString() {
		return "Wrestler:" + teamName + ":" + name  ;
	}
	private void addToSummary(Bout b) {
	   if ( b.isAWin() ) {
          addWin();	
          switch ( b.getMatchResultType() ) {
			  case FFT: 
			    addWinByFFT();
				break;
			  case FALL:
			    addWinByFall();
				break;
			  case TECH:
			    addWinByTech();
				break;
			  case MD:
			    addWinByMD();
			    break;
			  case DEC:
			    addWinByDec();
				break;
			  case INJ:
			    break;
			  case DQ:
			    break;
		  }
       } else {
          addLoss();
          switch ( b.getMatchResultType() ) {

          case FFT:
			  addLossByFFT();
			    break;
			  case FALL:
			    addLossByFall();
				break;
			  case TECH:
			    addLossByTech();
				break;
			  case MD:
			    addLossByMD();
			    break;
			  case DEC:
			    addLossByDec();
				break;
			  case INJ:
			    if ( lossByInjury) {
			    	lossByInjuryString += ";";
			    } else {
			    	lossByInjury=true;
			    	lossByInjuryString= "Loss by Injury on ";
			    }
			    if ( b.getMatchDate() != null ) {
			    	lossByInjuryString += b.getMatchDate();
			    	lossByInjuryString += " ";
			    }
			    lossByInjuryString += " vs ";
			    lossByInjuryString += b.getOpponentTeam();
			    
			    break;
			  case DQ:
			    break;
		  }		  
       }		  
	}
	public void addWin() { wins++; }
	public void addLoss() { losses++; }
	public void addWinByFFT() { winByFFT++; }
	public void addWinByFall() { winByFall++; }
	public void addWinByTech() { winByTech++; }
	public void addWinByMD() { winByMD++; }
	public void addWinByDec() { winByDec++; }
	
	public void addLossByFFT() { lossByFFT++; }
	public void addLossByFall() { lossByFall++; }
	public void addLossByTech() { lossByTech++; }
	public void addLossByMD() { lossByMD++; }
	public void addLossByDec() { lossByDec++; }

	public boolean equals(Object o) {
	  if ( o == null ) { return false; }
	  if ( this == o ) { return true; }
	  if ( this.getClass() == o.getClass() ){
         Wrestler ow = (Wrestler) o;		  
	     if ( this.getName().equals(ow.getName()) && this.getTeamName().equals(ow.getTeamName())) {
			 return true;
	     }
	  }
	  return false; 
	}
	public int hashCode() {
		return getName().hashCode() + getTeamName().hashCode();
	}


public String getFinWeight() {
	String finWeight = "";
	boolean a = playedMatch();
	
	if(cert != null) {
		finWeight = cert;
	}
	else (this.cert == null&&this.playedMatch()== true){
		finWeight = this.getLowestWeightWrestled();
	}
	
	return finWeight;
}

public boolean playedMatch() {
	if (matchWeight == null) {
		return false;
}	
	return true;
}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:254)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-13 22:33:14.294
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:254)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-13 22:33:14.294
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:254)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-13 22:33:17.892
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package JuniorHigh;

import java.util.*;
import java.util.Enumeration;

/*
 *
 *  This is a class to holds an wrestler and all data pertaining to him/her.
 */
class Wrestler {
	private String name;
	private String seed;
	private String cert;
	private String teamName;
	private WrestlingLanguage.Grade grade;
	private WrestlingLanguage.Gender gender;
	private String trackRecord;
	private String trackWtClass;
	private boolean rosteredLastYear;
	private String trackLastYearWtClass;
	private String trackLastYearRecord;
	private WrestlingLanguage.Prestige prestigeLastYear;
	private WrestlingLanguage.Prestige prestige2YearsAgo;
	private WrestlingLanguage.Prestige prestige3YearsAgo;
	
	private Hashtable<String,Integer> matchesAtWeight=new Hashtable<String,Integer>();
	
	private int wins;
	private int losses;
	private boolean lossByInjury=false;
	private String lossByInjuryString;
	private int winByFFT;
	private int lossByFFT;

	private int winByFall;
	private int winByDec;
	private int winByMD;
	private int winByTech;
	
	private int lossByFall;
	private int lossByDec;
	private int lossByMD;
	private int lossByTech;
	
	private int weight;
	
	private Hashtable<Integer,Integer> matchWeight=new Hashtable<Integer,Integer>();

		
	private WeighInHistory wiHistory;
	
	/* These 2 attributes are used to force where we put the wrestler in the reporting
	 * order.
	 */
	private String forceWeight=null;  /* for reporting force the use of this weight class. */
	private Integer forceRank=null;  /* for reporting this is the rank order withing the weight class. */

	public void setLossByInjuryString(String s) {
		lossByInjuryString = s;
	}
	public String getLossByInjuryString() { return lossByInjuryString; }
	
	public String getLowestWeightWrestled() {
		int lowInt=99999;
		
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
			int i =  Integer.parseInt(key);
		    if (i < lowInt ) {
		    	lowInt = i;
		    }
		}
		return Integer.toString(lowInt);
	}
	public String getPrintWeight() {
		if ( forceWeight != null ) {
			if ( forceWeight.length() > 0 ) {
				return forceWeight;
			}
		}
		return getLowestWeightWrestled();
	}
	public int getPrintRank() {
		if (forceRank == null ) {
			return getWins() + getLosses();
		} else {
			return 100000 - forceRank.intValue();
		}
	}
	public String getForceWeight() { return forceWeight; }
	public Integer getForceRank() { return forceRank; }
	
	public void setWeight( int w ) { 
		if (matchWeight.containsKey(w)) {
			int val =matchWeight.get(w);
			matchWeight.put(w, val+1);
			
		}
		else {
		matchWeight.put(w, 1);	
		}
		
	}
	public String getWeight() {
		Enumeration<Integer> e = matchWeight.keys();
		String WeightString="";
		while (e.hasMoreElements()) {
			 
	            // Getting the key of a particular entry
	            int keyWeight = e.nextElement();
	            int valueCount = matchWeight.get(keyWeight);
	            
	            WeightString += Integer.toString(valueCount) + "@" + Integer.toString(keyWeight) + " - ";
	             
	          
	        }
		return WeightString;
		
	}


	
	public void setForceWeight( String w ) { forceWeight = w; }
	public void setForceRank ( Integer i ) { forceRank = i; }
	
	List<Bout> bouts = new ArrayList<Bout> ();

	public List<Bout> getBouts() { return bouts; }
	
	public boolean getLossByInjury() { return lossByInjury; }
	
	public WeighInHistory getWeighInHistory() { return wiHistory; }
	
	public void setWeighInHistory(WeighInHistory wih ) { wiHistory = wih; }

	public void setPrestigeLastYear(WrestlingLanguage.Prestige p) { prestigeLastYear = p; }
	public void setPrestige2YearsAgo(WrestlingLanguage.Prestige p) { prestige2YearsAgo= p; }
	public void setPrestige3YearsAgo(WrestlingLanguage.Prestige p) { prestige3YearsAgo = p; }

	public WrestlingLanguage.Prestige getPrestigeLastYear() { return prestigeLastYear; }
	public WrestlingLanguage.Prestige getPrestige2YearsAgo() { return prestige2YearsAgo; }
	public WrestlingLanguage.Prestige getPrestige3YearsAgo() { return prestige3YearsAgo; }

    public void printVerbose () {
		System.out.println( getName() + 
			" Grade<" + getGrade() + ">" + 
			" Seed<" + getSeed() + ">" +
			" Cert<" + getCert() + ">"); 
			//" Gender<" + getGender() + "> Wt<" + 
			//getTrackWtClass() + ">" + " (" + getWins() + "W-" + 
			//getLosses() + "L) Last Year=<" + rosteredLastYear + "> Last Year Record <" + trackLastYearRecord + ">" );
    }	   
	public String getRecordString() { 
		return String.valueOf(wins) + "-" + String.valueOf(losses); 
	}
	public String getRecordBreakdown() {
		String breakdownString = "";
		boolean addedWins=false;
		if ( getWins() > 0 ) {
			breakdownString += getWins() + "W[";
			if ( getWinByFall() > 0 ) {
				breakdownString += getWinByFall() + " Pin,";
				addedWins=true;
			}
			if ( getWinByTech() > 0 ) {
				breakdownString += getWinByTech() + " TF,";
				addedWins=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getWinByMD() + " MD,";
				addedWins=true;
			}
			if ( getWinByDec() > 0 ) {
				breakdownString += getWinByDec() + " Dec,";
				addedWins=true;
			}
			if ( getWinByFFT() > 0 ) {
				breakdownString += getWinByFFT() + " FFT,";
				addedWins=true;
			}
			if ( addedWins ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "0 W";
		}
		boolean addedLosses=false;
		if ( getLosses() > 0 ) {
			breakdownString += "-" + getLosses() + "L[";
			if ( getLossByFall() > 0 ) {
				breakdownString += getLossByFall() + " Pin,";
				addedLosses=true;
			}
			if ( getLossByTech() > 0 ) {
				breakdownString += getLossByTech() + " TF,";
				addedLosses=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getLossByMD() + " MD,";
				addedLosses=true;
			}
			if ( getLossByDec() > 0 ) {
				breakdownString += getLossByDec() + " Dec,";
				addedLosses=true;
			}
			
			if ( addedLosses ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "-0L";
		}
		if ( getWins() ==0 && getLosses() == 0 ) {
			return "";
		} else {
			return breakdownString +" - "+ getWeight();
		}
	}
	public String getName() { return name; }
	public String getSeed() { return seed; }
	public String getCert() { return cert; }
	public String getTeamName() { return teamName; }
	public WrestlingLanguage.Grade getGrade() { return grade; }
	public WrestlingLanguage.Gender getGender() { return gender; }
	public String getTrackRecord() { return trackRecord; }
	public String getTrackWtClass() { return trackWtClass; }
	
	public int getWins() { return wins; }
	public int getLosses() { return losses; }
	
	public int getWinByFFT() { return winByFFT; }
	public int getWinByFall() { return winByFall; }
	public int getWinByTech() { return winByTech; }
	public int getWinByMD() { return winByMD; }
	public int getWinByDec() { return winByDec; }
	
	public int getLossByFFT() { return lossByFFT; }
	public int getLossByFall() { return lossByFall; }
	public int getLossByTech() { return lossByTech; }
	public int getLossByMD() { return lossByMD; }
	public int getLossByDec() { return lossByDec; }
	
    public Wrestler(String n, String team){
		setName(n);
		setTeamName(team);
		return;
	}
	public boolean getRosteredLastYear() { return rosteredLastYear; }
	
	public void setRosteredLastYearOn() { rosteredLastYear = true; }
	public void setRosteredLastYearOff() { rosteredLastYear = false; }
	
	public String getTrackLastYearWtClass() { return trackLastYearWtClass; }
	public String getTrackLastYearRecord() { return trackLastYearRecord; }
	
	public void setTrackLastYearWtClass(String w) { 
		trackLastYearWtClass = w; 
	}
	public void setTrackLastYearRecord(String r) {
		trackLastYearRecord = r;
	}
	
	
	public void addBout(Bout b) {
		String cmd=b.getMatchDate();
		if (cmd == null ) {
			Event e = b.getEvent();
			if ( e != null ) {
				String sss = e.getEventTitle();
				if ( wiHistory != null ) {
					String s = wiHistory.findWeighInDate(sss);
					if ( s != null ) { 
						b.setMatchDate(s);
					}
				}
			}
		}	
		
		bouts.add(b);
		addToSummary(b);
		addToMatchesAtWeight(b);
	}
	private void addToMatchesAtWeight(Bout b) {
		String w=b.getWeight();
		Integer ct = matchesAtWeight.get(w);
		if ( ct != null ) {
			ct++;
			matchesAtWeight.replace(w,ct);
		} else {
			matchesAtWeight.put(w,1);
		}
		return;
	}
	public String getMatchesAtWeightString() {

		String byWt="";
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
	
			int ct = matchesAtWeight.get(key);
			if ( byWt.length() > 0 ) { byWt=byWt + ";" ; }
			byWt=byWt + ct + "@" + key;
		}
		return byWt;
	}
	
	public void setName( String n ) {
		name = n.strip();
	}
	public void setSeed( String n ) {
		seed = n.strip();
	}
	public void setCert( String n ) {
		cert = n.strip();
	}
	public void setTeamName( String team ) {
		teamName = team;
	}
	public void setGrade5() { grade = WrestlingLanguage.Grade.G5;	}
	public void setGrade6() { grade = WrestlingLanguage.Grade.G6;	}
	public void setGrade7() { grade = WrestlingLanguage.Grade.G7;	}
	public void setGrade8() { grade = WrestlingLanguage.Grade.G8;	}
	public void setGrade(WrestlingLanguage.Grade g ) { grade=g; }
	
	public void setGenderM() { gender = WrestlingLanguage.Gender.M;	}
	public void setGenderF() { gender = WrestlingLanguage.Gender.F;	}
	public void setGender(WrestlingLanguage.Gender g ) { gender = g; }
	
	public void setTrackRecord(String rec) {
		trackRecord = rec;
	}
	public void setTrackWtClass(String w ) {
		trackWtClass = w;
	}
	public String toString() {
		return "Wrestler:" + teamName + ":" + name  ;
	}
	private void addToSummary(Bout b) {
	   if ( b.isAWin() ) {
          addWin();	
          switch ( b.getMatchResultType() ) {
			  case FFT: 
			    addWinByFFT();
				break;
			  case FALL:
			    addWinByFall();
				break;
			  case TECH:
			    addWinByTech();
				break;
			  case MD:
			    addWinByMD();
			    break;
			  case DEC:
			    addWinByDec();
				break;
			  case INJ:
			    break;
			  case DQ:
			    break;
		  }
       } else {
          addLoss();
          switch ( b.getMatchResultType() ) {

          case FFT:
			  addLossByFFT();
			    break;
			  case FALL:
			    addLossByFall();
				break;
			  case TECH:
			    addLossByTech();
				break;
			  case MD:
			    addLossByMD();
			    break;
			  case DEC:
			    addLossByDec();
				break;
			  case INJ:
			    if ( lossByInjury) {
			    	lossByInjuryString += ";";
			    } else {
			    	lossByInjury=true;
			    	lossByInjuryString= "Loss by Injury on ";
			    }
			    if ( b.getMatchDate() != null ) {
			    	lossByInjuryString += b.getMatchDate();
			    	lossByInjuryString += " ";
			    }
			    lossByInjuryString += " vs ";
			    lossByInjuryString += b.getOpponentTeam();
			    
			    break;
			  case DQ:
			    break;
		  }		  
       }		  
	}
	public void addWin() { wins++; }
	public void addLoss() { losses++; }
	public void addWinByFFT() { winByFFT++; }
	public void addWinByFall() { winByFall++; }
	public void addWinByTech() { winByTech++; }
	public void addWinByMD() { winByMD++; }
	public void addWinByDec() { winByDec++; }
	
	public void addLossByFFT() { lossByFFT++; }
	public void addLossByFall() { lossByFall++; }
	public void addLossByTech() { lossByTech++; }
	public void addLossByMD() { lossByMD++; }
	public void addLossByDec() { lossByDec++; }

	public boolean equals(Object o) {
	  if ( o == null ) { return false; }
	  if ( this == o ) { return true; }
	  if ( this.getClass() == o.getClass() ){
         Wrestler ow = (Wrestler) o;		  
	     if ( this.getName().equals(ow.getName()) && this.getTeamName().equals(ow.getTeamName())) {
			 return true;
	     }
	  }
	  return false; 
	}
	public int hashCode() {
		return getName().hashCode() + getTeamName().hashCode();
	}


public String getFinWeight() {
	String finWeight = "";
	boolean a = playedMatch();
	
	if(cert != null) {
		finWeight = cert;
	}
	else (this.cert == null&&this.playedMatch()== true){
		finWeight = this.getLowestWeightWrestled();
	}
	
	return finWeight;
}

public boolean playedMatch() {
	if (matchWeight == null) {
		return false;
}	
	return true;
}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4320)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3943)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:577)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-13 22:33:17.898
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4320)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3943)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:577)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-13 22:33:17.898
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4320)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3943)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:577)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-13 22:33:17.906
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package JuniorHigh;

import java.util.*;
import java.util.Enumeration;

/*
 *
 *  This is a class to holds an wrestler and all data pertaining to him/her.
 */
class Wrestler {
	private String name;
	private String seed;
	private String cert;
	private String teamName;
	private WrestlingLanguage.Grade grade;
	private WrestlingLanguage.Gender gender;
	private String trackRecord;
	private String trackWtClass;
	private boolean rosteredLastYear;
	private String trackLastYearWtClass;
	private String trackLastYearRecord;
	private WrestlingLanguage.Prestige prestigeLastYear;
	private WrestlingLanguage.Prestige prestige2YearsAgo;
	private WrestlingLanguage.Prestige prestige3YearsAgo;
	
	private Hashtable<String,Integer> matchesAtWeight=new Hashtable<String,Integer>();
	
	private int wins;
	private int losses;
	private boolean lossByInjury=false;
	private String lossByInjuryString;
	private int winByFFT;
	private int lossByFFT;

	private int winByFall;
	private int winByDec;
	private int winByMD;
	private int winByTech;
	
	private int lossByFall;
	private int lossByDec;
	private int lossByMD;
	private int lossByTech;
	
	private int weight;
	
	private Hashtable<Integer,Integer> matchWeight=new Hashtable<Integer,Integer>();

		
	private WeighInHistory wiHistory;
	
	/* These 2 attributes are used to force where we put the wrestler in the reporting
	 * order.
	 */
	private String forceWeight=null;  /* for reporting force the use of this weight class. */
	private Integer forceRank=null;  /* for reporting this is the rank order withing the weight class. */

	public void setLossByInjuryString(String s) {
		lossByInjuryString = s;
	}
	public String getLossByInjuryString() { return lossByInjuryString; }
	
	public String getLowestWeightWrestled() {
		int lowInt=99999;
		
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
			int i =  Integer.parseInt(key);
		    if (i < lowInt ) {
		    	lowInt = i;
		    }
		}
		return Integer.toString(lowInt);
	}
	public String getPrintWeight() {
		if ( forceWeight != null ) {
			if ( forceWeight.length() > 0 ) {
				return forceWeight;
			}
		}
		return getLowestWeightWrestled();
	}
	public int getPrintRank() {
		if (forceRank == null ) {
			return getWins() + getLosses();
		} else {
			return 100000 - forceRank.intValue();
		}
	}
	public String getForceWeight() { return forceWeight; }
	public Integer getForceRank() { return forceRank; }
	
	public void setWeight( int w ) { 
		if (matchWeight.containsKey(w)) {
			int val =matchWeight.get(w);
			matchWeight.put(w, val+1);
			
		}
		else {
		matchWeight.put(w, 1);	
		}
		
	}
	public String getWeight() {
		Enumeration<Integer> e = matchWeight.keys();
		String WeightString="";
		while (e.hasMoreElements()) {
			 
	            // Getting the key of a particular entry
	            int keyWeight = e.nextElement();
	            int valueCount = matchWeight.get(keyWeight);
	            
	            WeightString += Integer.toString(valueCount) + "@" + Integer.toString(keyWeight) + " - ";
	             
	          
	        }
		return WeightString;
		
	}


	
	public void setForceWeight( String w ) { forceWeight = w; }
	public void setForceRank ( Integer i ) { forceRank = i; }
	
	List<Bout> bouts = new ArrayList<Bout> ();

	public List<Bout> getBouts() { return bouts; }
	
	public boolean getLossByInjury() { return lossByInjury; }
	
	public WeighInHistory getWeighInHistory() { return wiHistory; }
	
	public void setWeighInHistory(WeighInHistory wih ) { wiHistory = wih; }

	public void setPrestigeLastYear(WrestlingLanguage.Prestige p) { prestigeLastYear = p; }
	public void setPrestige2YearsAgo(WrestlingLanguage.Prestige p) { prestige2YearsAgo= p; }
	public void setPrestige3YearsAgo(WrestlingLanguage.Prestige p) { prestige3YearsAgo = p; }

	public WrestlingLanguage.Prestige getPrestigeLastYear() { return prestigeLastYear; }
	public WrestlingLanguage.Prestige getPrestige2YearsAgo() { return prestige2YearsAgo; }
	public WrestlingLanguage.Prestige getPrestige3YearsAgo() { return prestige3YearsAgo; }

    public void printVerbose () {
		System.out.println( getName() + 
			" Grade<" + getGrade() + ">" + 
			" Seed<" + getSeed() + ">" +
			" Cert<" + getCert() + ">"); 
			//" Gender<" + getGender() + "> Wt<" + 
			//getTrackWtClass() + ">" + " (" + getWins() + "W-" + 
			//getLosses() + "L) Last Year=<" + rosteredLastYear + "> Last Year Record <" + trackLastYearRecord + ">" );
    }	   
	public String getRecordString() { 
		return String.valueOf(wins) + "-" + String.valueOf(losses); 
	}
	public String getRecordBreakdown() {
		String breakdownString = "";
		boolean addedWins=false;
		if ( getWins() > 0 ) {
			breakdownString += getWins() + "W[";
			if ( getWinByFall() > 0 ) {
				breakdownString += getWinByFall() + " Pin,";
				addedWins=true;
			}
			if ( getWinByTech() > 0 ) {
				breakdownString += getWinByTech() + " TF,";
				addedWins=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getWinByMD() + " MD,";
				addedWins=true;
			}
			if ( getWinByDec() > 0 ) {
				breakdownString += getWinByDec() + " Dec,";
				addedWins=true;
			}
			if ( getWinByFFT() > 0 ) {
				breakdownString += getWinByFFT() + " FFT,";
				addedWins=true;
			}
			if ( addedWins ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "0 W";
		}
		boolean addedLosses=false;
		if ( getLosses() > 0 ) {
			breakdownString += "-" + getLosses() + "L[";
			if ( getLossByFall() > 0 ) {
				breakdownString += getLossByFall() + " Pin,";
				addedLosses=true;
			}
			if ( getLossByTech() > 0 ) {
				breakdownString += getLossByTech() + " TF,";
				addedLosses=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getLossByMD() + " MD,";
				addedLosses=true;
			}
			if ( getLossByDec() > 0 ) {
				breakdownString += getLossByDec() + " Dec,";
				addedLosses=true;
			}
			
			if ( addedLosses ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "-0L";
		}
		if ( getWins() ==0 && getLosses() == 0 ) {
			return "";
		} else {
			return breakdownString +" - "+ getWeight();
		}
	}
	public String getName() { return name; }
	public String getSeed() { return seed; }
	public String getCert() { return cert; }
	public String getTeamName() { return teamName; }
	public WrestlingLanguage.Grade getGrade() { return grade; }
	public WrestlingLanguage.Gender getGender() { return gender; }
	public String getTrackRecord() { return trackRecord; }
	public String getTrackWtClass() { return trackWtClass; }
	
	public int getWins() { return wins; }
	public int getLosses() { return losses; }
	
	public int getWinByFFT() { return winByFFT; }
	public int getWinByFall() { return winByFall; }
	public int getWinByTech() { return winByTech; }
	public int getWinByMD() { return winByMD; }
	public int getWinByDec() { return winByDec; }
	
	public int getLossByFFT() { return lossByFFT; }
	public int getLossByFall() { return lossByFall; }
	public int getLossByTech() { return lossByTech; }
	public int getLossByMD() { return lossByMD; }
	public int getLossByDec() { return lossByDec; }
	
    public Wrestler(String n, String team){
		setName(n);
		setTeamName(team);
		return;
	}
	public boolean getRosteredLastYear() { return rosteredLastYear; }
	
	public void setRosteredLastYearOn() { rosteredLastYear = true; }
	public void setRosteredLastYearOff() { rosteredLastYear = false; }
	
	public String getTrackLastYearWtClass() { return trackLastYearWtClass; }
	public String getTrackLastYearRecord() { return trackLastYearRecord; }
	
	public void setTrackLastYearWtClass(String w) { 
		trackLastYearWtClass = w; 
	}
	public void setTrackLastYearRecord(String r) {
		trackLastYearRecord = r;
	}
	
	
	public void addBout(Bout b) {
		String cmd=b.getMatchDate();
		if (cmd == null ) {
			Event e = b.getEvent();
			if ( e != null ) {
				String sss = e.getEventTitle();
				if ( wiHistory != null ) {
					String s = wiHistory.findWeighInDate(sss);
					if ( s != null ) { 
						b.setMatchDate(s);
					}
				}
			}
		}	
		
		bouts.add(b);
		addToSummary(b);
		addToMatchesAtWeight(b);
	}
	private void addToMatchesAtWeight(Bout b) {
		String w=b.getWeight();
		Integer ct = matchesAtWeight.get(w);
		if ( ct != null ) {
			ct++;
			matchesAtWeight.replace(w,ct);
		} else {
			matchesAtWeight.put(w,1);
		}
		return;
	}
	public String getMatchesAtWeightString() {

		String byWt="";
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
	
			int ct = matchesAtWeight.get(key);
			if ( byWt.length() > 0 ) { byWt=byWt + ";" ; }
			byWt=byWt + ct + "@" + key;
		}
		return byWt;
	}
	
	public void setName( String n ) {
		name = n.strip();
	}
	public void setSeed( String n ) {
		seed = n.strip();
	}
	public void setCert( String n ) {
		cert = n.strip();
	}
	public void setTeamName( String team ) {
		teamName = team;
	}
	public void setGrade5() { grade = WrestlingLanguage.Grade.G5;	}
	public void setGrade6() { grade = WrestlingLanguage.Grade.G6;	}
	public void setGrade7() { grade = WrestlingLanguage.Grade.G7;	}
	public void setGrade8() { grade = WrestlingLanguage.Grade.G8;	}
	public void setGrade(WrestlingLanguage.Grade g ) { grade=g; }
	
	public void setGenderM() { gender = WrestlingLanguage.Gender.M;	}
	public void setGenderF() { gender = WrestlingLanguage.Gender.F;	}
	public void setGender(WrestlingLanguage.Gender g ) { gender = g; }
	
	public void setTrackRecord(String rec) {
		trackRecord = rec;
	}
	public void setTrackWtClass(String w ) {
		trackWtClass = w;
	}
	public String toString() {
		return "Wrestler:" + teamName + ":" + name  ;
	}
	private void addToSummary(Bout b) {
	   if ( b.isAWin() ) {
          addWin();	
          switch ( b.getMatchResultType() ) {
			  case FFT: 
			    addWinByFFT();
				break;
			  case FALL:
			    addWinByFall();
				break;
			  case TECH:
			    addWinByTech();
				break;
			  case MD:
			    addWinByMD();
			    break;
			  case DEC:
			    addWinByDec();
				break;
			  case INJ:
			    break;
			  case DQ:
			    break;
		  }
       } else {
          addLoss();
          switch ( b.getMatchResultType() ) {

          case FFT:
			  addLossByFFT();
			    break;
			  case FALL:
			    addLossByFall();
				break;
			  case TECH:
			    addLossByTech();
				break;
			  case MD:
			    addLossByMD();
			    break;
			  case DEC:
			    addLossByDec();
				break;
			  case INJ:
			    if ( lossByInjury) {
			    	lossByInjuryString += ";";
			    } else {
			    	lossByInjury=true;
			    	lossByInjuryString= "Loss by Injury on ";
			    }
			    if ( b.getMatchDate() != null ) {
			    	lossByInjuryString += b.getMatchDate();
			    	lossByInjuryString += " ";
			    }
			    lossByInjuryString += " vs ";
			    lossByInjuryString += b.getOpponentTeam();
			    
			    break;
			  case DQ:
			    break;
		  }		  
       }		  
	}
	public void addWin() { wins++; }
	public void addLoss() { losses++; }
	public void addWinByFFT() { winByFFT++; }
	public void addWinByFall() { winByFall++; }
	public void addWinByTech() { winByTech++; }
	public void addWinByMD() { winByMD++; }
	public void addWinByDec() { winByDec++; }
	
	public void addLossByFFT() { lossByFFT++; }
	public void addLossByFall() { lossByFall++; }
	public void addLossByTech() { lossByTech++; }
	public void addLossByMD() { lossByMD++; }
	public void addLossByDec() { lossByDec++; }

	public boolean equals(Object o) {
	  if ( o == null ) { return false; }
	  if ( this == o ) { return true; }
	  if ( this.getClass() == o.getClass() ){
         Wrestler ow = (Wrestler) o;		  
	     if ( this.getName().equals(ow.getName()) && this.getTeamName().equals(ow.getTeamName())) {
			 return true;
	     }
	  }
	  return false; 
	}
	public int hashCode() {
		return getName().hashCode() + getTeamName().hashCode();
	}


public String getFinWeight() {
	String finWeight = "";
	boolean a = playedMatch();
	
	if(cert != null) {
		finWeight = cert;
	}
	else (this.cert == null&&this.playedMatch()== true){
		finWeight = this.getLowestWeightWrestled();
	}
	
	return finWeight;
}

public boolean playedMatch() {
	if (matchWeight == null) {
		return false;
}	
	return true;
}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4320)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3943)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:577)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui 4 0 2022-10-13 22:33:17.906
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4320)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3943)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:577)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-13 22:33:18.479
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package JuniorHigh;

import java.util.*;
import java.util.Enumeration;

/*
 *
 *  This is a class to holds an wrestler and all data pertaining to him/her.
 */
class Wrestler {
	private String name;
	private String seed;
	private String cert;
	private String teamName;
	private WrestlingLanguage.Grade grade;
	private WrestlingLanguage.Gender gender;
	private String trackRecord;
	private String trackWtClass;
	private boolean rosteredLastYear;
	private String trackLastYearWtClass;
	private String trackLastYearRecord;
	private WrestlingLanguage.Prestige prestigeLastYear;
	private WrestlingLanguage.Prestige prestige2YearsAgo;
	private WrestlingLanguage.Prestige prestige3YearsAgo;
	
	private Hashtable<String,Integer> matchesAtWeight=new Hashtable<String,Integer>();
	
	private int wins;
	private int losses;
	private boolean lossByInjury=false;
	private String lossByInjuryString;
	private int winByFFT;
	private int lossByFFT;

	private int winByFall;
	private int winByDec;
	private int winByMD;
	private int winByTech;
	
	private int lossByFall;
	private int lossByDec;
	private int lossByMD;
	private int lossByTech;
	
	private int weight;
	
	private Hashtable<Integer,Integer> matchWeight=new Hashtable<Integer,Integer>();

		
	private WeighInHistory wiHistory;
	
	/* These 2 attributes are used to force where we put the wrestler in the reporting
	 * order.
	 */
	private String forceWeight=null;  /* for reporting force the use of this weight class. */
	private Integer forceRank=null;  /* for reporting this is the rank order withing the weight class. */

	public void setLossByInjuryString(String s) {
		lossByInjuryString = s;
	}
	public String getLossByInjuryString() { return lossByInjuryString; }
	
	public String getLowestWeightWrestled() {
		int lowInt=99999;
		
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
			int i =  Integer.parseInt(key);
		    if (i < lowInt ) {
		    	lowInt = i;
		    }
		}
		return Integer.toString(lowInt);
	}
	public String getPrintWeight() {
		if ( forceWeight != null ) {
			if ( forceWeight.length() > 0 ) {
				return forceWeight;
			}
		}
		return getLowestWeightWrestled();
	}
	public int getPrintRank() {
		if (forceRank == null ) {
			return getWins() + getLosses();
		} else {
			return 100000 - forceRank.intValue();
		}
	}
	public String getForceWeight() { return forceWeight; }
	public Integer getForceRank() { return forceRank; }
	
	public void setWeight( int w ) { 
		if (matchWeight.containsKey(w)) {
			int val =matchWeight.get(w);
			matchWeight.put(w, val+1);
			
		}
		else {
		matchWeight.put(w, 1);	
		}
		
	}
	public String getWeight() {
		Enumeration<Integer> e = matchWeight.keys();
		String WeightString="";
		while (e.hasMoreElements()) {
			 
	            // Getting the key of a particular entry
	            int keyWeight = e.nextElement();
	            int valueCount = matchWeight.get(keyWeight);
	            
	            WeightString += Integer.toString(valueCount) + "@" + Integer.toString(keyWeight) + " - ";
	             
	          
	        }
		return WeightString;
		
	}


	
	public void setForceWeight( String w ) { forceWeight = w; }
	public void setForceRank ( Integer i ) { forceRank = i; }
	
	List<Bout> bouts = new ArrayList<Bout> ();

	public List<Bout> getBouts() { return bouts; }
	
	public boolean getLossByInjury() { return lossByInjury; }
	
	public WeighInHistory getWeighInHistory() { return wiHistory; }
	
	public void setWeighInHistory(WeighInHistory wih ) { wiHistory = wih; }

	public void setPrestigeLastYear(WrestlingLanguage.Prestige p) { prestigeLastYear = p; }
	public void setPrestige2YearsAgo(WrestlingLanguage.Prestige p) { prestige2YearsAgo= p; }
	public void setPrestige3YearsAgo(WrestlingLanguage.Prestige p) { prestige3YearsAgo = p; }

	public WrestlingLanguage.Prestige getPrestigeLastYear() { return prestigeLastYear; }
	public WrestlingLanguage.Prestige getPrestige2YearsAgo() { return prestige2YearsAgo; }
	public WrestlingLanguage.Prestige getPrestige3YearsAgo() { return prestige3YearsAgo; }

    public void printVerbose () {
		System.out.println( getName() + 
			" Grade<" + getGrade() + ">" + 
			" Seed<" + getSeed() + ">" +
			" Cert<" + getCert() + ">"); 
			//" Gender<" + getGender() + "> Wt<" + 
			//getTrackWtClass() + ">" + " (" + getWins() + "W-" + 
			//getLosses() + "L) Last Year=<" + rosteredLastYear + "> Last Year Record <" + trackLastYearRecord + ">" );
    }	   
	public String getRecordString() { 
		return String.valueOf(wins) + "-" + String.valueOf(losses); 
	}
	public String getRecordBreakdown() {
		String breakdownString = "";
		boolean addedWins=false;
		if ( getWins() > 0 ) {
			breakdownString += getWins() + "W[";
			if ( getWinByFall() > 0 ) {
				breakdownString += getWinByFall() + " Pin,";
				addedWins=true;
			}
			if ( getWinByTech() > 0 ) {
				breakdownString += getWinByTech() + " TF,";
				addedWins=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getWinByMD() + " MD,";
				addedWins=true;
			}
			if ( getWinByDec() > 0 ) {
				breakdownString += getWinByDec() + " Dec,";
				addedWins=true;
			}
			if ( getWinByFFT() > 0 ) {
				breakdownString += getWinByFFT() + " FFT,";
				addedWins=true;
			}
			if ( addedWins ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "0 W";
		}
		boolean addedLosses=false;
		if ( getLosses() > 0 ) {
			breakdownString += "-" + getLosses() + "L[";
			if ( getLossByFall() > 0 ) {
				breakdownString += getLossByFall() + " Pin,";
				addedLosses=true;
			}
			if ( getLossByTech() > 0 ) {
				breakdownString += getLossByTech() + " TF,";
				addedLosses=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getLossByMD() + " MD,";
				addedLosses=true;
			}
			if ( getLossByDec() > 0 ) {
				breakdownString += getLossByDec() + " Dec,";
				addedLosses=true;
			}
			
			if ( addedLosses ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "-0L";
		}
		if ( getWins() ==0 && getLosses() == 0 ) {
			return "";
		} else {
			return breakdownString +" - "+ getWeight();
		}
	}
	public String getName() { return name; }
	public String getSeed() { return seed; }
	public String getCert() { return cert; }
	public String getTeamName() { return teamName; }
	public WrestlingLanguage.Grade getGrade() { return grade; }
	public WrestlingLanguage.Gender getGender() { return gender; }
	public String getTrackRecord() { return trackRecord; }
	public String getTrackWtClass() { return trackWtClass; }
	
	public int getWins() { return wins; }
	public int getLosses() { return losses; }
	
	public int getWinByFFT() { return winByFFT; }
	public int getWinByFall() { return winByFall; }
	public int getWinByTech() { return winByTech; }
	public int getWinByMD() { return winByMD; }
	public int getWinByDec() { return winByDec; }
	
	public int getLossByFFT() { return lossByFFT; }
	public int getLossByFall() { return lossByFall; }
	public int getLossByTech() { return lossByTech; }
	public int getLossByMD() { return lossByMD; }
	public int getLossByDec() { return lossByDec; }
	
    public Wrestler(String n, String team){
		setName(n);
		setTeamName(team);
		return;
	}
	public boolean getRosteredLastYear() { return rosteredLastYear; }
	
	public void setRosteredLastYearOn() { rosteredLastYear = true; }
	public void setRosteredLastYearOff() { rosteredLastYear = false; }
	
	public String getTrackLastYearWtClass() { return trackLastYearWtClass; }
	public String getTrackLastYearRecord() { return trackLastYearRecord; }
	
	public void setTrackLastYearWtClass(String w) { 
		trackLastYearWtClass = w; 
	}
	public void setTrackLastYearRecord(String r) {
		trackLastYearRecord = r;
	}
	
	
	public void addBout(Bout b) {
		String cmd=b.getMatchDate();
		if (cmd == null ) {
			Event e = b.getEvent();
			if ( e != null ) {
				String sss = e.getEventTitle();
				if ( wiHistory != null ) {
					String s = wiHistory.findWeighInDate(sss);
					if ( s != null ) { 
						b.setMatchDate(s);
					}
				}
			}
		}	
		
		bouts.add(b);
		addToSummary(b);
		addToMatchesAtWeight(b);
	}
	private void addToMatchesAtWeight(Bout b) {
		String w=b.getWeight();
		Integer ct = matchesAtWeight.get(w);
		if ( ct != null ) {
			ct++;
			matchesAtWeight.replace(w,ct);
		} else {
			matchesAtWeight.put(w,1);
		}
		return;
	}
	public String getMatchesAtWeightString() {

		String byWt="";
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
	
			int ct = matchesAtWeight.get(key);
			if ( byWt.length() > 0 ) { byWt=byWt + ";" ; }
			byWt=byWt + ct + "@" + key;
		}
		return byWt;
	}
	
	public void setName( String n ) {
		name = n.strip();
	}
	public void setSeed( String n ) {
		seed = n.strip();
	}
	public void setCert( String n ) {
		cert = n.strip();
	}
	public void setTeamName( String team ) {
		teamName = team;
	}
	public void setGrade5() { grade = WrestlingLanguage.Grade.G5;	}
	public void setGrade6() { grade = WrestlingLanguage.Grade.G6;	}
	public void setGrade7() { grade = WrestlingLanguage.Grade.G7;	}
	public void setGrade8() { grade = WrestlingLanguage.Grade.G8;	}
	public void setGrade(WrestlingLanguage.Grade g ) { grade=g; }
	
	public void setGenderM() { gender = WrestlingLanguage.Gender.M;	}
	public void setGenderF() { gender = WrestlingLanguage.Gender.F;	}
	public void setGender(WrestlingLanguage.Gender g ) { gender = g; }
	
	public void setTrackRecord(String rec) {
		trackRecord = rec;
	}
	public void setTrackWtClass(String w ) {
		trackWtClass = w;
	}
	public String toString() {
		return "Wrestler:" + teamName + ":" + name  ;
	}
	private void addToSummary(Bout b) {
	   if ( b.isAWin() ) {
          addWin();	
          switch ( b.getMatchResultType() ) {
			  case FFT: 
			    addWinByFFT();
				break;
			  case FALL:
			    addWinByFall();
				break;
			  case TECH:
			    addWinByTech();
				break;
			  case MD:
			    addWinByMD();
			    break;
			  case DEC:
			    addWinByDec();
				break;
			  case INJ:
			    break;
			  case DQ:
			    break;
		  }
       } else {
          addLoss();
          switch ( b.getMatchResultType() ) {

          case FFT:
			  addLossByFFT();
			    break;
			  case FALL:
			    addLossByFall();
				break;
			  case TECH:
			    addLossByTech();
				break;
			  case MD:
			    addLossByMD();
			    break;
			  case DEC:
			    addLossByDec();
				break;
			  case INJ:
			    if ( lossByInjury) {
			    	lossByInjuryString += ";";
			    } else {
			    	lossByInjury=true;
			    	lossByInjuryString= "Loss by Injury on ";
			    }
			    if ( b.getMatchDate() != null ) {
			    	lossByInjuryString += b.getMatchDate();
			    	lossByInjuryString += " ";
			    }
			    lossByInjuryString += " vs ";
			    lossByInjuryString += b.getOpponentTeam();
			    
			    break;
			  case DQ:
			    break;
		  }		  
       }		  
	}
	public void addWin() { wins++; }
	public void addLoss() { losses++; }
	public void addWinByFFT() { winByFFT++; }
	public void addWinByFall() { winByFall++; }
	public void addWinByTech() { winByTech++; }
	public void addWinByMD() { winByMD++; }
	public void addWinByDec() { winByDec++; }
	
	public void addLossByFFT() { lossByFFT++; }
	public void addLossByFall() { lossByFall++; }
	public void addLossByTech() { lossByTech++; }
	public void addLossByMD() { lossByMD++; }
	public void addLossByDec() { lossByDec++; }

	public boolean equals(Object o) {
	  if ( o == null ) { return false; }
	  if ( this == o ) { return true; }
	  if ( this.getClass() == o.getClass() ){
         Wrestler ow = (Wrestler) o;		  
	     if ( this.getName().equals(ow.getName()) && this.getTeamName().equals(ow.getTeamName())) {
			 return true;
	     }
	  }
	  return false; 
	}
	public int hashCode() {
		return getName().hashCode() + getTeamName().hashCode();
	}


public String getFinWeight() {
	String finWeight = "";
	boolean a = playedMatch();
	
	if(cert != null) {
		finWeight = cert;
	}
	else (this.cert == null&&this.playedMatch()== true){
		finWeight = this.getLowestWeightWrestled();
	}
	
	return finWeight;
}

public boolean playedMatch() {
	if (matchWeight == null) {
		return false;
}	
	return true;
}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-13 22:33:18.480
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-13 22:33:18.480
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-10-13 22:33:20.650
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package JuniorHigh;

import java.util.*;
import java.util.Enumeration;

/*
 *
 *  This is a class to holds an wrestler and all data pertaining to him/her.
 */
class Wrestler {
	private String name;
	private String seed;
	private String cert;
	private String teamName;
	private WrestlingLanguage.Grade grade;
	private WrestlingLanguage.Gender gender;
	private String trackRecord;
	private String trackWtClass;
	private boolean rosteredLastYear;
	private String trackLastYearWtClass;
	private String trackLastYearRecord;
	private WrestlingLanguage.Prestige prestigeLastYear;
	private WrestlingLanguage.Prestige prestige2YearsAgo;
	private WrestlingLanguage.Prestige prestige3YearsAgo;
	
	private Hashtable<String,Integer> matchesAtWeight=new Hashtable<String,Integer>();
	
	private int wins;
	private int losses;
	private boolean lossByInjury=false;
	private String lossByInjuryString;
	private int winByFFT;
	private int lossByFFT;

	private int winByFall;
	private int winByDec;
	private int winByMD;
	private int winByTech;
	
	private int lossByFall;
	private int lossByDec;
	private int lossByMD;
	private int lossByTech;
	
	private int weight;
	
	private Hashtable<Integer,Integer> matchWeight=new Hashtable<Integer,Integer>();

		
	private WeighInHistory wiHistory;
	
	/* These 2 attributes are used to force where we put the wrestler in the reporting
	 * order.
	 */
	private String forceWeight=null;  /* for reporting force the use of this weight class. */
	private Integer forceRank=null;  /* for reporting this is the rank order withing the weight class. */

	public void setLossByInjuryString(String s) {
		lossByInjuryString = s;
	}
	public String getLossByInjuryString() { return lossByInjuryString; }
	
	public String getLowestWeightWrestled() {
		int lowInt=99999;
		
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
			int i =  Integer.parseInt(key);
		    if (i < lowInt ) {
		    	lowInt = i;
		    }
		}
		return Integer.toString(lowInt);
	}
	public String getPrintWeight() {
		if ( forceWeight != null ) {
			if ( forceWeight.length() > 0 ) {
				return forceWeight;
			}
		}
		return getLowestWeightWrestled();
	}
	public int getPrintRank() {
		if (forceRank == null ) {
			return getWins() + getLosses();
		} else {
			return 100000 - forceRank.intValue();
		}
	}
	public String getForceWeight() { return forceWeight; }
	public Integer getForceRank() { return forceRank; }
	
	public void setWeight( int w ) { 
		if (matchWeight.containsKey(w)) {
			int val =matchWeight.get(w);
			matchWeight.put(w, val+1);
			
		}
		else {
		matchWeight.put(w, 1);	
		}
		
	}
	public String getWeight() {
		Enumeration<Integer> e = matchWeight.keys();
		String WeightString="";
		while (e.hasMoreElements()) {
			 
	            // Getting the key of a particular entry
	            int keyWeight = e.nextElement();
	            int valueCount = matchWeight.get(keyWeight);
	            
	            WeightString += Integer.toString(valueCount) + "@" + Integer.toString(keyWeight) + " - ";
	             
	          
	        }
		return WeightString;
		
	}


	
	public void setForceWeight( String w ) { forceWeight = w; }
	public void setForceRank ( Integer i ) { forceRank = i; }
	
	List<Bout> bouts = new ArrayList<Bout> ();

	public List<Bout> getBouts() { return bouts; }
	
	public boolean getLossByInjury() { return lossByInjury; }
	
	public WeighInHistory getWeighInHistory() { return wiHistory; }
	
	public void setWeighInHistory(WeighInHistory wih ) { wiHistory = wih; }

	public void setPrestigeLastYear(WrestlingLanguage.Prestige p) { prestigeLastYear = p; }
	public void setPrestige2YearsAgo(WrestlingLanguage.Prestige p) { prestige2YearsAgo= p; }
	public void setPrestige3YearsAgo(WrestlingLanguage.Prestige p) { prestige3YearsAgo = p; }

	public WrestlingLanguage.Prestige getPrestigeLastYear() { return prestigeLastYear; }
	public WrestlingLanguage.Prestige getPrestige2YearsAgo() { return prestige2YearsAgo; }
	public WrestlingLanguage.Prestige getPrestige3YearsAgo() { return prestige3YearsAgo; }

    public void printVerbose () {
		System.out.println( getName() + 
			" Grade<" + getGrade() + ">" + 
			" Seed<" + getSeed() + ">" +
			" Cert<" + getCert() + ">"); 
			//" Gender<" + getGender() + "> Wt<" + 
			//getTrackWtClass() + ">" + " (" + getWins() + "W-" + 
			//getLosses() + "L) Last Year=<" + rosteredLastYear + "> Last Year Record <" + trackLastYearRecord + ">" );
    }	   
	public String getRecordString() { 
		return String.valueOf(wins) + "-" + String.valueOf(losses); 
	}
	public String getRecordBreakdown() {
		String breakdownString = "";
		boolean addedWins=false;
		if ( getWins() > 0 ) {
			breakdownString += getWins() + "W[";
			if ( getWinByFall() > 0 ) {
				breakdownString += getWinByFall() + " Pin,";
				addedWins=true;
			}
			if ( getWinByTech() > 0 ) {
				breakdownString += getWinByTech() + " TF,";
				addedWins=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getWinByMD() + " MD,";
				addedWins=true;
			}
			if ( getWinByDec() > 0 ) {
				breakdownString += getWinByDec() + " Dec,";
				addedWins=true;
			}
			if ( getWinByFFT() > 0 ) {
				breakdownString += getWinByFFT() + " FFT,";
				addedWins=true;
			}
			if ( addedWins ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "0 W";
		}
		boolean addedLosses=false;
		if ( getLosses() > 0 ) {
			breakdownString += "-" + getLosses() + "L[";
			if ( getLossByFall() > 0 ) {
				breakdownString += getLossByFall() + " Pin,";
				addedLosses=true;
			}
			if ( getLossByTech() > 0 ) {
				breakdownString += getLossByTech() + " TF,";
				addedLosses=true;
			}
			if ( getWinByMD() > 0 ) {
				breakdownString += getLossByMD() + " MD,";
				addedLosses=true;
			}
			if ( getLossByDec() > 0 ) {
				breakdownString += getLossByDec() + " Dec,";
				addedLosses=true;
			}
			
			if ( addedLosses ) { 
				breakdownString = breakdownString.substring(0,breakdownString.length()-1);
			}
			breakdownString += "]";
		} else {
			breakdownString += "-0L";
		}
		if ( getWins() ==0 && getLosses() == 0 ) {
			return "";
		} else {
			return breakdownString +" - "+ getWeight();
		}
	}
	public String getName() { return name; }
	public String getSeed() { return seed; }
	public String getCert() { return cert; }
	public String getTeamName() { return teamName; }
	public WrestlingLanguage.Grade getGrade() { return grade; }
	public WrestlingLanguage.Gender getGender() { return gender; }
	public String getTrackRecord() { return trackRecord; }
	public String getTrackWtClass() { return trackWtClass; }
	
	public int getWins() { return wins; }
	public int getLosses() { return losses; }
	
	public int getWinByFFT() { return winByFFT; }
	public int getWinByFall() { return winByFall; }
	public int getWinByTech() { return winByTech; }
	public int getWinByMD() { return winByMD; }
	public int getWinByDec() { return winByDec; }
	
	public int getLossByFFT() { return lossByFFT; }
	public int getLossByFall() { return lossByFall; }
	public int getLossByTech() { return lossByTech; }
	public int getLossByMD() { return lossByMD; }
	public int getLossByDec() { return lossByDec; }
	
    public Wrestler(String n, String team){
		setName(n);
		setTeamName(team);
		return;
	}
	public boolean getRosteredLastYear() { return rosteredLastYear; }
	
	public void setRosteredLastYearOn() { rosteredLastYear = true; }
	public void setRosteredLastYearOff() { rosteredLastYear = false; }
	
	public String getTrackLastYearWtClass() { return trackLastYearWtClass; }
	public String getTrackLastYearRecord() { return trackLastYearRecord; }
	
	public void setTrackLastYearWtClass(String w) { 
		trackLastYearWtClass = w; 
	}
	public void setTrackLastYearRecord(String r) {
		trackLastYearRecord = r;
	}
	
	
	public void addBout(Bout b) {
		String cmd=b.getMatchDate();
		if (cmd == null ) {
			Event e = b.getEvent();
			if ( e != null ) {
				String sss = e.getEventTitle();
				if ( wiHistory != null ) {
					String s = wiHistory.findWeighInDate(sss);
					if ( s != null ) { 
						b.setMatchDate(s);
					}
				}
			}
		}	
		
		bouts.add(b);
		addToSummary(b);
		addToMatchesAtWeight(b);
	}
	private void addToMatchesAtWeight(Bout b) {
		String w=b.getWeight();
		Integer ct = matchesAtWeight.get(w);
		if ( ct != null ) {
			ct++;
			matchesAtWeight.replace(w,ct);
		} else {
			matchesAtWeight.put(w,1);
		}
		return;
	}
	public String getMatchesAtWeightString() {

		String byWt="";
		Set<String> keys = matchesAtWeight.keySet();
		for (String key: keys ) {
	
			int ct = matchesAtWeight.get(key);
			if ( byWt.length() > 0 ) { byWt=byWt + ";" ; }
			byWt=byWt + ct + "@" + key;
		}
		return byWt;
	}
	
	public void setName( String n ) {
		name = n.strip();
	}
	public void setSeed( String n ) {
		seed = n.strip();
	}
	public void setCert( String n ) {
		cert = n.strip();
	}
	public void setTeamName( String team ) {
		teamName = team;
	}
	public void setGrade5() { grade = WrestlingLanguage.Grade.G5;	}
	public void setGrade6() { grade = WrestlingLanguage.Grade.G6;	}
	public void setGrade7() { grade = WrestlingLanguage.Grade.G7;	}
	public void setGrade8() { grade = WrestlingLanguage.Grade.G8;	}
	public void setGrade(WrestlingLanguage.Grade g ) { grade=g; }
	
	public void setGenderM() { gender = WrestlingLanguage.Gender.M;	}
	public void setGenderF() { gender = WrestlingLanguage.Gender.F;	}
	public void setGender(WrestlingLanguage.Gender g ) { gender = g; }
	
	public void setTrackRecord(String rec) {
		trackRecord = rec;
	}
	public void setTrackWtClass(String w ) {
		trackWtClass = w;
	}
	public String toString() {
		return "Wrestler:" + teamName + ":" + name  ;
	}
	private void addToSummary(Bout b) {
	   if ( b.isAWin() ) {
          addWin();	
          switch ( b.getMatchResultType() ) {
			  case FFT: 
			    addWinByFFT();
				break;
			  case FALL:
			    addWinByFall();
				break;
			  case TECH:
			    addWinByTech();
				break;
			  case MD:
			    addWinByMD();
			    break;
			  case DEC:
			    addWinByDec();
				break;
			  case INJ:
			    break;
			  case DQ:
			    break;
		  }
       } else {
          addLoss();
          switch ( b.getMatchResultType() ) {

          case FFT:
			  addLossByFFT();
			    break;
			  case FALL:
			    addLossByFall();
				break;
			  case TECH:
			    addLossByTech();
				break;
			  case MD:
			    addLossByMD();
			    break;
			  case DEC:
			    addLossByDec();
				break;
			  case INJ:
			    if ( lossByInjury) {
			    	lossByInjuryString += ";";
			    } else {
			    	lossByInjury=true;
			    	lossByInjuryString= "Loss by Injury on ";
			    }
			    if ( b.getMatchDate() != null ) {
			    	lossByInjuryString += b.getMatchDate();
			    	lossByInjuryString += " ";
			    }
			    lossByInjuryString += " vs ";
			    lossByInjuryString += b.getOpponentTeam();
			    
			    break;
			  case DQ:
			    break;
		  }		  
       }		  
	}
	public void addWin() { wins++; }
	public void addLoss() { losses++; }
	public void addWinByFFT() { winByFFT++; }
	public void addWinByFall() { winByFall++; }
	public void addWinByTech() { winByTech++; }
	public void addWinByMD() { winByMD++; }
	public void addWinByDec() { winByDec++; }
	
	public void addLossByFFT() { lossByFFT++; }
	public void addLossByFall() { lossByFall++; }
	public void addLossByTech() { lossByTech++; }
	public void addLossByMD() { lossByMD++; }
	public void addLossByDec() { lossByDec++; }

	public boolean equals(Object o) {
	  if ( o == null ) { return false; }
	  if ( this == o ) { return true; }
	  if ( this.getClass() == o.getClass() ){
         Wrestler ow = (Wrestler) o;		  
	     if ( this.getName().equals(ow.getName()) && this.getTeamName().equals(ow.getTeamName())) {
			 return true;
	     }
	  }
	  return false; 
	}
	public int hashCode() {
		return getName().hashCode() + getTeamName().hashCode();
	}


public String getFinWeight() {
	String finWeight = "";
	boolean a = playedMatch();
	
	if(cert != null) {
		finWeight = cert;
	}
	else (this.cert == null&&this.playedMatch()== true){
		finWeight = this.getLowestWeightWrestled();
	}
	
	return finWeight;
}

public boolean playedMatch() {
	if (matchWeight == null) {
		return false;
}	
	return true;
}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-10-13 22:33:20.651
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-10-13 22:33:20.651
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2038)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2022-10-15 11:47:04.021 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=18
java.vendor=Oracle Corporation
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/arnavgupta/.eclipse_keyring
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/arnavgupta/.eclipse_keyring

!ENTRY org.eclipse.jface 2 0 2022-10-15 11:47:10.315
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-15 11:47:10.315
!MESSAGE A conflict occurred for COMMAND+SHIFT+T:
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2ceb68a1,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6de33fde,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-15 11:47:10.315
!MESSAGE A conflict occurred for ALT+COMMAND+R:
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@69c33ea2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@59e0d521,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)
!SESSION 2022-10-16 00:14:00.065 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=18
java.vendor=Oracle Corporation
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/arnavgupta/.eclipse_keyring
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/arnavgupta/.eclipse_keyring

!ENTRY org.eclipse.jface 2 0 2022-10-16 00:14:06.695
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-16 00:14:06.695
!MESSAGE A conflict occurred for COMMAND+SHIFT+T:
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@37c87fcc,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@ca2be53,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-16 00:14:06.695
!MESSAGE A conflict occurred for ALT+COMMAND+R:
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@78f5cbc5,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@70697478,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)
!SESSION 2022-10-16 20:30:16.656 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=18
java.vendor=Oracle Corporation
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/arnavgupta/.eclipse_keyring
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/arnavgupta/.eclipse_keyring

!ENTRY org.eclipse.jface 2 0 2022-10-16 20:30:23.160
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-16 20:30:23.160
!MESSAGE A conflict occurred for COMMAND+SHIFT+T:
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@d13379e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7c8df667,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-16 20:30:23.160
!MESSAGE A conflict occurred for ALT+COMMAND+R:
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@498e41a4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@be616f0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)
!SESSION 2022-10-19 21:15:21.593 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=18
java.vendor=Oracle Corporation
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/arnavgupta/.eclipse_keyring
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/arnavgupta/.eclipse_keyring

!ENTRY org.eclipse.jface 2 0 2022-10-19 21:15:28.097
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-19 21:15:28.097
!MESSAGE A conflict occurred for COMMAND+SHIFT+T:
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@32c0fecc,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@35ceec81,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-19 21:15:28.097
!MESSAGE A conflict occurred for ALT+COMMAND+R:
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@d13379e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7c8df667,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)
!SESSION 2022-10-26 21:13:07.141 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=18
java.vendor=Oracle Corporation
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/arnavgupta/.eclipse_keyring
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/arnavgupta/.eclipse_keyring

!ENTRY org.eclipse.jface 2 0 2022-10-26 21:13:13.852
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-26 21:13:13.852
!MESSAGE A conflict occurred for COMMAND+SHIFT+T:
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@ca2be53,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@78f5cbc5,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-26 21:13:13.852
!MESSAGE A conflict occurred for ALT+COMMAND+R:
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@70697478,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@42b43a6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)
!SESSION 2022-10-28 23:32:49.464 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=18
java.vendor=Oracle Corporation
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/arnavgupta/.eclipse_keyring
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/arnavgupta/.eclipse_keyring

!ENTRY org.eclipse.jface 2 0 2022-10-28 23:32:56.043
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-28 23:32:56.043
!MESSAGE A conflict occurred for COMMAND+SHIFT+T:
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@498e41a4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@be616f0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-28 23:32:56.043
!MESSAGE A conflict occurred for ALT+COMMAND+R:
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1f5d7fd5,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@cf08c97,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)
!SESSION 2022-10-31 12:16:44.685 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=18
java.vendor=Oracle Corporation
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/arnavgupta/.eclipse_keyring
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/arnavgupta/.eclipse_keyring

!ENTRY org.eclipse.jface 2 0 2022-10-31 12:16:51.169
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-31 12:16:51.169
!MESSAGE A conflict occurred for COMMAND+SHIFT+T:
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60a6840c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@53525379,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-10-31 12:16:51.169
!MESSAGE A conflict occurred for ALT+COMMAND+R:
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1be3f8f8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@78b9155e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)
!SESSION 2022-11-02 21:46:07.710 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=18
java.vendor=Oracle Corporation
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/arnavgupta/.eclipse_keyring
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/arnavgupta/.eclipse_keyring

!ENTRY org.eclipse.jface 2 0 2022-11-02 21:46:14.458
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-02 21:46:14.458
!MESSAGE A conflict occurred for COMMAND+SHIFT+T:
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@192f5f39,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4cd5fc46,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-02 21:46:14.458
!MESSAGE A conflict occurred for ALT+COMMAND+R:
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2965dd88,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3221588e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)
!SESSION 2022-11-06 15:15:11.742 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=18
java.vendor=Oracle Corporation
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/arnavgupta/.eclipse_keyring
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/arnavgupta/.eclipse_keyring

!ENTRY org.eclipse.jface 2 0 2022-11-06 15:15:18.010
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-06 15:15:18.010
!MESSAGE A conflict occurred for COMMAND+SHIFT+T:
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5ad0c70a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2a16d4dc,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-06 15:15:18.010
!MESSAGE A conflict occurred for ALT+COMMAND+R:
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@75805562,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@13d984ee,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)
!SESSION 2022-11-06 21:21:37.374 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=18
java.vendor=Oracle Corporation
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/arnavgupta/.eclipse_keyring
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/arnavgupta/.eclipse_keyring

!ENTRY org.eclipse.jface 2 0 2022-11-06 21:21:43.910
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-06 21:21:43.910
!MESSAGE A conflict occurred for COMMAND+SHIFT+T:
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7c8df667,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@498e41a4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-06 21:21:43.910
!MESSAGE A conflict occurred for ALT+COMMAND+R:
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@be616f0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1f5d7fd5,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)
!SESSION 2022-11-07 21:28:13.085 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=18
java.vendor=Oracle Corporation
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/arnavgupta/.eclipse_keyring
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/arnavgupta/.eclipse_keyring

!ENTRY org.eclipse.jface 2 0 2022-11-07 21:28:20.464
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-07 21:28:20.464
!MESSAGE A conflict occurred for COMMAND+SHIFT+T:
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@35ceec81,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@d13379e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-07 21:28:20.464
!MESSAGE A conflict occurred for ALT+COMMAND+R:
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7c8df667,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@498e41a4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)
!SESSION 2022-11-09 21:20:11.501 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=18
java.vendor=Oracle Corporation
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/arnavgupta/.eclipse_keyring
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/arnavgupta/.eclipse_keyring

!ENTRY org.eclipse.jface 2 0 2022-11-09 21:20:18.633
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-09 21:20:18.633
!MESSAGE A conflict occurred for COMMAND+SHIFT+T:
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2152fde5,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5d58dc61,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-09 21:20:18.633
!MESSAGE A conflict occurred for ALT+COMMAND+R:
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@32328dc4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@17df689e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)
!SESSION 2022-11-11 12:14:52.829 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=18
java.vendor=Oracle Corporation
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/arnavgupta/.eclipse_keyring
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/arnavgupta/.eclipse_keyring

!ENTRY org.eclipse.jface 2 0 2022-11-11 12:14:59.018
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-11 12:14:59.018
!MESSAGE A conflict occurred for COMMAND+SHIFT+T:
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5bb99d1d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3006bfb,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-11 12:14:59.018
!MESSAGE A conflict occurred for ALT+COMMAND+R:
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4fd37449,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5402612e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)

!ENTRY org.eclipse.core.resources 2 2 2022-11-11 22:29:52.399
!MESSAGE Save operation warnings.
!SUBENTRY 1 org.eclipse.core.resources 2 234 2022-11-11 22:29:52.400
!MESSAGE The project description file (.project) for 'TrackExtract' was missing.  This file contains important information about the project.  A new project description file has been created, but some information about the project may have been lost.
!SESSION 2022-11-12 18:55:03.365 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=18
java.vendor=Oracle Corporation
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/arnavgupta/.eclipse_keyring
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/arnavgupta/.eclipse_keyring

!ENTRY org.eclipse.jface 2 0 2022-11-12 18:55:09.985
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-12 18:55:09.985
!MESSAGE A conflict occurred for COMMAND+SHIFT+T:
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@32c0fecc,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@35ceec81,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-12 18:55:09.985
!MESSAGE A conflict occurred for ALT+COMMAND+R:
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@d13379e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7c8df667,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)

!ENTRY org.eclipse.ui 4 0 2022-11-12 20:07:48.641
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.swt.widgets.Display.filters(int)" because "this.display" is null
	at org.eclipse.swt.widgets.Widget.filters(Widget.java:831)
	at org.eclipse.swt.widgets.Control.scrollWheel(Control.java:2551)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:6388)
	at org.eclipse.swt.internal.cocoa.OS.objc_msgSendSuper(Native Method)
	at org.eclipse.swt.widgets.Widget.callSuper(Widget.java:236)
	at org.eclipse.swt.widgets.Widget.scrollWheel(Widget.java:1505)
	at org.eclipse.swt.widgets.Control.scrollWheel(Control.java:2560)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:6388)
	at org.eclipse.swt.internal.cocoa.OS.objc_msgSendSuper(Native Method)
	at org.eclipse.swt.widgets.Widget.callSuper(Widget.java:236)
	at org.eclipse.swt.widgets.Widget.windowSendEvent(Widget.java:2162)
	at org.eclipse.swt.widgets.Shell.windowSendEvent(Shell.java:2487)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:6380)
	at org.eclipse.swt.internal.cocoa.OS.objc_msgSendSuper(Native Method)
	at org.eclipse.swt.widgets.Display.applicationSendEvent(Display.java:5628)
	at org.eclipse.swt.widgets.Display.applicationProc(Display.java:5767)
	at org.eclipse.swt.internal.cocoa.OS.objc_msgSend(Native Method)
	at org.eclipse.swt.internal.cocoa.NSApplication.sendEvent(NSApplication.java:117)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3938)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:577)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.debug.core 2 0 2022-11-13 16:26:59.742
!MESSAGE Compile error during code evaluation: The type java.util.TimSort is ambiguous

!ENTRY org.eclipse.debug.core 2 0 2022-11-13 16:26:59.786
!MESSAGE Compile error during code evaluation: The type java.util.TimSort is ambiguous

!ENTRY org.eclipse.debug.core 2 0 2022-11-13 16:26:59.804
!MESSAGE Compile error during code evaluation: The type java.util.TimSort is ambiguous

!ENTRY org.eclipse.debug.core 2 0 2022-11-13 16:26:59.814
!MESSAGE Compile error during code evaluation: The type java.util.TimSort is ambiguous

!ENTRY org.eclipse.debug.core 2 0 2022-11-13 16:26:59.842
!MESSAGE Compile error during code evaluation: The type java.util.TimSort is ambiguous

!ENTRY org.eclipse.debug.core 2 0 2022-11-13 16:26:59.861
!MESSAGE Compile error during code evaluation: The type java.util.TimSort is ambiguous

!ENTRY org.eclipse.debug.core 2 0 2022-11-13 16:26:59.875
!MESSAGE Compile error during code evaluation: The type java.util.TimSort is ambiguous

!ENTRY org.eclipse.debug.core 2 0 2022-11-13 16:26:59.892
!MESSAGE Compile error during code evaluation: The type java.util.TimSort is ambiguous

!ENTRY org.eclipse.debug.core 2 0 2022-11-13 16:26:59.901
!MESSAGE Compile error during code evaluation: The type java.util.TimSort is ambiguous

!ENTRY org.eclipse.debug.core 2 0 2022-11-13 16:26:59.909
!MESSAGE Compile error during code evaluation: The type java.util.TimSort is ambiguous

!ENTRY org.eclipse.debug.core 2 0 2022-11-13 16:27:00.466
!MESSAGE Compile error during code evaluation: The type java.util.TimSort is ambiguous

!ENTRY org.eclipse.debug.core 2 0 2022-11-13 16:27:00.474
!MESSAGE Compile error during code evaluation: The type java.util.TimSort is ambiguous

!ENTRY org.eclipse.debug.core 2 0 2022-11-13 16:27:00.483
!MESSAGE Compile error during code evaluation: The type java.util.TimSort is ambiguous

!ENTRY org.eclipse.debug.core 2 0 2022-11-13 16:27:00.493
!MESSAGE Compile error during code evaluation: The type java.util.TimSort is ambiguous

!ENTRY org.eclipse.debug.core 2 0 2022-11-13 16:27:00.506
!MESSAGE Compile error during code evaluation: The type java.util.TimSort is ambiguous

!ENTRY org.eclipse.debug.core 2 0 2022-11-13 16:27:00.518
!MESSAGE Compile error during code evaluation: The type java.util.TimSort is ambiguous

!ENTRY org.eclipse.debug.core 2 0 2022-11-13 16:27:00.526
!MESSAGE Compile error during code evaluation: The type java.util.TimSort is ambiguous

!ENTRY org.eclipse.debug.core 2 0 2022-11-13 16:27:00.534
!MESSAGE Compile error during code evaluation: The type java.util.TimSort is ambiguous

!ENTRY org.eclipse.debug.core 2 0 2022-11-13 16:27:00.544
!MESSAGE Compile error during code evaluation: The type java.util.TimSort is ambiguous

!ENTRY org.eclipse.debug.core 2 0 2022-11-13 16:27:00.553
!MESSAGE Compile error during code evaluation: The type java.util.TimSort is ambiguous

!ENTRY org.eclipse.debug.core 2 0 2022-11-13 16:27:01.339
!MESSAGE Compile error during code evaluation: The type java.util.TimSort is ambiguous

!ENTRY org.eclipse.debug.core 2 0 2022-11-13 16:27:01.346
!MESSAGE Compile error during code evaluation: The type java.util.TimSort is ambiguous

!ENTRY org.eclipse.debug.core 2 0 2022-11-13 16:27:01.359
!MESSAGE Compile error during code evaluation: The type java.util.TimSort is ambiguous

!ENTRY org.eclipse.debug.core 2 0 2022-11-13 16:27:01.370
!MESSAGE Compile error during code evaluation: The type java.util.TimSort is ambiguous

!ENTRY org.eclipse.debug.core 2 0 2022-11-13 16:27:01.377
!MESSAGE Compile error during code evaluation: The type java.util.TimSort is ambiguous

!ENTRY org.eclipse.debug.core 2 0 2022-11-13 16:27:01.386
!MESSAGE Compile error during code evaluation: The type java.util.TimSort is ambiguous

!ENTRY org.eclipse.debug.core 2 0 2022-11-13 16:27:01.394
!MESSAGE Compile error during code evaluation: The type java.util.TimSort is ambiguous

!ENTRY org.eclipse.debug.core 2 0 2022-11-13 16:27:01.402
!MESSAGE Compile error during code evaluation: The type java.util.TimSort is ambiguous

!ENTRY org.eclipse.debug.core 2 0 2022-11-13 16:27:01.409
!MESSAGE Compile error during code evaluation: The type java.util.TimSort is ambiguous

!ENTRY org.eclipse.debug.core 2 0 2022-11-13 16:27:01.418
!MESSAGE Compile error during code evaluation: The type java.util.TimSort is ambiguous

!ENTRY org.eclipse.debug.core 2 0 2022-11-13 16:27:01.861
!MESSAGE Compile error during code evaluation: The type java.util.TimSort is ambiguous

!ENTRY org.eclipse.debug.core 2 0 2022-11-13 16:27:01.869
!MESSAGE Compile error during code evaluation: The type java.util.TimSort is ambiguous

!ENTRY org.eclipse.debug.core 2 0 2022-11-13 16:27:01.876
!MESSAGE Compile error during code evaluation: The type java.util.TimSort is ambiguous

!ENTRY org.eclipse.debug.core 2 0 2022-11-13 16:27:01.885
!MESSAGE Compile error during code evaluation: The type java.util.TimSort is ambiguous

!ENTRY org.eclipse.debug.core 2 0 2022-11-13 16:27:01.896
!MESSAGE Compile error during code evaluation: The type java.util.TimSort is ambiguous

!ENTRY org.eclipse.debug.core 2 0 2022-11-13 16:27:01.905
!MESSAGE Compile error during code evaluation: The type java.util.TimSort is ambiguous

!ENTRY org.eclipse.debug.core 2 0 2022-11-13 16:27:01.917
!MESSAGE Compile error during code evaluation: The type java.util.TimSort is ambiguous

!ENTRY org.eclipse.debug.core 2 0 2022-11-13 16:27:01.926
!MESSAGE Compile error during code evaluation: The type java.util.TimSort is ambiguous

!ENTRY org.eclipse.debug.core 2 0 2022-11-13 16:27:01.939
!MESSAGE Compile error during code evaluation: The type java.util.TimSort is ambiguous

!ENTRY org.eclipse.debug.core 2 0 2022-11-13 16:27:01.949
!MESSAGE Compile error during code evaluation: The type java.util.TimSort is ambiguous

!ENTRY org.eclipse.jdt.core 4 2 2022-11-13 16:42:04.701
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core".
!STACK 0
org.eclipse.core.runtime.AssertionFailedException: null argument:
	at org.eclipse.core.runtime.Assert.isNotNull(Assert.java:88)
	at org.eclipse.core.runtime.Assert.isNotNull(Assert.java:76)
	at org.eclipse.jdt.ui.text.folding.DefaultJavaFoldingStructureProvider.computeCurrentStructure(DefaultJavaFoldingStructureProvider.java:1403)
	at org.eclipse.jdt.ui.text.folding.DefaultJavaFoldingStructureProvider.update(DefaultJavaFoldingStructureProvider.java:900)
	at org.eclipse.jdt.ui.text.folding.DefaultJavaFoldingStructureProvider$ElementChangedListener.elementChanged(DefaultJavaFoldingStructureProvider.java:368)
	at org.eclipse.jdt.internal.core.DeltaProcessor$3.run(DeltaProcessor.java:1755)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.core.DeltaProcessor.notifyListeners(DeltaProcessor.java:1743)
	at org.eclipse.jdt.internal.core.DeltaProcessor.fireReconcileDelta(DeltaProcessor.java:1594)
	at org.eclipse.jdt.internal.core.DeltaProcessor.fire(DeltaProcessor.java:1553)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:781)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2022-11-13 16:42:04.716
!MESSAGE Exception occurred in listener of Java element change notification
!STACK 0
org.eclipse.core.runtime.AssertionFailedException: null argument:
	at org.eclipse.core.runtime.Assert.isNotNull(Assert.java:88)
	at org.eclipse.core.runtime.Assert.isNotNull(Assert.java:76)
	at org.eclipse.jdt.ui.text.folding.DefaultJavaFoldingStructureProvider.computeCurrentStructure(DefaultJavaFoldingStructureProvider.java:1403)
	at org.eclipse.jdt.ui.text.folding.DefaultJavaFoldingStructureProvider.update(DefaultJavaFoldingStructureProvider.java:900)
	at org.eclipse.jdt.ui.text.folding.DefaultJavaFoldingStructureProvider$ElementChangedListener.elementChanged(DefaultJavaFoldingStructureProvider.java:368)
	at org.eclipse.jdt.internal.core.DeltaProcessor$3.run(DeltaProcessor.java:1755)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.core.DeltaProcessor.notifyListeners(DeltaProcessor.java:1743)
	at org.eclipse.jdt.internal.core.DeltaProcessor.fireReconcileDelta(DeltaProcessor.java:1594)
	at org.eclipse.jdt.internal.core.DeltaProcessor.fire(DeltaProcessor.java:1553)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:781)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
!SESSION 2022-11-14 07:39:48.805 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=18
java.vendor=Oracle Corporation
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/arnavgupta/.eclipse_keyring
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/arnavgupta/.eclipse_keyring

!ENTRY org.eclipse.jface 2 0 2022-11-14 07:39:55.401
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-14 07:39:55.401
!MESSAGE A conflict occurred for COMMAND+SHIFT+T:
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@241d1052,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7b3c0ecb,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-14 07:39:55.401
!MESSAGE A conflict occurred for ALT+COMMAND+R:
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5bb99d1d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3006bfb,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)
!SESSION 2022-11-14 14:21:22.312 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=18
java.vendor=Oracle Corporation
BootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -keyring /Users/arnavgupta/.eclipse_keyring
Command-line arguments:  -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.java.product -keyring /Users/arnavgupta/.eclipse_keyring

!ENTRY org.eclipse.jface 2 0 2022-11-14 14:21:28.719
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-14 14:21:28.719
!MESSAGE A conflict occurred for COMMAND+SHIFT+T:
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@78b9155e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2ceb68a1,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-11-14 14:21:28.719
!MESSAGE A conflict occurred for ALT+COMMAND+R:
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6de33fde,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@69c33ea2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)

!ENTRY org.eclipse.jdt.debug.ui 4 150 2022-11-14 14:42:04.902
!MESSAGE Internal Error
!STACK 1
org.eclipse.debug.core.DebugException: Invalid stack frame
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getUnderlyingStackFrame(JDIStackFrame.java:1371)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getUnderlyingThisObject(JDIStackFrame.java:1006)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getVariables0(JDIStackFrame.java:369)
	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getVariables(JDIStackFrame.java:307)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.containsVariable(JavaDebugHover.java:620)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.lambda$2(JavaDebugHover.java:639)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.findFirstFrameForVariable(JavaDebugHover.java:604)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:469)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SUBENTRY 1 org.eclipse.jdt.debug 4 100 2022-11-14 14:42:04.906
!MESSAGE Invalid stack frame
